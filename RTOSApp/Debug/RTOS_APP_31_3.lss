
RTOS_APP_31_3.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00006e66  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         000001a8  00800060  00006e66  00006efa  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000054d  00800208  00800208  000070a2  2**0
                  ALLOC
  3 .stab         00009954  00000000  00000000  000070a4  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      0000495a  00000000  00000000  000109f8  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 000001c0  00000000  00000000  00015352  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 0000020e  00000000  00000000  00015512  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   0000268b  00000000  00000000  00015720  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 000014d1  00000000  00000000  00017dab  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   000012ab  00000000  00000000  0001927c  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  000001e0  00000000  00000000  0001a528  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    000002fb  00000000  00000000  0001a708  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    00000a0a  00000000  00000000  0001aa03  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000050  00000000  00000000  0001b40d  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 c3 27 	jmp	0x4f86	; 0x4f86 <__vector_1>
       8:	0c 94 f0 27 	jmp	0x4fe0	; 0x4fe0 <__vector_2>
       c:	0c 94 1d 28 	jmp	0x503a	; 0x503a <__vector_3>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 83 13 	jmp	0x2706	; 0x2706 <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 d1 32 	jmp	0x65a2	; 0x65a2 <__vector_11>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 07 34 	jmp	0x680e	; 0x680e <__vector_13>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	12 e0       	ldi	r17, 0x02	; 2
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e6 e6       	ldi	r30, 0x66	; 102
      68:	fe e6       	ldi	r31, 0x6E	; 110
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	a8 30       	cpi	r26, 0x08	; 8
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	17 e0       	ldi	r17, 0x07	; 7
      78:	a8 e0       	ldi	r26, 0x08	; 8
      7a:	b2 e0       	ldi	r27, 0x02	; 2
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a5 35       	cpi	r26, 0x55	; 85
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 3b 34 	call	0x6876	; 0x6876 <main>
      8a:	0c 94 31 37 	jmp	0x6e62	; 0x6e62 <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <__fixunssfsi>:
      92:	ef 92       	push	r14
      94:	ff 92       	push	r15
      96:	0f 93       	push	r16
      98:	1f 93       	push	r17
      9a:	7b 01       	movw	r14, r22
      9c:	8c 01       	movw	r16, r24
      9e:	20 e0       	ldi	r18, 0x00	; 0
      a0:	30 e0       	ldi	r19, 0x00	; 0
      a2:	40 e0       	ldi	r20, 0x00	; 0
      a4:	5f e4       	ldi	r21, 0x4F	; 79
      a6:	0e 94 f5 03 	call	0x7ea	; 0x7ea <__gesf2>
      aa:	88 23       	and	r24, r24
      ac:	8c f0       	brlt	.+34     	; 0xd0 <__fixunssfsi+0x3e>
      ae:	c8 01       	movw	r24, r16
      b0:	b7 01       	movw	r22, r14
      b2:	20 e0       	ldi	r18, 0x00	; 0
      b4:	30 e0       	ldi	r19, 0x00	; 0
      b6:	40 e0       	ldi	r20, 0x00	; 0
      b8:	5f e4       	ldi	r21, 0x4F	; 79
      ba:	0e 94 c1 01 	call	0x382	; 0x382 <__subsf3>
      be:	0e 94 e3 04 	call	0x9c6	; 0x9c6 <__fixsfsi>
      c2:	9b 01       	movw	r18, r22
      c4:	ac 01       	movw	r20, r24
      c6:	20 50       	subi	r18, 0x00	; 0
      c8:	30 40       	sbci	r19, 0x00	; 0
      ca:	40 40       	sbci	r20, 0x00	; 0
      cc:	50 48       	sbci	r21, 0x80	; 128
      ce:	06 c0       	rjmp	.+12     	; 0xdc <__fixunssfsi+0x4a>
      d0:	c8 01       	movw	r24, r16
      d2:	b7 01       	movw	r22, r14
      d4:	0e 94 e3 04 	call	0x9c6	; 0x9c6 <__fixsfsi>
      d8:	9b 01       	movw	r18, r22
      da:	ac 01       	movw	r20, r24
      dc:	b9 01       	movw	r22, r18
      de:	ca 01       	movw	r24, r20
      e0:	1f 91       	pop	r17
      e2:	0f 91       	pop	r16
      e4:	ff 90       	pop	r15
      e6:	ef 90       	pop	r14
      e8:	08 95       	ret

000000ea <_fpadd_parts>:
      ea:	a0 e0       	ldi	r26, 0x00	; 0
      ec:	b0 e0       	ldi	r27, 0x00	; 0
      ee:	eb e7       	ldi	r30, 0x7B	; 123
      f0:	f0 e0       	ldi	r31, 0x00	; 0
      f2:	0c 94 ac 36 	jmp	0x6d58	; 0x6d58 <__prologue_saves__>
      f6:	dc 01       	movw	r26, r24
      f8:	2b 01       	movw	r4, r22
      fa:	fa 01       	movw	r30, r20
      fc:	9c 91       	ld	r25, X
      fe:	92 30       	cpi	r25, 0x02	; 2
     100:	08 f4       	brcc	.+2      	; 0x104 <_fpadd_parts+0x1a>
     102:	39 c1       	rjmp	.+626    	; 0x376 <_fpadd_parts+0x28c>
     104:	eb 01       	movw	r28, r22
     106:	88 81       	ld	r24, Y
     108:	82 30       	cpi	r24, 0x02	; 2
     10a:	08 f4       	brcc	.+2      	; 0x10e <_fpadd_parts+0x24>
     10c:	33 c1       	rjmp	.+614    	; 0x374 <_fpadd_parts+0x28a>
     10e:	94 30       	cpi	r25, 0x04	; 4
     110:	69 f4       	brne	.+26     	; 0x12c <_fpadd_parts+0x42>
     112:	84 30       	cpi	r24, 0x04	; 4
     114:	09 f0       	breq	.+2      	; 0x118 <_fpadd_parts+0x2e>
     116:	2f c1       	rjmp	.+606    	; 0x376 <_fpadd_parts+0x28c>
     118:	11 96       	adiw	r26, 0x01	; 1
     11a:	9c 91       	ld	r25, X
     11c:	11 97       	sbiw	r26, 0x01	; 1
     11e:	89 81       	ldd	r24, Y+1	; 0x01
     120:	98 17       	cp	r25, r24
     122:	09 f4       	brne	.+2      	; 0x126 <_fpadd_parts+0x3c>
     124:	28 c1       	rjmp	.+592    	; 0x376 <_fpadd_parts+0x28c>
     126:	a3 ee       	ldi	r26, 0xE3	; 227
     128:	b0 e0       	ldi	r27, 0x00	; 0
     12a:	25 c1       	rjmp	.+586    	; 0x376 <_fpadd_parts+0x28c>
     12c:	84 30       	cpi	r24, 0x04	; 4
     12e:	09 f4       	brne	.+2      	; 0x132 <_fpadd_parts+0x48>
     130:	21 c1       	rjmp	.+578    	; 0x374 <_fpadd_parts+0x28a>
     132:	82 30       	cpi	r24, 0x02	; 2
     134:	a9 f4       	brne	.+42     	; 0x160 <_fpadd_parts+0x76>
     136:	92 30       	cpi	r25, 0x02	; 2
     138:	09 f0       	breq	.+2      	; 0x13c <_fpadd_parts+0x52>
     13a:	1d c1       	rjmp	.+570    	; 0x376 <_fpadd_parts+0x28c>
     13c:	9a 01       	movw	r18, r20
     13e:	ad 01       	movw	r20, r26
     140:	88 e0       	ldi	r24, 0x08	; 8
     142:	ea 01       	movw	r28, r20
     144:	09 90       	ld	r0, Y+
     146:	ae 01       	movw	r20, r28
     148:	e9 01       	movw	r28, r18
     14a:	09 92       	st	Y+, r0
     14c:	9e 01       	movw	r18, r28
     14e:	81 50       	subi	r24, 0x01	; 1
     150:	c1 f7       	brne	.-16     	; 0x142 <_fpadd_parts+0x58>
     152:	e2 01       	movw	r28, r4
     154:	89 81       	ldd	r24, Y+1	; 0x01
     156:	11 96       	adiw	r26, 0x01	; 1
     158:	9c 91       	ld	r25, X
     15a:	89 23       	and	r24, r25
     15c:	81 83       	std	Z+1, r24	; 0x01
     15e:	08 c1       	rjmp	.+528    	; 0x370 <_fpadd_parts+0x286>
     160:	92 30       	cpi	r25, 0x02	; 2
     162:	09 f4       	brne	.+2      	; 0x166 <_fpadd_parts+0x7c>
     164:	07 c1       	rjmp	.+526    	; 0x374 <_fpadd_parts+0x28a>
     166:	12 96       	adiw	r26, 0x02	; 2
     168:	2d 90       	ld	r2, X+
     16a:	3c 90       	ld	r3, X
     16c:	13 97       	sbiw	r26, 0x03	; 3
     16e:	eb 01       	movw	r28, r22
     170:	8a 81       	ldd	r24, Y+2	; 0x02
     172:	9b 81       	ldd	r25, Y+3	; 0x03
     174:	14 96       	adiw	r26, 0x04	; 4
     176:	ad 90       	ld	r10, X+
     178:	bd 90       	ld	r11, X+
     17a:	cd 90       	ld	r12, X+
     17c:	dc 90       	ld	r13, X
     17e:	17 97       	sbiw	r26, 0x07	; 7
     180:	ec 80       	ldd	r14, Y+4	; 0x04
     182:	fd 80       	ldd	r15, Y+5	; 0x05
     184:	0e 81       	ldd	r16, Y+6	; 0x06
     186:	1f 81       	ldd	r17, Y+7	; 0x07
     188:	91 01       	movw	r18, r2
     18a:	28 1b       	sub	r18, r24
     18c:	39 0b       	sbc	r19, r25
     18e:	b9 01       	movw	r22, r18
     190:	37 ff       	sbrs	r19, 7
     192:	04 c0       	rjmp	.+8      	; 0x19c <_fpadd_parts+0xb2>
     194:	66 27       	eor	r22, r22
     196:	77 27       	eor	r23, r23
     198:	62 1b       	sub	r22, r18
     19a:	73 0b       	sbc	r23, r19
     19c:	60 32       	cpi	r22, 0x20	; 32
     19e:	71 05       	cpc	r23, r1
     1a0:	0c f0       	brlt	.+2      	; 0x1a4 <_fpadd_parts+0xba>
     1a2:	61 c0       	rjmp	.+194    	; 0x266 <_fpadd_parts+0x17c>
     1a4:	12 16       	cp	r1, r18
     1a6:	13 06       	cpc	r1, r19
     1a8:	6c f5       	brge	.+90     	; 0x204 <_fpadd_parts+0x11a>
     1aa:	37 01       	movw	r6, r14
     1ac:	48 01       	movw	r8, r16
     1ae:	06 2e       	mov	r0, r22
     1b0:	04 c0       	rjmp	.+8      	; 0x1ba <_fpadd_parts+0xd0>
     1b2:	96 94       	lsr	r9
     1b4:	87 94       	ror	r8
     1b6:	77 94       	ror	r7
     1b8:	67 94       	ror	r6
     1ba:	0a 94       	dec	r0
     1bc:	d2 f7       	brpl	.-12     	; 0x1b2 <_fpadd_parts+0xc8>
     1be:	21 e0       	ldi	r18, 0x01	; 1
     1c0:	30 e0       	ldi	r19, 0x00	; 0
     1c2:	40 e0       	ldi	r20, 0x00	; 0
     1c4:	50 e0       	ldi	r21, 0x00	; 0
     1c6:	04 c0       	rjmp	.+8      	; 0x1d0 <_fpadd_parts+0xe6>
     1c8:	22 0f       	add	r18, r18
     1ca:	33 1f       	adc	r19, r19
     1cc:	44 1f       	adc	r20, r20
     1ce:	55 1f       	adc	r21, r21
     1d0:	6a 95       	dec	r22
     1d2:	d2 f7       	brpl	.-12     	; 0x1c8 <_fpadd_parts+0xde>
     1d4:	21 50       	subi	r18, 0x01	; 1
     1d6:	30 40       	sbci	r19, 0x00	; 0
     1d8:	40 40       	sbci	r20, 0x00	; 0
     1da:	50 40       	sbci	r21, 0x00	; 0
     1dc:	2e 21       	and	r18, r14
     1de:	3f 21       	and	r19, r15
     1e0:	40 23       	and	r20, r16
     1e2:	51 23       	and	r21, r17
     1e4:	21 15       	cp	r18, r1
     1e6:	31 05       	cpc	r19, r1
     1e8:	41 05       	cpc	r20, r1
     1ea:	51 05       	cpc	r21, r1
     1ec:	21 f0       	breq	.+8      	; 0x1f6 <_fpadd_parts+0x10c>
     1ee:	21 e0       	ldi	r18, 0x01	; 1
     1f0:	30 e0       	ldi	r19, 0x00	; 0
     1f2:	40 e0       	ldi	r20, 0x00	; 0
     1f4:	50 e0       	ldi	r21, 0x00	; 0
     1f6:	79 01       	movw	r14, r18
     1f8:	8a 01       	movw	r16, r20
     1fa:	e6 28       	or	r14, r6
     1fc:	f7 28       	or	r15, r7
     1fe:	08 29       	or	r16, r8
     200:	19 29       	or	r17, r9
     202:	3c c0       	rjmp	.+120    	; 0x27c <_fpadd_parts+0x192>
     204:	23 2b       	or	r18, r19
     206:	d1 f1       	breq	.+116    	; 0x27c <_fpadd_parts+0x192>
     208:	26 0e       	add	r2, r22
     20a:	37 1e       	adc	r3, r23
     20c:	35 01       	movw	r6, r10
     20e:	46 01       	movw	r8, r12
     210:	06 2e       	mov	r0, r22
     212:	04 c0       	rjmp	.+8      	; 0x21c <_fpadd_parts+0x132>
     214:	96 94       	lsr	r9
     216:	87 94       	ror	r8
     218:	77 94       	ror	r7
     21a:	67 94       	ror	r6
     21c:	0a 94       	dec	r0
     21e:	d2 f7       	brpl	.-12     	; 0x214 <_fpadd_parts+0x12a>
     220:	21 e0       	ldi	r18, 0x01	; 1
     222:	30 e0       	ldi	r19, 0x00	; 0
     224:	40 e0       	ldi	r20, 0x00	; 0
     226:	50 e0       	ldi	r21, 0x00	; 0
     228:	04 c0       	rjmp	.+8      	; 0x232 <_fpadd_parts+0x148>
     22a:	22 0f       	add	r18, r18
     22c:	33 1f       	adc	r19, r19
     22e:	44 1f       	adc	r20, r20
     230:	55 1f       	adc	r21, r21
     232:	6a 95       	dec	r22
     234:	d2 f7       	brpl	.-12     	; 0x22a <_fpadd_parts+0x140>
     236:	21 50       	subi	r18, 0x01	; 1
     238:	30 40       	sbci	r19, 0x00	; 0
     23a:	40 40       	sbci	r20, 0x00	; 0
     23c:	50 40       	sbci	r21, 0x00	; 0
     23e:	2a 21       	and	r18, r10
     240:	3b 21       	and	r19, r11
     242:	4c 21       	and	r20, r12
     244:	5d 21       	and	r21, r13
     246:	21 15       	cp	r18, r1
     248:	31 05       	cpc	r19, r1
     24a:	41 05       	cpc	r20, r1
     24c:	51 05       	cpc	r21, r1
     24e:	21 f0       	breq	.+8      	; 0x258 <_fpadd_parts+0x16e>
     250:	21 e0       	ldi	r18, 0x01	; 1
     252:	30 e0       	ldi	r19, 0x00	; 0
     254:	40 e0       	ldi	r20, 0x00	; 0
     256:	50 e0       	ldi	r21, 0x00	; 0
     258:	59 01       	movw	r10, r18
     25a:	6a 01       	movw	r12, r20
     25c:	a6 28       	or	r10, r6
     25e:	b7 28       	or	r11, r7
     260:	c8 28       	or	r12, r8
     262:	d9 28       	or	r13, r9
     264:	0b c0       	rjmp	.+22     	; 0x27c <_fpadd_parts+0x192>
     266:	82 15       	cp	r24, r2
     268:	93 05       	cpc	r25, r3
     26a:	2c f0       	brlt	.+10     	; 0x276 <_fpadd_parts+0x18c>
     26c:	1c 01       	movw	r2, r24
     26e:	aa 24       	eor	r10, r10
     270:	bb 24       	eor	r11, r11
     272:	65 01       	movw	r12, r10
     274:	03 c0       	rjmp	.+6      	; 0x27c <_fpadd_parts+0x192>
     276:	ee 24       	eor	r14, r14
     278:	ff 24       	eor	r15, r15
     27a:	87 01       	movw	r16, r14
     27c:	11 96       	adiw	r26, 0x01	; 1
     27e:	9c 91       	ld	r25, X
     280:	d2 01       	movw	r26, r4
     282:	11 96       	adiw	r26, 0x01	; 1
     284:	8c 91       	ld	r24, X
     286:	98 17       	cp	r25, r24
     288:	09 f4       	brne	.+2      	; 0x28c <_fpadd_parts+0x1a2>
     28a:	45 c0       	rjmp	.+138    	; 0x316 <_fpadd_parts+0x22c>
     28c:	99 23       	and	r25, r25
     28e:	39 f0       	breq	.+14     	; 0x29e <_fpadd_parts+0x1b4>
     290:	a8 01       	movw	r20, r16
     292:	97 01       	movw	r18, r14
     294:	2a 19       	sub	r18, r10
     296:	3b 09       	sbc	r19, r11
     298:	4c 09       	sbc	r20, r12
     29a:	5d 09       	sbc	r21, r13
     29c:	06 c0       	rjmp	.+12     	; 0x2aa <_fpadd_parts+0x1c0>
     29e:	a6 01       	movw	r20, r12
     2a0:	95 01       	movw	r18, r10
     2a2:	2e 19       	sub	r18, r14
     2a4:	3f 09       	sbc	r19, r15
     2a6:	40 0b       	sbc	r20, r16
     2a8:	51 0b       	sbc	r21, r17
     2aa:	57 fd       	sbrc	r21, 7
     2ac:	08 c0       	rjmp	.+16     	; 0x2be <_fpadd_parts+0x1d4>
     2ae:	11 82       	std	Z+1, r1	; 0x01
     2b0:	33 82       	std	Z+3, r3	; 0x03
     2b2:	22 82       	std	Z+2, r2	; 0x02
     2b4:	24 83       	std	Z+4, r18	; 0x04
     2b6:	35 83       	std	Z+5, r19	; 0x05
     2b8:	46 83       	std	Z+6, r20	; 0x06
     2ba:	57 83       	std	Z+7, r21	; 0x07
     2bc:	1d c0       	rjmp	.+58     	; 0x2f8 <_fpadd_parts+0x20e>
     2be:	81 e0       	ldi	r24, 0x01	; 1
     2c0:	81 83       	std	Z+1, r24	; 0x01
     2c2:	33 82       	std	Z+3, r3	; 0x03
     2c4:	22 82       	std	Z+2, r2	; 0x02
     2c6:	88 27       	eor	r24, r24
     2c8:	99 27       	eor	r25, r25
     2ca:	dc 01       	movw	r26, r24
     2cc:	82 1b       	sub	r24, r18
     2ce:	93 0b       	sbc	r25, r19
     2d0:	a4 0b       	sbc	r26, r20
     2d2:	b5 0b       	sbc	r27, r21
     2d4:	84 83       	std	Z+4, r24	; 0x04
     2d6:	95 83       	std	Z+5, r25	; 0x05
     2d8:	a6 83       	std	Z+6, r26	; 0x06
     2da:	b7 83       	std	Z+7, r27	; 0x07
     2dc:	0d c0       	rjmp	.+26     	; 0x2f8 <_fpadd_parts+0x20e>
     2de:	22 0f       	add	r18, r18
     2e0:	33 1f       	adc	r19, r19
     2e2:	44 1f       	adc	r20, r20
     2e4:	55 1f       	adc	r21, r21
     2e6:	24 83       	std	Z+4, r18	; 0x04
     2e8:	35 83       	std	Z+5, r19	; 0x05
     2ea:	46 83       	std	Z+6, r20	; 0x06
     2ec:	57 83       	std	Z+7, r21	; 0x07
     2ee:	82 81       	ldd	r24, Z+2	; 0x02
     2f0:	93 81       	ldd	r25, Z+3	; 0x03
     2f2:	01 97       	sbiw	r24, 0x01	; 1
     2f4:	93 83       	std	Z+3, r25	; 0x03
     2f6:	82 83       	std	Z+2, r24	; 0x02
     2f8:	24 81       	ldd	r18, Z+4	; 0x04
     2fa:	35 81       	ldd	r19, Z+5	; 0x05
     2fc:	46 81       	ldd	r20, Z+6	; 0x06
     2fe:	57 81       	ldd	r21, Z+7	; 0x07
     300:	da 01       	movw	r26, r20
     302:	c9 01       	movw	r24, r18
     304:	01 97       	sbiw	r24, 0x01	; 1
     306:	a1 09       	sbc	r26, r1
     308:	b1 09       	sbc	r27, r1
     30a:	8f 5f       	subi	r24, 0xFF	; 255
     30c:	9f 4f       	sbci	r25, 0xFF	; 255
     30e:	af 4f       	sbci	r26, 0xFF	; 255
     310:	bf 43       	sbci	r27, 0x3F	; 63
     312:	28 f3       	brcs	.-54     	; 0x2de <_fpadd_parts+0x1f4>
     314:	0b c0       	rjmp	.+22     	; 0x32c <_fpadd_parts+0x242>
     316:	91 83       	std	Z+1, r25	; 0x01
     318:	33 82       	std	Z+3, r3	; 0x03
     31a:	22 82       	std	Z+2, r2	; 0x02
     31c:	ea 0c       	add	r14, r10
     31e:	fb 1c       	adc	r15, r11
     320:	0c 1d       	adc	r16, r12
     322:	1d 1d       	adc	r17, r13
     324:	e4 82       	std	Z+4, r14	; 0x04
     326:	f5 82       	std	Z+5, r15	; 0x05
     328:	06 83       	std	Z+6, r16	; 0x06
     32a:	17 83       	std	Z+7, r17	; 0x07
     32c:	83 e0       	ldi	r24, 0x03	; 3
     32e:	80 83       	st	Z, r24
     330:	24 81       	ldd	r18, Z+4	; 0x04
     332:	35 81       	ldd	r19, Z+5	; 0x05
     334:	46 81       	ldd	r20, Z+6	; 0x06
     336:	57 81       	ldd	r21, Z+7	; 0x07
     338:	57 ff       	sbrs	r21, 7
     33a:	1a c0       	rjmp	.+52     	; 0x370 <_fpadd_parts+0x286>
     33c:	c9 01       	movw	r24, r18
     33e:	aa 27       	eor	r26, r26
     340:	97 fd       	sbrc	r25, 7
     342:	a0 95       	com	r26
     344:	ba 2f       	mov	r27, r26
     346:	81 70       	andi	r24, 0x01	; 1
     348:	90 70       	andi	r25, 0x00	; 0
     34a:	a0 70       	andi	r26, 0x00	; 0
     34c:	b0 70       	andi	r27, 0x00	; 0
     34e:	56 95       	lsr	r21
     350:	47 95       	ror	r20
     352:	37 95       	ror	r19
     354:	27 95       	ror	r18
     356:	82 2b       	or	r24, r18
     358:	93 2b       	or	r25, r19
     35a:	a4 2b       	or	r26, r20
     35c:	b5 2b       	or	r27, r21
     35e:	84 83       	std	Z+4, r24	; 0x04
     360:	95 83       	std	Z+5, r25	; 0x05
     362:	a6 83       	std	Z+6, r26	; 0x06
     364:	b7 83       	std	Z+7, r27	; 0x07
     366:	82 81       	ldd	r24, Z+2	; 0x02
     368:	93 81       	ldd	r25, Z+3	; 0x03
     36a:	01 96       	adiw	r24, 0x01	; 1
     36c:	93 83       	std	Z+3, r25	; 0x03
     36e:	82 83       	std	Z+2, r24	; 0x02
     370:	df 01       	movw	r26, r30
     372:	01 c0       	rjmp	.+2      	; 0x376 <_fpadd_parts+0x28c>
     374:	d2 01       	movw	r26, r4
     376:	cd 01       	movw	r24, r26
     378:	cd b7       	in	r28, 0x3d	; 61
     37a:	de b7       	in	r29, 0x3e	; 62
     37c:	e2 e1       	ldi	r30, 0x12	; 18
     37e:	0c 94 c8 36 	jmp	0x6d90	; 0x6d90 <__epilogue_restores__>

00000382 <__subsf3>:
     382:	a0 e2       	ldi	r26, 0x20	; 32
     384:	b0 e0       	ldi	r27, 0x00	; 0
     386:	e7 ec       	ldi	r30, 0xC7	; 199
     388:	f1 e0       	ldi	r31, 0x01	; 1
     38a:	0c 94 b8 36 	jmp	0x6d70	; 0x6d70 <__prologue_saves__+0x18>
     38e:	69 83       	std	Y+1, r22	; 0x01
     390:	7a 83       	std	Y+2, r23	; 0x02
     392:	8b 83       	std	Y+3, r24	; 0x03
     394:	9c 83       	std	Y+4, r25	; 0x04
     396:	2d 83       	std	Y+5, r18	; 0x05
     398:	3e 83       	std	Y+6, r19	; 0x06
     39a:	4f 83       	std	Y+7, r20	; 0x07
     39c:	58 87       	std	Y+8, r21	; 0x08
     39e:	e9 e0       	ldi	r30, 0x09	; 9
     3a0:	ee 2e       	mov	r14, r30
     3a2:	f1 2c       	mov	r15, r1
     3a4:	ec 0e       	add	r14, r28
     3a6:	fd 1e       	adc	r15, r29
     3a8:	ce 01       	movw	r24, r28
     3aa:	01 96       	adiw	r24, 0x01	; 1
     3ac:	b7 01       	movw	r22, r14
     3ae:	0e 94 5b 06 	call	0xcb6	; 0xcb6 <__unpack_f>
     3b2:	8e 01       	movw	r16, r28
     3b4:	0f 5e       	subi	r16, 0xEF	; 239
     3b6:	1f 4f       	sbci	r17, 0xFF	; 255
     3b8:	ce 01       	movw	r24, r28
     3ba:	05 96       	adiw	r24, 0x05	; 5
     3bc:	b8 01       	movw	r22, r16
     3be:	0e 94 5b 06 	call	0xcb6	; 0xcb6 <__unpack_f>
     3c2:	8a 89       	ldd	r24, Y+18	; 0x12
     3c4:	91 e0       	ldi	r25, 0x01	; 1
     3c6:	89 27       	eor	r24, r25
     3c8:	8a 8b       	std	Y+18, r24	; 0x12
     3ca:	c7 01       	movw	r24, r14
     3cc:	b8 01       	movw	r22, r16
     3ce:	ae 01       	movw	r20, r28
     3d0:	47 5e       	subi	r20, 0xE7	; 231
     3d2:	5f 4f       	sbci	r21, 0xFF	; 255
     3d4:	0e 94 75 00 	call	0xea	; 0xea <_fpadd_parts>
     3d8:	0e 94 86 05 	call	0xb0c	; 0xb0c <__pack_f>
     3dc:	a0 96       	adiw	r28, 0x20	; 32
     3de:	e6 e0       	ldi	r30, 0x06	; 6
     3e0:	0c 94 d4 36 	jmp	0x6da8	; 0x6da8 <__epilogue_restores__+0x18>

000003e4 <__addsf3>:
     3e4:	a0 e2       	ldi	r26, 0x20	; 32
     3e6:	b0 e0       	ldi	r27, 0x00	; 0
     3e8:	e8 ef       	ldi	r30, 0xF8	; 248
     3ea:	f1 e0       	ldi	r31, 0x01	; 1
     3ec:	0c 94 b8 36 	jmp	0x6d70	; 0x6d70 <__prologue_saves__+0x18>
     3f0:	69 83       	std	Y+1, r22	; 0x01
     3f2:	7a 83       	std	Y+2, r23	; 0x02
     3f4:	8b 83       	std	Y+3, r24	; 0x03
     3f6:	9c 83       	std	Y+4, r25	; 0x04
     3f8:	2d 83       	std	Y+5, r18	; 0x05
     3fa:	3e 83       	std	Y+6, r19	; 0x06
     3fc:	4f 83       	std	Y+7, r20	; 0x07
     3fe:	58 87       	std	Y+8, r21	; 0x08
     400:	f9 e0       	ldi	r31, 0x09	; 9
     402:	ef 2e       	mov	r14, r31
     404:	f1 2c       	mov	r15, r1
     406:	ec 0e       	add	r14, r28
     408:	fd 1e       	adc	r15, r29
     40a:	ce 01       	movw	r24, r28
     40c:	01 96       	adiw	r24, 0x01	; 1
     40e:	b7 01       	movw	r22, r14
     410:	0e 94 5b 06 	call	0xcb6	; 0xcb6 <__unpack_f>
     414:	8e 01       	movw	r16, r28
     416:	0f 5e       	subi	r16, 0xEF	; 239
     418:	1f 4f       	sbci	r17, 0xFF	; 255
     41a:	ce 01       	movw	r24, r28
     41c:	05 96       	adiw	r24, 0x05	; 5
     41e:	b8 01       	movw	r22, r16
     420:	0e 94 5b 06 	call	0xcb6	; 0xcb6 <__unpack_f>
     424:	c7 01       	movw	r24, r14
     426:	b8 01       	movw	r22, r16
     428:	ae 01       	movw	r20, r28
     42a:	47 5e       	subi	r20, 0xE7	; 231
     42c:	5f 4f       	sbci	r21, 0xFF	; 255
     42e:	0e 94 75 00 	call	0xea	; 0xea <_fpadd_parts>
     432:	0e 94 86 05 	call	0xb0c	; 0xb0c <__pack_f>
     436:	a0 96       	adiw	r28, 0x20	; 32
     438:	e6 e0       	ldi	r30, 0x06	; 6
     43a:	0c 94 d4 36 	jmp	0x6da8	; 0x6da8 <__epilogue_restores__+0x18>

0000043e <__mulsf3>:
     43e:	a0 e2       	ldi	r26, 0x20	; 32
     440:	b0 e0       	ldi	r27, 0x00	; 0
     442:	e5 e2       	ldi	r30, 0x25	; 37
     444:	f2 e0       	ldi	r31, 0x02	; 2
     446:	0c 94 ac 36 	jmp	0x6d58	; 0x6d58 <__prologue_saves__>
     44a:	69 83       	std	Y+1, r22	; 0x01
     44c:	7a 83       	std	Y+2, r23	; 0x02
     44e:	8b 83       	std	Y+3, r24	; 0x03
     450:	9c 83       	std	Y+4, r25	; 0x04
     452:	2d 83       	std	Y+5, r18	; 0x05
     454:	3e 83       	std	Y+6, r19	; 0x06
     456:	4f 83       	std	Y+7, r20	; 0x07
     458:	58 87       	std	Y+8, r21	; 0x08
     45a:	ce 01       	movw	r24, r28
     45c:	01 96       	adiw	r24, 0x01	; 1
     45e:	be 01       	movw	r22, r28
     460:	67 5f       	subi	r22, 0xF7	; 247
     462:	7f 4f       	sbci	r23, 0xFF	; 255
     464:	0e 94 5b 06 	call	0xcb6	; 0xcb6 <__unpack_f>
     468:	ce 01       	movw	r24, r28
     46a:	05 96       	adiw	r24, 0x05	; 5
     46c:	be 01       	movw	r22, r28
     46e:	6f 5e       	subi	r22, 0xEF	; 239
     470:	7f 4f       	sbci	r23, 0xFF	; 255
     472:	0e 94 5b 06 	call	0xcb6	; 0xcb6 <__unpack_f>
     476:	99 85       	ldd	r25, Y+9	; 0x09
     478:	92 30       	cpi	r25, 0x02	; 2
     47a:	88 f0       	brcs	.+34     	; 0x49e <__mulsf3+0x60>
     47c:	89 89       	ldd	r24, Y+17	; 0x11
     47e:	82 30       	cpi	r24, 0x02	; 2
     480:	c8 f0       	brcs	.+50     	; 0x4b4 <__mulsf3+0x76>
     482:	94 30       	cpi	r25, 0x04	; 4
     484:	19 f4       	brne	.+6      	; 0x48c <__mulsf3+0x4e>
     486:	82 30       	cpi	r24, 0x02	; 2
     488:	51 f4       	brne	.+20     	; 0x49e <__mulsf3+0x60>
     48a:	04 c0       	rjmp	.+8      	; 0x494 <__mulsf3+0x56>
     48c:	84 30       	cpi	r24, 0x04	; 4
     48e:	29 f4       	brne	.+10     	; 0x49a <__mulsf3+0x5c>
     490:	92 30       	cpi	r25, 0x02	; 2
     492:	81 f4       	brne	.+32     	; 0x4b4 <__mulsf3+0x76>
     494:	83 ee       	ldi	r24, 0xE3	; 227
     496:	90 e0       	ldi	r25, 0x00	; 0
     498:	c6 c0       	rjmp	.+396    	; 0x626 <__mulsf3+0x1e8>
     49a:	92 30       	cpi	r25, 0x02	; 2
     49c:	49 f4       	brne	.+18     	; 0x4b0 <__mulsf3+0x72>
     49e:	20 e0       	ldi	r18, 0x00	; 0
     4a0:	9a 85       	ldd	r25, Y+10	; 0x0a
     4a2:	8a 89       	ldd	r24, Y+18	; 0x12
     4a4:	98 13       	cpse	r25, r24
     4a6:	21 e0       	ldi	r18, 0x01	; 1
     4a8:	2a 87       	std	Y+10, r18	; 0x0a
     4aa:	ce 01       	movw	r24, r28
     4ac:	09 96       	adiw	r24, 0x09	; 9
     4ae:	bb c0       	rjmp	.+374    	; 0x626 <__mulsf3+0x1e8>
     4b0:	82 30       	cpi	r24, 0x02	; 2
     4b2:	49 f4       	brne	.+18     	; 0x4c6 <__mulsf3+0x88>
     4b4:	20 e0       	ldi	r18, 0x00	; 0
     4b6:	9a 85       	ldd	r25, Y+10	; 0x0a
     4b8:	8a 89       	ldd	r24, Y+18	; 0x12
     4ba:	98 13       	cpse	r25, r24
     4bc:	21 e0       	ldi	r18, 0x01	; 1
     4be:	2a 8b       	std	Y+18, r18	; 0x12
     4c0:	ce 01       	movw	r24, r28
     4c2:	41 96       	adiw	r24, 0x11	; 17
     4c4:	b0 c0       	rjmp	.+352    	; 0x626 <__mulsf3+0x1e8>
     4c6:	2d 84       	ldd	r2, Y+13	; 0x0d
     4c8:	3e 84       	ldd	r3, Y+14	; 0x0e
     4ca:	4f 84       	ldd	r4, Y+15	; 0x0f
     4cc:	58 88       	ldd	r5, Y+16	; 0x10
     4ce:	6d 88       	ldd	r6, Y+21	; 0x15
     4d0:	7e 88       	ldd	r7, Y+22	; 0x16
     4d2:	8f 88       	ldd	r8, Y+23	; 0x17
     4d4:	98 8c       	ldd	r9, Y+24	; 0x18
     4d6:	ee 24       	eor	r14, r14
     4d8:	ff 24       	eor	r15, r15
     4da:	87 01       	movw	r16, r14
     4dc:	aa 24       	eor	r10, r10
     4de:	bb 24       	eor	r11, r11
     4e0:	65 01       	movw	r12, r10
     4e2:	40 e0       	ldi	r20, 0x00	; 0
     4e4:	50 e0       	ldi	r21, 0x00	; 0
     4e6:	60 e0       	ldi	r22, 0x00	; 0
     4e8:	70 e0       	ldi	r23, 0x00	; 0
     4ea:	e0 e0       	ldi	r30, 0x00	; 0
     4ec:	f0 e0       	ldi	r31, 0x00	; 0
     4ee:	c1 01       	movw	r24, r2
     4f0:	81 70       	andi	r24, 0x01	; 1
     4f2:	90 70       	andi	r25, 0x00	; 0
     4f4:	89 2b       	or	r24, r25
     4f6:	e9 f0       	breq	.+58     	; 0x532 <__mulsf3+0xf4>
     4f8:	e6 0c       	add	r14, r6
     4fa:	f7 1c       	adc	r15, r7
     4fc:	08 1d       	adc	r16, r8
     4fe:	19 1d       	adc	r17, r9
     500:	9a 01       	movw	r18, r20
     502:	ab 01       	movw	r20, r22
     504:	2a 0d       	add	r18, r10
     506:	3b 1d       	adc	r19, r11
     508:	4c 1d       	adc	r20, r12
     50a:	5d 1d       	adc	r21, r13
     50c:	80 e0       	ldi	r24, 0x00	; 0
     50e:	90 e0       	ldi	r25, 0x00	; 0
     510:	a0 e0       	ldi	r26, 0x00	; 0
     512:	b0 e0       	ldi	r27, 0x00	; 0
     514:	e6 14       	cp	r14, r6
     516:	f7 04       	cpc	r15, r7
     518:	08 05       	cpc	r16, r8
     51a:	19 05       	cpc	r17, r9
     51c:	20 f4       	brcc	.+8      	; 0x526 <__mulsf3+0xe8>
     51e:	81 e0       	ldi	r24, 0x01	; 1
     520:	90 e0       	ldi	r25, 0x00	; 0
     522:	a0 e0       	ldi	r26, 0x00	; 0
     524:	b0 e0       	ldi	r27, 0x00	; 0
     526:	ba 01       	movw	r22, r20
     528:	a9 01       	movw	r20, r18
     52a:	48 0f       	add	r20, r24
     52c:	59 1f       	adc	r21, r25
     52e:	6a 1f       	adc	r22, r26
     530:	7b 1f       	adc	r23, r27
     532:	aa 0c       	add	r10, r10
     534:	bb 1c       	adc	r11, r11
     536:	cc 1c       	adc	r12, r12
     538:	dd 1c       	adc	r13, r13
     53a:	97 fe       	sbrs	r9, 7
     53c:	08 c0       	rjmp	.+16     	; 0x54e <__mulsf3+0x110>
     53e:	81 e0       	ldi	r24, 0x01	; 1
     540:	90 e0       	ldi	r25, 0x00	; 0
     542:	a0 e0       	ldi	r26, 0x00	; 0
     544:	b0 e0       	ldi	r27, 0x00	; 0
     546:	a8 2a       	or	r10, r24
     548:	b9 2a       	or	r11, r25
     54a:	ca 2a       	or	r12, r26
     54c:	db 2a       	or	r13, r27
     54e:	31 96       	adiw	r30, 0x01	; 1
     550:	e0 32       	cpi	r30, 0x20	; 32
     552:	f1 05       	cpc	r31, r1
     554:	49 f0       	breq	.+18     	; 0x568 <__mulsf3+0x12a>
     556:	66 0c       	add	r6, r6
     558:	77 1c       	adc	r7, r7
     55a:	88 1c       	adc	r8, r8
     55c:	99 1c       	adc	r9, r9
     55e:	56 94       	lsr	r5
     560:	47 94       	ror	r4
     562:	37 94       	ror	r3
     564:	27 94       	ror	r2
     566:	c3 cf       	rjmp	.-122    	; 0x4ee <__mulsf3+0xb0>
     568:	fa 85       	ldd	r31, Y+10	; 0x0a
     56a:	ea 89       	ldd	r30, Y+18	; 0x12
     56c:	2b 89       	ldd	r18, Y+19	; 0x13
     56e:	3c 89       	ldd	r19, Y+20	; 0x14
     570:	8b 85       	ldd	r24, Y+11	; 0x0b
     572:	9c 85       	ldd	r25, Y+12	; 0x0c
     574:	28 0f       	add	r18, r24
     576:	39 1f       	adc	r19, r25
     578:	2e 5f       	subi	r18, 0xFE	; 254
     57a:	3f 4f       	sbci	r19, 0xFF	; 255
     57c:	17 c0       	rjmp	.+46     	; 0x5ac <__mulsf3+0x16e>
     57e:	ca 01       	movw	r24, r20
     580:	81 70       	andi	r24, 0x01	; 1
     582:	90 70       	andi	r25, 0x00	; 0
     584:	89 2b       	or	r24, r25
     586:	61 f0       	breq	.+24     	; 0x5a0 <__mulsf3+0x162>
     588:	16 95       	lsr	r17
     58a:	07 95       	ror	r16
     58c:	f7 94       	ror	r15
     58e:	e7 94       	ror	r14
     590:	80 e0       	ldi	r24, 0x00	; 0
     592:	90 e0       	ldi	r25, 0x00	; 0
     594:	a0 e0       	ldi	r26, 0x00	; 0
     596:	b0 e8       	ldi	r27, 0x80	; 128
     598:	e8 2a       	or	r14, r24
     59a:	f9 2a       	or	r15, r25
     59c:	0a 2b       	or	r16, r26
     59e:	1b 2b       	or	r17, r27
     5a0:	76 95       	lsr	r23
     5a2:	67 95       	ror	r22
     5a4:	57 95       	ror	r21
     5a6:	47 95       	ror	r20
     5a8:	2f 5f       	subi	r18, 0xFF	; 255
     5aa:	3f 4f       	sbci	r19, 0xFF	; 255
     5ac:	77 fd       	sbrc	r23, 7
     5ae:	e7 cf       	rjmp	.-50     	; 0x57e <__mulsf3+0x140>
     5b0:	0c c0       	rjmp	.+24     	; 0x5ca <__mulsf3+0x18c>
     5b2:	44 0f       	add	r20, r20
     5b4:	55 1f       	adc	r21, r21
     5b6:	66 1f       	adc	r22, r22
     5b8:	77 1f       	adc	r23, r23
     5ba:	17 fd       	sbrc	r17, 7
     5bc:	41 60       	ori	r20, 0x01	; 1
     5be:	ee 0c       	add	r14, r14
     5c0:	ff 1c       	adc	r15, r15
     5c2:	00 1f       	adc	r16, r16
     5c4:	11 1f       	adc	r17, r17
     5c6:	21 50       	subi	r18, 0x01	; 1
     5c8:	30 40       	sbci	r19, 0x00	; 0
     5ca:	40 30       	cpi	r20, 0x00	; 0
     5cc:	90 e0       	ldi	r25, 0x00	; 0
     5ce:	59 07       	cpc	r21, r25
     5d0:	90 e0       	ldi	r25, 0x00	; 0
     5d2:	69 07       	cpc	r22, r25
     5d4:	90 e4       	ldi	r25, 0x40	; 64
     5d6:	79 07       	cpc	r23, r25
     5d8:	60 f3       	brcs	.-40     	; 0x5b2 <__mulsf3+0x174>
     5da:	2b 8f       	std	Y+27, r18	; 0x1b
     5dc:	3c 8f       	std	Y+28, r19	; 0x1c
     5de:	db 01       	movw	r26, r22
     5e0:	ca 01       	movw	r24, r20
     5e2:	8f 77       	andi	r24, 0x7F	; 127
     5e4:	90 70       	andi	r25, 0x00	; 0
     5e6:	a0 70       	andi	r26, 0x00	; 0
     5e8:	b0 70       	andi	r27, 0x00	; 0
     5ea:	80 34       	cpi	r24, 0x40	; 64
     5ec:	91 05       	cpc	r25, r1
     5ee:	a1 05       	cpc	r26, r1
     5f0:	b1 05       	cpc	r27, r1
     5f2:	61 f4       	brne	.+24     	; 0x60c <__mulsf3+0x1ce>
     5f4:	47 fd       	sbrc	r20, 7
     5f6:	0a c0       	rjmp	.+20     	; 0x60c <__mulsf3+0x1ce>
     5f8:	e1 14       	cp	r14, r1
     5fa:	f1 04       	cpc	r15, r1
     5fc:	01 05       	cpc	r16, r1
     5fe:	11 05       	cpc	r17, r1
     600:	29 f0       	breq	.+10     	; 0x60c <__mulsf3+0x1ce>
     602:	40 5c       	subi	r20, 0xC0	; 192
     604:	5f 4f       	sbci	r21, 0xFF	; 255
     606:	6f 4f       	sbci	r22, 0xFF	; 255
     608:	7f 4f       	sbci	r23, 0xFF	; 255
     60a:	40 78       	andi	r20, 0x80	; 128
     60c:	1a 8e       	std	Y+26, r1	; 0x1a
     60e:	fe 17       	cp	r31, r30
     610:	11 f0       	breq	.+4      	; 0x616 <__mulsf3+0x1d8>
     612:	81 e0       	ldi	r24, 0x01	; 1
     614:	8a 8f       	std	Y+26, r24	; 0x1a
     616:	4d 8f       	std	Y+29, r20	; 0x1d
     618:	5e 8f       	std	Y+30, r21	; 0x1e
     61a:	6f 8f       	std	Y+31, r22	; 0x1f
     61c:	78 a3       	std	Y+32, r23	; 0x20
     61e:	83 e0       	ldi	r24, 0x03	; 3
     620:	89 8f       	std	Y+25, r24	; 0x19
     622:	ce 01       	movw	r24, r28
     624:	49 96       	adiw	r24, 0x19	; 25
     626:	0e 94 86 05 	call	0xb0c	; 0xb0c <__pack_f>
     62a:	a0 96       	adiw	r28, 0x20	; 32
     62c:	e2 e1       	ldi	r30, 0x12	; 18
     62e:	0c 94 c8 36 	jmp	0x6d90	; 0x6d90 <__epilogue_restores__>

00000632 <__divsf3>:
     632:	a8 e1       	ldi	r26, 0x18	; 24
     634:	b0 e0       	ldi	r27, 0x00	; 0
     636:	ef e1       	ldi	r30, 0x1F	; 31
     638:	f3 e0       	ldi	r31, 0x03	; 3
     63a:	0c 94 b4 36 	jmp	0x6d68	; 0x6d68 <__prologue_saves__+0x10>
     63e:	69 83       	std	Y+1, r22	; 0x01
     640:	7a 83       	std	Y+2, r23	; 0x02
     642:	8b 83       	std	Y+3, r24	; 0x03
     644:	9c 83       	std	Y+4, r25	; 0x04
     646:	2d 83       	std	Y+5, r18	; 0x05
     648:	3e 83       	std	Y+6, r19	; 0x06
     64a:	4f 83       	std	Y+7, r20	; 0x07
     64c:	58 87       	std	Y+8, r21	; 0x08
     64e:	b9 e0       	ldi	r27, 0x09	; 9
     650:	eb 2e       	mov	r14, r27
     652:	f1 2c       	mov	r15, r1
     654:	ec 0e       	add	r14, r28
     656:	fd 1e       	adc	r15, r29
     658:	ce 01       	movw	r24, r28
     65a:	01 96       	adiw	r24, 0x01	; 1
     65c:	b7 01       	movw	r22, r14
     65e:	0e 94 5b 06 	call	0xcb6	; 0xcb6 <__unpack_f>
     662:	8e 01       	movw	r16, r28
     664:	0f 5e       	subi	r16, 0xEF	; 239
     666:	1f 4f       	sbci	r17, 0xFF	; 255
     668:	ce 01       	movw	r24, r28
     66a:	05 96       	adiw	r24, 0x05	; 5
     66c:	b8 01       	movw	r22, r16
     66e:	0e 94 5b 06 	call	0xcb6	; 0xcb6 <__unpack_f>
     672:	29 85       	ldd	r18, Y+9	; 0x09
     674:	22 30       	cpi	r18, 0x02	; 2
     676:	08 f4       	brcc	.+2      	; 0x67a <__divsf3+0x48>
     678:	7e c0       	rjmp	.+252    	; 0x776 <__divsf3+0x144>
     67a:	39 89       	ldd	r19, Y+17	; 0x11
     67c:	32 30       	cpi	r19, 0x02	; 2
     67e:	10 f4       	brcc	.+4      	; 0x684 <__divsf3+0x52>
     680:	b8 01       	movw	r22, r16
     682:	7c c0       	rjmp	.+248    	; 0x77c <__divsf3+0x14a>
     684:	8a 85       	ldd	r24, Y+10	; 0x0a
     686:	9a 89       	ldd	r25, Y+18	; 0x12
     688:	89 27       	eor	r24, r25
     68a:	8a 87       	std	Y+10, r24	; 0x0a
     68c:	24 30       	cpi	r18, 0x04	; 4
     68e:	11 f0       	breq	.+4      	; 0x694 <__divsf3+0x62>
     690:	22 30       	cpi	r18, 0x02	; 2
     692:	31 f4       	brne	.+12     	; 0x6a0 <__divsf3+0x6e>
     694:	23 17       	cp	r18, r19
     696:	09 f0       	breq	.+2      	; 0x69a <__divsf3+0x68>
     698:	6e c0       	rjmp	.+220    	; 0x776 <__divsf3+0x144>
     69a:	63 ee       	ldi	r22, 0xE3	; 227
     69c:	70 e0       	ldi	r23, 0x00	; 0
     69e:	6e c0       	rjmp	.+220    	; 0x77c <__divsf3+0x14a>
     6a0:	34 30       	cpi	r19, 0x04	; 4
     6a2:	39 f4       	brne	.+14     	; 0x6b2 <__divsf3+0x80>
     6a4:	1d 86       	std	Y+13, r1	; 0x0d
     6a6:	1e 86       	std	Y+14, r1	; 0x0e
     6a8:	1f 86       	std	Y+15, r1	; 0x0f
     6aa:	18 8a       	std	Y+16, r1	; 0x10
     6ac:	1c 86       	std	Y+12, r1	; 0x0c
     6ae:	1b 86       	std	Y+11, r1	; 0x0b
     6b0:	04 c0       	rjmp	.+8      	; 0x6ba <__divsf3+0x88>
     6b2:	32 30       	cpi	r19, 0x02	; 2
     6b4:	21 f4       	brne	.+8      	; 0x6be <__divsf3+0x8c>
     6b6:	84 e0       	ldi	r24, 0x04	; 4
     6b8:	89 87       	std	Y+9, r24	; 0x09
     6ba:	b7 01       	movw	r22, r14
     6bc:	5f c0       	rjmp	.+190    	; 0x77c <__divsf3+0x14a>
     6be:	2b 85       	ldd	r18, Y+11	; 0x0b
     6c0:	3c 85       	ldd	r19, Y+12	; 0x0c
     6c2:	8b 89       	ldd	r24, Y+19	; 0x13
     6c4:	9c 89       	ldd	r25, Y+20	; 0x14
     6c6:	28 1b       	sub	r18, r24
     6c8:	39 0b       	sbc	r19, r25
     6ca:	3c 87       	std	Y+12, r19	; 0x0c
     6cc:	2b 87       	std	Y+11, r18	; 0x0b
     6ce:	ed 84       	ldd	r14, Y+13	; 0x0d
     6d0:	fe 84       	ldd	r15, Y+14	; 0x0e
     6d2:	0f 85       	ldd	r16, Y+15	; 0x0f
     6d4:	18 89       	ldd	r17, Y+16	; 0x10
     6d6:	ad 88       	ldd	r10, Y+21	; 0x15
     6d8:	be 88       	ldd	r11, Y+22	; 0x16
     6da:	cf 88       	ldd	r12, Y+23	; 0x17
     6dc:	d8 8c       	ldd	r13, Y+24	; 0x18
     6de:	ea 14       	cp	r14, r10
     6e0:	fb 04       	cpc	r15, r11
     6e2:	0c 05       	cpc	r16, r12
     6e4:	1d 05       	cpc	r17, r13
     6e6:	40 f4       	brcc	.+16     	; 0x6f8 <__divsf3+0xc6>
     6e8:	ee 0c       	add	r14, r14
     6ea:	ff 1c       	adc	r15, r15
     6ec:	00 1f       	adc	r16, r16
     6ee:	11 1f       	adc	r17, r17
     6f0:	21 50       	subi	r18, 0x01	; 1
     6f2:	30 40       	sbci	r19, 0x00	; 0
     6f4:	3c 87       	std	Y+12, r19	; 0x0c
     6f6:	2b 87       	std	Y+11, r18	; 0x0b
     6f8:	20 e0       	ldi	r18, 0x00	; 0
     6fa:	30 e0       	ldi	r19, 0x00	; 0
     6fc:	40 e0       	ldi	r20, 0x00	; 0
     6fe:	50 e0       	ldi	r21, 0x00	; 0
     700:	80 e0       	ldi	r24, 0x00	; 0
     702:	90 e0       	ldi	r25, 0x00	; 0
     704:	a0 e0       	ldi	r26, 0x00	; 0
     706:	b0 e4       	ldi	r27, 0x40	; 64
     708:	60 e0       	ldi	r22, 0x00	; 0
     70a:	70 e0       	ldi	r23, 0x00	; 0
     70c:	ea 14       	cp	r14, r10
     70e:	fb 04       	cpc	r15, r11
     710:	0c 05       	cpc	r16, r12
     712:	1d 05       	cpc	r17, r13
     714:	40 f0       	brcs	.+16     	; 0x726 <__divsf3+0xf4>
     716:	28 2b       	or	r18, r24
     718:	39 2b       	or	r19, r25
     71a:	4a 2b       	or	r20, r26
     71c:	5b 2b       	or	r21, r27
     71e:	ea 18       	sub	r14, r10
     720:	fb 08       	sbc	r15, r11
     722:	0c 09       	sbc	r16, r12
     724:	1d 09       	sbc	r17, r13
     726:	b6 95       	lsr	r27
     728:	a7 95       	ror	r26
     72a:	97 95       	ror	r25
     72c:	87 95       	ror	r24
     72e:	ee 0c       	add	r14, r14
     730:	ff 1c       	adc	r15, r15
     732:	00 1f       	adc	r16, r16
     734:	11 1f       	adc	r17, r17
     736:	6f 5f       	subi	r22, 0xFF	; 255
     738:	7f 4f       	sbci	r23, 0xFF	; 255
     73a:	6f 31       	cpi	r22, 0x1F	; 31
     73c:	71 05       	cpc	r23, r1
     73e:	31 f7       	brne	.-52     	; 0x70c <__divsf3+0xda>
     740:	da 01       	movw	r26, r20
     742:	c9 01       	movw	r24, r18
     744:	8f 77       	andi	r24, 0x7F	; 127
     746:	90 70       	andi	r25, 0x00	; 0
     748:	a0 70       	andi	r26, 0x00	; 0
     74a:	b0 70       	andi	r27, 0x00	; 0
     74c:	80 34       	cpi	r24, 0x40	; 64
     74e:	91 05       	cpc	r25, r1
     750:	a1 05       	cpc	r26, r1
     752:	b1 05       	cpc	r27, r1
     754:	61 f4       	brne	.+24     	; 0x76e <__divsf3+0x13c>
     756:	27 fd       	sbrc	r18, 7
     758:	0a c0       	rjmp	.+20     	; 0x76e <__divsf3+0x13c>
     75a:	e1 14       	cp	r14, r1
     75c:	f1 04       	cpc	r15, r1
     75e:	01 05       	cpc	r16, r1
     760:	11 05       	cpc	r17, r1
     762:	29 f0       	breq	.+10     	; 0x76e <__divsf3+0x13c>
     764:	20 5c       	subi	r18, 0xC0	; 192
     766:	3f 4f       	sbci	r19, 0xFF	; 255
     768:	4f 4f       	sbci	r20, 0xFF	; 255
     76a:	5f 4f       	sbci	r21, 0xFF	; 255
     76c:	20 78       	andi	r18, 0x80	; 128
     76e:	2d 87       	std	Y+13, r18	; 0x0d
     770:	3e 87       	std	Y+14, r19	; 0x0e
     772:	4f 87       	std	Y+15, r20	; 0x0f
     774:	58 8b       	std	Y+16, r21	; 0x10
     776:	be 01       	movw	r22, r28
     778:	67 5f       	subi	r22, 0xF7	; 247
     77a:	7f 4f       	sbci	r23, 0xFF	; 255
     77c:	cb 01       	movw	r24, r22
     77e:	0e 94 86 05 	call	0xb0c	; 0xb0c <__pack_f>
     782:	68 96       	adiw	r28, 0x18	; 24
     784:	ea e0       	ldi	r30, 0x0A	; 10
     786:	0c 94 d0 36 	jmp	0x6da0	; 0x6da0 <__epilogue_restores__+0x10>

0000078a <__gtsf2>:
     78a:	a8 e1       	ldi	r26, 0x18	; 24
     78c:	b0 e0       	ldi	r27, 0x00	; 0
     78e:	eb ec       	ldi	r30, 0xCB	; 203
     790:	f3 e0       	ldi	r31, 0x03	; 3
     792:	0c 94 b8 36 	jmp	0x6d70	; 0x6d70 <__prologue_saves__+0x18>
     796:	69 83       	std	Y+1, r22	; 0x01
     798:	7a 83       	std	Y+2, r23	; 0x02
     79a:	8b 83       	std	Y+3, r24	; 0x03
     79c:	9c 83       	std	Y+4, r25	; 0x04
     79e:	2d 83       	std	Y+5, r18	; 0x05
     7a0:	3e 83       	std	Y+6, r19	; 0x06
     7a2:	4f 83       	std	Y+7, r20	; 0x07
     7a4:	58 87       	std	Y+8, r21	; 0x08
     7a6:	89 e0       	ldi	r24, 0x09	; 9
     7a8:	e8 2e       	mov	r14, r24
     7aa:	f1 2c       	mov	r15, r1
     7ac:	ec 0e       	add	r14, r28
     7ae:	fd 1e       	adc	r15, r29
     7b0:	ce 01       	movw	r24, r28
     7b2:	01 96       	adiw	r24, 0x01	; 1
     7b4:	b7 01       	movw	r22, r14
     7b6:	0e 94 5b 06 	call	0xcb6	; 0xcb6 <__unpack_f>
     7ba:	8e 01       	movw	r16, r28
     7bc:	0f 5e       	subi	r16, 0xEF	; 239
     7be:	1f 4f       	sbci	r17, 0xFF	; 255
     7c0:	ce 01       	movw	r24, r28
     7c2:	05 96       	adiw	r24, 0x05	; 5
     7c4:	b8 01       	movw	r22, r16
     7c6:	0e 94 5b 06 	call	0xcb6	; 0xcb6 <__unpack_f>
     7ca:	89 85       	ldd	r24, Y+9	; 0x09
     7cc:	82 30       	cpi	r24, 0x02	; 2
     7ce:	40 f0       	brcs	.+16     	; 0x7e0 <__gtsf2+0x56>
     7d0:	89 89       	ldd	r24, Y+17	; 0x11
     7d2:	82 30       	cpi	r24, 0x02	; 2
     7d4:	28 f0       	brcs	.+10     	; 0x7e0 <__gtsf2+0x56>
     7d6:	c7 01       	movw	r24, r14
     7d8:	b8 01       	movw	r22, r16
     7da:	0e 94 d3 06 	call	0xda6	; 0xda6 <__fpcmp_parts_f>
     7de:	01 c0       	rjmp	.+2      	; 0x7e2 <__gtsf2+0x58>
     7e0:	8f ef       	ldi	r24, 0xFF	; 255
     7e2:	68 96       	adiw	r28, 0x18	; 24
     7e4:	e6 e0       	ldi	r30, 0x06	; 6
     7e6:	0c 94 d4 36 	jmp	0x6da8	; 0x6da8 <__epilogue_restores__+0x18>

000007ea <__gesf2>:
     7ea:	a8 e1       	ldi	r26, 0x18	; 24
     7ec:	b0 e0       	ldi	r27, 0x00	; 0
     7ee:	eb ef       	ldi	r30, 0xFB	; 251
     7f0:	f3 e0       	ldi	r31, 0x03	; 3
     7f2:	0c 94 b8 36 	jmp	0x6d70	; 0x6d70 <__prologue_saves__+0x18>
     7f6:	69 83       	std	Y+1, r22	; 0x01
     7f8:	7a 83       	std	Y+2, r23	; 0x02
     7fa:	8b 83       	std	Y+3, r24	; 0x03
     7fc:	9c 83       	std	Y+4, r25	; 0x04
     7fe:	2d 83       	std	Y+5, r18	; 0x05
     800:	3e 83       	std	Y+6, r19	; 0x06
     802:	4f 83       	std	Y+7, r20	; 0x07
     804:	58 87       	std	Y+8, r21	; 0x08
     806:	89 e0       	ldi	r24, 0x09	; 9
     808:	e8 2e       	mov	r14, r24
     80a:	f1 2c       	mov	r15, r1
     80c:	ec 0e       	add	r14, r28
     80e:	fd 1e       	adc	r15, r29
     810:	ce 01       	movw	r24, r28
     812:	01 96       	adiw	r24, 0x01	; 1
     814:	b7 01       	movw	r22, r14
     816:	0e 94 5b 06 	call	0xcb6	; 0xcb6 <__unpack_f>
     81a:	8e 01       	movw	r16, r28
     81c:	0f 5e       	subi	r16, 0xEF	; 239
     81e:	1f 4f       	sbci	r17, 0xFF	; 255
     820:	ce 01       	movw	r24, r28
     822:	05 96       	adiw	r24, 0x05	; 5
     824:	b8 01       	movw	r22, r16
     826:	0e 94 5b 06 	call	0xcb6	; 0xcb6 <__unpack_f>
     82a:	89 85       	ldd	r24, Y+9	; 0x09
     82c:	82 30       	cpi	r24, 0x02	; 2
     82e:	40 f0       	brcs	.+16     	; 0x840 <__gesf2+0x56>
     830:	89 89       	ldd	r24, Y+17	; 0x11
     832:	82 30       	cpi	r24, 0x02	; 2
     834:	28 f0       	brcs	.+10     	; 0x840 <__gesf2+0x56>
     836:	c7 01       	movw	r24, r14
     838:	b8 01       	movw	r22, r16
     83a:	0e 94 d3 06 	call	0xda6	; 0xda6 <__fpcmp_parts_f>
     83e:	01 c0       	rjmp	.+2      	; 0x842 <__gesf2+0x58>
     840:	8f ef       	ldi	r24, 0xFF	; 255
     842:	68 96       	adiw	r28, 0x18	; 24
     844:	e6 e0       	ldi	r30, 0x06	; 6
     846:	0c 94 d4 36 	jmp	0x6da8	; 0x6da8 <__epilogue_restores__+0x18>

0000084a <__ltsf2>:
     84a:	a8 e1       	ldi	r26, 0x18	; 24
     84c:	b0 e0       	ldi	r27, 0x00	; 0
     84e:	eb e2       	ldi	r30, 0x2B	; 43
     850:	f4 e0       	ldi	r31, 0x04	; 4
     852:	0c 94 b8 36 	jmp	0x6d70	; 0x6d70 <__prologue_saves__+0x18>
     856:	69 83       	std	Y+1, r22	; 0x01
     858:	7a 83       	std	Y+2, r23	; 0x02
     85a:	8b 83       	std	Y+3, r24	; 0x03
     85c:	9c 83       	std	Y+4, r25	; 0x04
     85e:	2d 83       	std	Y+5, r18	; 0x05
     860:	3e 83       	std	Y+6, r19	; 0x06
     862:	4f 83       	std	Y+7, r20	; 0x07
     864:	58 87       	std	Y+8, r21	; 0x08
     866:	89 e0       	ldi	r24, 0x09	; 9
     868:	e8 2e       	mov	r14, r24
     86a:	f1 2c       	mov	r15, r1
     86c:	ec 0e       	add	r14, r28
     86e:	fd 1e       	adc	r15, r29
     870:	ce 01       	movw	r24, r28
     872:	01 96       	adiw	r24, 0x01	; 1
     874:	b7 01       	movw	r22, r14
     876:	0e 94 5b 06 	call	0xcb6	; 0xcb6 <__unpack_f>
     87a:	8e 01       	movw	r16, r28
     87c:	0f 5e       	subi	r16, 0xEF	; 239
     87e:	1f 4f       	sbci	r17, 0xFF	; 255
     880:	ce 01       	movw	r24, r28
     882:	05 96       	adiw	r24, 0x05	; 5
     884:	b8 01       	movw	r22, r16
     886:	0e 94 5b 06 	call	0xcb6	; 0xcb6 <__unpack_f>
     88a:	89 85       	ldd	r24, Y+9	; 0x09
     88c:	82 30       	cpi	r24, 0x02	; 2
     88e:	40 f0       	brcs	.+16     	; 0x8a0 <__stack+0x41>
     890:	89 89       	ldd	r24, Y+17	; 0x11
     892:	82 30       	cpi	r24, 0x02	; 2
     894:	28 f0       	brcs	.+10     	; 0x8a0 <__stack+0x41>
     896:	c7 01       	movw	r24, r14
     898:	b8 01       	movw	r22, r16
     89a:	0e 94 d3 06 	call	0xda6	; 0xda6 <__fpcmp_parts_f>
     89e:	01 c0       	rjmp	.+2      	; 0x8a2 <__stack+0x43>
     8a0:	81 e0       	ldi	r24, 0x01	; 1
     8a2:	68 96       	adiw	r28, 0x18	; 24
     8a4:	e6 e0       	ldi	r30, 0x06	; 6
     8a6:	0c 94 d4 36 	jmp	0x6da8	; 0x6da8 <__epilogue_restores__+0x18>

000008aa <__lesf2>:
     8aa:	a8 e1       	ldi	r26, 0x18	; 24
     8ac:	b0 e0       	ldi	r27, 0x00	; 0
     8ae:	eb e5       	ldi	r30, 0x5B	; 91
     8b0:	f4 e0       	ldi	r31, 0x04	; 4
     8b2:	0c 94 b8 36 	jmp	0x6d70	; 0x6d70 <__prologue_saves__+0x18>
     8b6:	69 83       	std	Y+1, r22	; 0x01
     8b8:	7a 83       	std	Y+2, r23	; 0x02
     8ba:	8b 83       	std	Y+3, r24	; 0x03
     8bc:	9c 83       	std	Y+4, r25	; 0x04
     8be:	2d 83       	std	Y+5, r18	; 0x05
     8c0:	3e 83       	std	Y+6, r19	; 0x06
     8c2:	4f 83       	std	Y+7, r20	; 0x07
     8c4:	58 87       	std	Y+8, r21	; 0x08
     8c6:	89 e0       	ldi	r24, 0x09	; 9
     8c8:	e8 2e       	mov	r14, r24
     8ca:	f1 2c       	mov	r15, r1
     8cc:	ec 0e       	add	r14, r28
     8ce:	fd 1e       	adc	r15, r29
     8d0:	ce 01       	movw	r24, r28
     8d2:	01 96       	adiw	r24, 0x01	; 1
     8d4:	b7 01       	movw	r22, r14
     8d6:	0e 94 5b 06 	call	0xcb6	; 0xcb6 <__unpack_f>
     8da:	8e 01       	movw	r16, r28
     8dc:	0f 5e       	subi	r16, 0xEF	; 239
     8de:	1f 4f       	sbci	r17, 0xFF	; 255
     8e0:	ce 01       	movw	r24, r28
     8e2:	05 96       	adiw	r24, 0x05	; 5
     8e4:	b8 01       	movw	r22, r16
     8e6:	0e 94 5b 06 	call	0xcb6	; 0xcb6 <__unpack_f>
     8ea:	89 85       	ldd	r24, Y+9	; 0x09
     8ec:	82 30       	cpi	r24, 0x02	; 2
     8ee:	40 f0       	brcs	.+16     	; 0x900 <__lesf2+0x56>
     8f0:	89 89       	ldd	r24, Y+17	; 0x11
     8f2:	82 30       	cpi	r24, 0x02	; 2
     8f4:	28 f0       	brcs	.+10     	; 0x900 <__lesf2+0x56>
     8f6:	c7 01       	movw	r24, r14
     8f8:	b8 01       	movw	r22, r16
     8fa:	0e 94 d3 06 	call	0xda6	; 0xda6 <__fpcmp_parts_f>
     8fe:	01 c0       	rjmp	.+2      	; 0x902 <__lesf2+0x58>
     900:	81 e0       	ldi	r24, 0x01	; 1
     902:	68 96       	adiw	r28, 0x18	; 24
     904:	e6 e0       	ldi	r30, 0x06	; 6
     906:	0c 94 d4 36 	jmp	0x6da8	; 0x6da8 <__epilogue_restores__+0x18>

0000090a <__floatsisf>:
     90a:	a8 e0       	ldi	r26, 0x08	; 8
     90c:	b0 e0       	ldi	r27, 0x00	; 0
     90e:	eb e8       	ldi	r30, 0x8B	; 139
     910:	f4 e0       	ldi	r31, 0x04	; 4
     912:	0c 94 b5 36 	jmp	0x6d6a	; 0x6d6a <__prologue_saves__+0x12>
     916:	9b 01       	movw	r18, r22
     918:	ac 01       	movw	r20, r24
     91a:	83 e0       	ldi	r24, 0x03	; 3
     91c:	89 83       	std	Y+1, r24	; 0x01
     91e:	da 01       	movw	r26, r20
     920:	c9 01       	movw	r24, r18
     922:	88 27       	eor	r24, r24
     924:	b7 fd       	sbrc	r27, 7
     926:	83 95       	inc	r24
     928:	99 27       	eor	r25, r25
     92a:	aa 27       	eor	r26, r26
     92c:	bb 27       	eor	r27, r27
     92e:	b8 2e       	mov	r11, r24
     930:	21 15       	cp	r18, r1
     932:	31 05       	cpc	r19, r1
     934:	41 05       	cpc	r20, r1
     936:	51 05       	cpc	r21, r1
     938:	19 f4       	brne	.+6      	; 0x940 <__floatsisf+0x36>
     93a:	82 e0       	ldi	r24, 0x02	; 2
     93c:	89 83       	std	Y+1, r24	; 0x01
     93e:	3a c0       	rjmp	.+116    	; 0x9b4 <__floatsisf+0xaa>
     940:	88 23       	and	r24, r24
     942:	a9 f0       	breq	.+42     	; 0x96e <__floatsisf+0x64>
     944:	20 30       	cpi	r18, 0x00	; 0
     946:	80 e0       	ldi	r24, 0x00	; 0
     948:	38 07       	cpc	r19, r24
     94a:	80 e0       	ldi	r24, 0x00	; 0
     94c:	48 07       	cpc	r20, r24
     94e:	80 e8       	ldi	r24, 0x80	; 128
     950:	58 07       	cpc	r21, r24
     952:	29 f4       	brne	.+10     	; 0x95e <__floatsisf+0x54>
     954:	60 e0       	ldi	r22, 0x00	; 0
     956:	70 e0       	ldi	r23, 0x00	; 0
     958:	80 e0       	ldi	r24, 0x00	; 0
     95a:	9f ec       	ldi	r25, 0xCF	; 207
     95c:	30 c0       	rjmp	.+96     	; 0x9be <__floatsisf+0xb4>
     95e:	ee 24       	eor	r14, r14
     960:	ff 24       	eor	r15, r15
     962:	87 01       	movw	r16, r14
     964:	e2 1a       	sub	r14, r18
     966:	f3 0a       	sbc	r15, r19
     968:	04 0b       	sbc	r16, r20
     96a:	15 0b       	sbc	r17, r21
     96c:	02 c0       	rjmp	.+4      	; 0x972 <__floatsisf+0x68>
     96e:	79 01       	movw	r14, r18
     970:	8a 01       	movw	r16, r20
     972:	8e e1       	ldi	r24, 0x1E	; 30
     974:	c8 2e       	mov	r12, r24
     976:	d1 2c       	mov	r13, r1
     978:	dc 82       	std	Y+4, r13	; 0x04
     97a:	cb 82       	std	Y+3, r12	; 0x03
     97c:	ed 82       	std	Y+5, r14	; 0x05
     97e:	fe 82       	std	Y+6, r15	; 0x06
     980:	0f 83       	std	Y+7, r16	; 0x07
     982:	18 87       	std	Y+8, r17	; 0x08
     984:	c8 01       	movw	r24, r16
     986:	b7 01       	movw	r22, r14
     988:	0e 94 37 05 	call	0xa6e	; 0xa6e <__clzsi2>
     98c:	01 97       	sbiw	r24, 0x01	; 1
     98e:	18 16       	cp	r1, r24
     990:	19 06       	cpc	r1, r25
     992:	84 f4       	brge	.+32     	; 0x9b4 <__floatsisf+0xaa>
     994:	08 2e       	mov	r0, r24
     996:	04 c0       	rjmp	.+8      	; 0x9a0 <__floatsisf+0x96>
     998:	ee 0c       	add	r14, r14
     99a:	ff 1c       	adc	r15, r15
     99c:	00 1f       	adc	r16, r16
     99e:	11 1f       	adc	r17, r17
     9a0:	0a 94       	dec	r0
     9a2:	d2 f7       	brpl	.-12     	; 0x998 <__floatsisf+0x8e>
     9a4:	ed 82       	std	Y+5, r14	; 0x05
     9a6:	fe 82       	std	Y+6, r15	; 0x06
     9a8:	0f 83       	std	Y+7, r16	; 0x07
     9aa:	18 87       	std	Y+8, r17	; 0x08
     9ac:	c8 1a       	sub	r12, r24
     9ae:	d9 0a       	sbc	r13, r25
     9b0:	dc 82       	std	Y+4, r13	; 0x04
     9b2:	cb 82       	std	Y+3, r12	; 0x03
     9b4:	ba 82       	std	Y+2, r11	; 0x02
     9b6:	ce 01       	movw	r24, r28
     9b8:	01 96       	adiw	r24, 0x01	; 1
     9ba:	0e 94 86 05 	call	0xb0c	; 0xb0c <__pack_f>
     9be:	28 96       	adiw	r28, 0x08	; 8
     9c0:	e9 e0       	ldi	r30, 0x09	; 9
     9c2:	0c 94 d1 36 	jmp	0x6da2	; 0x6da2 <__epilogue_restores__+0x12>

000009c6 <__fixsfsi>:
     9c6:	ac e0       	ldi	r26, 0x0C	; 12
     9c8:	b0 e0       	ldi	r27, 0x00	; 0
     9ca:	e9 ee       	ldi	r30, 0xE9	; 233
     9cc:	f4 e0       	ldi	r31, 0x04	; 4
     9ce:	0c 94 bc 36 	jmp	0x6d78	; 0x6d78 <__prologue_saves__+0x20>
     9d2:	69 83       	std	Y+1, r22	; 0x01
     9d4:	7a 83       	std	Y+2, r23	; 0x02
     9d6:	8b 83       	std	Y+3, r24	; 0x03
     9d8:	9c 83       	std	Y+4, r25	; 0x04
     9da:	ce 01       	movw	r24, r28
     9dc:	01 96       	adiw	r24, 0x01	; 1
     9de:	be 01       	movw	r22, r28
     9e0:	6b 5f       	subi	r22, 0xFB	; 251
     9e2:	7f 4f       	sbci	r23, 0xFF	; 255
     9e4:	0e 94 5b 06 	call	0xcb6	; 0xcb6 <__unpack_f>
     9e8:	8d 81       	ldd	r24, Y+5	; 0x05
     9ea:	82 30       	cpi	r24, 0x02	; 2
     9ec:	61 f1       	breq	.+88     	; 0xa46 <__fixsfsi+0x80>
     9ee:	82 30       	cpi	r24, 0x02	; 2
     9f0:	50 f1       	brcs	.+84     	; 0xa46 <__fixsfsi+0x80>
     9f2:	84 30       	cpi	r24, 0x04	; 4
     9f4:	21 f4       	brne	.+8      	; 0x9fe <__fixsfsi+0x38>
     9f6:	8e 81       	ldd	r24, Y+6	; 0x06
     9f8:	88 23       	and	r24, r24
     9fa:	51 f1       	breq	.+84     	; 0xa50 <__fixsfsi+0x8a>
     9fc:	2e c0       	rjmp	.+92     	; 0xa5a <__fixsfsi+0x94>
     9fe:	2f 81       	ldd	r18, Y+7	; 0x07
     a00:	38 85       	ldd	r19, Y+8	; 0x08
     a02:	37 fd       	sbrc	r19, 7
     a04:	20 c0       	rjmp	.+64     	; 0xa46 <__fixsfsi+0x80>
     a06:	6e 81       	ldd	r22, Y+6	; 0x06
     a08:	2f 31       	cpi	r18, 0x1F	; 31
     a0a:	31 05       	cpc	r19, r1
     a0c:	1c f0       	brlt	.+6      	; 0xa14 <__fixsfsi+0x4e>
     a0e:	66 23       	and	r22, r22
     a10:	f9 f0       	breq	.+62     	; 0xa50 <__fixsfsi+0x8a>
     a12:	23 c0       	rjmp	.+70     	; 0xa5a <__fixsfsi+0x94>
     a14:	8e e1       	ldi	r24, 0x1E	; 30
     a16:	90 e0       	ldi	r25, 0x00	; 0
     a18:	82 1b       	sub	r24, r18
     a1a:	93 0b       	sbc	r25, r19
     a1c:	29 85       	ldd	r18, Y+9	; 0x09
     a1e:	3a 85       	ldd	r19, Y+10	; 0x0a
     a20:	4b 85       	ldd	r20, Y+11	; 0x0b
     a22:	5c 85       	ldd	r21, Y+12	; 0x0c
     a24:	04 c0       	rjmp	.+8      	; 0xa2e <__fixsfsi+0x68>
     a26:	56 95       	lsr	r21
     a28:	47 95       	ror	r20
     a2a:	37 95       	ror	r19
     a2c:	27 95       	ror	r18
     a2e:	8a 95       	dec	r24
     a30:	d2 f7       	brpl	.-12     	; 0xa26 <__fixsfsi+0x60>
     a32:	66 23       	and	r22, r22
     a34:	b1 f0       	breq	.+44     	; 0xa62 <__fixsfsi+0x9c>
     a36:	50 95       	com	r21
     a38:	40 95       	com	r20
     a3a:	30 95       	com	r19
     a3c:	21 95       	neg	r18
     a3e:	3f 4f       	sbci	r19, 0xFF	; 255
     a40:	4f 4f       	sbci	r20, 0xFF	; 255
     a42:	5f 4f       	sbci	r21, 0xFF	; 255
     a44:	0e c0       	rjmp	.+28     	; 0xa62 <__fixsfsi+0x9c>
     a46:	20 e0       	ldi	r18, 0x00	; 0
     a48:	30 e0       	ldi	r19, 0x00	; 0
     a4a:	40 e0       	ldi	r20, 0x00	; 0
     a4c:	50 e0       	ldi	r21, 0x00	; 0
     a4e:	09 c0       	rjmp	.+18     	; 0xa62 <__fixsfsi+0x9c>
     a50:	2f ef       	ldi	r18, 0xFF	; 255
     a52:	3f ef       	ldi	r19, 0xFF	; 255
     a54:	4f ef       	ldi	r20, 0xFF	; 255
     a56:	5f e7       	ldi	r21, 0x7F	; 127
     a58:	04 c0       	rjmp	.+8      	; 0xa62 <__fixsfsi+0x9c>
     a5a:	20 e0       	ldi	r18, 0x00	; 0
     a5c:	30 e0       	ldi	r19, 0x00	; 0
     a5e:	40 e0       	ldi	r20, 0x00	; 0
     a60:	50 e8       	ldi	r21, 0x80	; 128
     a62:	b9 01       	movw	r22, r18
     a64:	ca 01       	movw	r24, r20
     a66:	2c 96       	adiw	r28, 0x0c	; 12
     a68:	e2 e0       	ldi	r30, 0x02	; 2
     a6a:	0c 94 d8 36 	jmp	0x6db0	; 0x6db0 <__epilogue_restores__+0x20>

00000a6e <__clzsi2>:
     a6e:	ef 92       	push	r14
     a70:	ff 92       	push	r15
     a72:	0f 93       	push	r16
     a74:	1f 93       	push	r17
     a76:	7b 01       	movw	r14, r22
     a78:	8c 01       	movw	r16, r24
     a7a:	80 e0       	ldi	r24, 0x00	; 0
     a7c:	e8 16       	cp	r14, r24
     a7e:	80 e0       	ldi	r24, 0x00	; 0
     a80:	f8 06       	cpc	r15, r24
     a82:	81 e0       	ldi	r24, 0x01	; 1
     a84:	08 07       	cpc	r16, r24
     a86:	80 e0       	ldi	r24, 0x00	; 0
     a88:	18 07       	cpc	r17, r24
     a8a:	88 f4       	brcc	.+34     	; 0xaae <__clzsi2+0x40>
     a8c:	8f ef       	ldi	r24, 0xFF	; 255
     a8e:	e8 16       	cp	r14, r24
     a90:	f1 04       	cpc	r15, r1
     a92:	01 05       	cpc	r16, r1
     a94:	11 05       	cpc	r17, r1
     a96:	31 f0       	breq	.+12     	; 0xaa4 <__clzsi2+0x36>
     a98:	28 f0       	brcs	.+10     	; 0xaa4 <__clzsi2+0x36>
     a9a:	88 e0       	ldi	r24, 0x08	; 8
     a9c:	90 e0       	ldi	r25, 0x00	; 0
     a9e:	a0 e0       	ldi	r26, 0x00	; 0
     aa0:	b0 e0       	ldi	r27, 0x00	; 0
     aa2:	17 c0       	rjmp	.+46     	; 0xad2 <__clzsi2+0x64>
     aa4:	80 e0       	ldi	r24, 0x00	; 0
     aa6:	90 e0       	ldi	r25, 0x00	; 0
     aa8:	a0 e0       	ldi	r26, 0x00	; 0
     aaa:	b0 e0       	ldi	r27, 0x00	; 0
     aac:	12 c0       	rjmp	.+36     	; 0xad2 <__clzsi2+0x64>
     aae:	80 e0       	ldi	r24, 0x00	; 0
     ab0:	e8 16       	cp	r14, r24
     ab2:	80 e0       	ldi	r24, 0x00	; 0
     ab4:	f8 06       	cpc	r15, r24
     ab6:	80 e0       	ldi	r24, 0x00	; 0
     ab8:	08 07       	cpc	r16, r24
     aba:	81 e0       	ldi	r24, 0x01	; 1
     abc:	18 07       	cpc	r17, r24
     abe:	28 f0       	brcs	.+10     	; 0xaca <__clzsi2+0x5c>
     ac0:	88 e1       	ldi	r24, 0x18	; 24
     ac2:	90 e0       	ldi	r25, 0x00	; 0
     ac4:	a0 e0       	ldi	r26, 0x00	; 0
     ac6:	b0 e0       	ldi	r27, 0x00	; 0
     ac8:	04 c0       	rjmp	.+8      	; 0xad2 <__clzsi2+0x64>
     aca:	80 e1       	ldi	r24, 0x10	; 16
     acc:	90 e0       	ldi	r25, 0x00	; 0
     ace:	a0 e0       	ldi	r26, 0x00	; 0
     ad0:	b0 e0       	ldi	r27, 0x00	; 0
     ad2:	20 e2       	ldi	r18, 0x20	; 32
     ad4:	30 e0       	ldi	r19, 0x00	; 0
     ad6:	40 e0       	ldi	r20, 0x00	; 0
     ad8:	50 e0       	ldi	r21, 0x00	; 0
     ada:	28 1b       	sub	r18, r24
     adc:	39 0b       	sbc	r19, r25
     ade:	4a 0b       	sbc	r20, r26
     ae0:	5b 0b       	sbc	r21, r27
     ae2:	04 c0       	rjmp	.+8      	; 0xaec <__clzsi2+0x7e>
     ae4:	16 95       	lsr	r17
     ae6:	07 95       	ror	r16
     ae8:	f7 94       	ror	r15
     aea:	e7 94       	ror	r14
     aec:	8a 95       	dec	r24
     aee:	d2 f7       	brpl	.-12     	; 0xae4 <__clzsi2+0x76>
     af0:	f7 01       	movw	r30, r14
     af2:	e5 51       	subi	r30, 0x15	; 21
     af4:	ff 4f       	sbci	r31, 0xFF	; 255
     af6:	80 81       	ld	r24, Z
     af8:	28 1b       	sub	r18, r24
     afa:	31 09       	sbc	r19, r1
     afc:	41 09       	sbc	r20, r1
     afe:	51 09       	sbc	r21, r1
     b00:	c9 01       	movw	r24, r18
     b02:	1f 91       	pop	r17
     b04:	0f 91       	pop	r16
     b06:	ff 90       	pop	r15
     b08:	ef 90       	pop	r14
     b0a:	08 95       	ret

00000b0c <__pack_f>:
     b0c:	df 92       	push	r13
     b0e:	ef 92       	push	r14
     b10:	ff 92       	push	r15
     b12:	0f 93       	push	r16
     b14:	1f 93       	push	r17
     b16:	fc 01       	movw	r30, r24
     b18:	e4 80       	ldd	r14, Z+4	; 0x04
     b1a:	f5 80       	ldd	r15, Z+5	; 0x05
     b1c:	06 81       	ldd	r16, Z+6	; 0x06
     b1e:	17 81       	ldd	r17, Z+7	; 0x07
     b20:	d1 80       	ldd	r13, Z+1	; 0x01
     b22:	80 81       	ld	r24, Z
     b24:	82 30       	cpi	r24, 0x02	; 2
     b26:	48 f4       	brcc	.+18     	; 0xb3a <__pack_f+0x2e>
     b28:	80 e0       	ldi	r24, 0x00	; 0
     b2a:	90 e0       	ldi	r25, 0x00	; 0
     b2c:	a0 e1       	ldi	r26, 0x10	; 16
     b2e:	b0 e0       	ldi	r27, 0x00	; 0
     b30:	e8 2a       	or	r14, r24
     b32:	f9 2a       	or	r15, r25
     b34:	0a 2b       	or	r16, r26
     b36:	1b 2b       	or	r17, r27
     b38:	a5 c0       	rjmp	.+330    	; 0xc84 <__pack_f+0x178>
     b3a:	84 30       	cpi	r24, 0x04	; 4
     b3c:	09 f4       	brne	.+2      	; 0xb40 <__pack_f+0x34>
     b3e:	9f c0       	rjmp	.+318    	; 0xc7e <__pack_f+0x172>
     b40:	82 30       	cpi	r24, 0x02	; 2
     b42:	21 f4       	brne	.+8      	; 0xb4c <__pack_f+0x40>
     b44:	ee 24       	eor	r14, r14
     b46:	ff 24       	eor	r15, r15
     b48:	87 01       	movw	r16, r14
     b4a:	05 c0       	rjmp	.+10     	; 0xb56 <__pack_f+0x4a>
     b4c:	e1 14       	cp	r14, r1
     b4e:	f1 04       	cpc	r15, r1
     b50:	01 05       	cpc	r16, r1
     b52:	11 05       	cpc	r17, r1
     b54:	19 f4       	brne	.+6      	; 0xb5c <__pack_f+0x50>
     b56:	e0 e0       	ldi	r30, 0x00	; 0
     b58:	f0 e0       	ldi	r31, 0x00	; 0
     b5a:	96 c0       	rjmp	.+300    	; 0xc88 <__pack_f+0x17c>
     b5c:	62 81       	ldd	r22, Z+2	; 0x02
     b5e:	73 81       	ldd	r23, Z+3	; 0x03
     b60:	9f ef       	ldi	r25, 0xFF	; 255
     b62:	62 38       	cpi	r22, 0x82	; 130
     b64:	79 07       	cpc	r23, r25
     b66:	0c f0       	brlt	.+2      	; 0xb6a <__pack_f+0x5e>
     b68:	5b c0       	rjmp	.+182    	; 0xc20 <__pack_f+0x114>
     b6a:	22 e8       	ldi	r18, 0x82	; 130
     b6c:	3f ef       	ldi	r19, 0xFF	; 255
     b6e:	26 1b       	sub	r18, r22
     b70:	37 0b       	sbc	r19, r23
     b72:	2a 31       	cpi	r18, 0x1A	; 26
     b74:	31 05       	cpc	r19, r1
     b76:	2c f0       	brlt	.+10     	; 0xb82 <__pack_f+0x76>
     b78:	20 e0       	ldi	r18, 0x00	; 0
     b7a:	30 e0       	ldi	r19, 0x00	; 0
     b7c:	40 e0       	ldi	r20, 0x00	; 0
     b7e:	50 e0       	ldi	r21, 0x00	; 0
     b80:	2a c0       	rjmp	.+84     	; 0xbd6 <__pack_f+0xca>
     b82:	b8 01       	movw	r22, r16
     b84:	a7 01       	movw	r20, r14
     b86:	02 2e       	mov	r0, r18
     b88:	04 c0       	rjmp	.+8      	; 0xb92 <__pack_f+0x86>
     b8a:	76 95       	lsr	r23
     b8c:	67 95       	ror	r22
     b8e:	57 95       	ror	r21
     b90:	47 95       	ror	r20
     b92:	0a 94       	dec	r0
     b94:	d2 f7       	brpl	.-12     	; 0xb8a <__pack_f+0x7e>
     b96:	81 e0       	ldi	r24, 0x01	; 1
     b98:	90 e0       	ldi	r25, 0x00	; 0
     b9a:	a0 e0       	ldi	r26, 0x00	; 0
     b9c:	b0 e0       	ldi	r27, 0x00	; 0
     b9e:	04 c0       	rjmp	.+8      	; 0xba8 <__pack_f+0x9c>
     ba0:	88 0f       	add	r24, r24
     ba2:	99 1f       	adc	r25, r25
     ba4:	aa 1f       	adc	r26, r26
     ba6:	bb 1f       	adc	r27, r27
     ba8:	2a 95       	dec	r18
     baa:	d2 f7       	brpl	.-12     	; 0xba0 <__pack_f+0x94>
     bac:	01 97       	sbiw	r24, 0x01	; 1
     bae:	a1 09       	sbc	r26, r1
     bb0:	b1 09       	sbc	r27, r1
     bb2:	8e 21       	and	r24, r14
     bb4:	9f 21       	and	r25, r15
     bb6:	a0 23       	and	r26, r16
     bb8:	b1 23       	and	r27, r17
     bba:	00 97       	sbiw	r24, 0x00	; 0
     bbc:	a1 05       	cpc	r26, r1
     bbe:	b1 05       	cpc	r27, r1
     bc0:	21 f0       	breq	.+8      	; 0xbca <__pack_f+0xbe>
     bc2:	81 e0       	ldi	r24, 0x01	; 1
     bc4:	90 e0       	ldi	r25, 0x00	; 0
     bc6:	a0 e0       	ldi	r26, 0x00	; 0
     bc8:	b0 e0       	ldi	r27, 0x00	; 0
     bca:	9a 01       	movw	r18, r20
     bcc:	ab 01       	movw	r20, r22
     bce:	28 2b       	or	r18, r24
     bd0:	39 2b       	or	r19, r25
     bd2:	4a 2b       	or	r20, r26
     bd4:	5b 2b       	or	r21, r27
     bd6:	da 01       	movw	r26, r20
     bd8:	c9 01       	movw	r24, r18
     bda:	8f 77       	andi	r24, 0x7F	; 127
     bdc:	90 70       	andi	r25, 0x00	; 0
     bde:	a0 70       	andi	r26, 0x00	; 0
     be0:	b0 70       	andi	r27, 0x00	; 0
     be2:	80 34       	cpi	r24, 0x40	; 64
     be4:	91 05       	cpc	r25, r1
     be6:	a1 05       	cpc	r26, r1
     be8:	b1 05       	cpc	r27, r1
     bea:	39 f4       	brne	.+14     	; 0xbfa <__pack_f+0xee>
     bec:	27 ff       	sbrs	r18, 7
     bee:	09 c0       	rjmp	.+18     	; 0xc02 <__pack_f+0xf6>
     bf0:	20 5c       	subi	r18, 0xC0	; 192
     bf2:	3f 4f       	sbci	r19, 0xFF	; 255
     bf4:	4f 4f       	sbci	r20, 0xFF	; 255
     bf6:	5f 4f       	sbci	r21, 0xFF	; 255
     bf8:	04 c0       	rjmp	.+8      	; 0xc02 <__pack_f+0xf6>
     bfa:	21 5c       	subi	r18, 0xC1	; 193
     bfc:	3f 4f       	sbci	r19, 0xFF	; 255
     bfe:	4f 4f       	sbci	r20, 0xFF	; 255
     c00:	5f 4f       	sbci	r21, 0xFF	; 255
     c02:	e0 e0       	ldi	r30, 0x00	; 0
     c04:	f0 e0       	ldi	r31, 0x00	; 0
     c06:	20 30       	cpi	r18, 0x00	; 0
     c08:	a0 e0       	ldi	r26, 0x00	; 0
     c0a:	3a 07       	cpc	r19, r26
     c0c:	a0 e0       	ldi	r26, 0x00	; 0
     c0e:	4a 07       	cpc	r20, r26
     c10:	a0 e4       	ldi	r26, 0x40	; 64
     c12:	5a 07       	cpc	r21, r26
     c14:	10 f0       	brcs	.+4      	; 0xc1a <__pack_f+0x10e>
     c16:	e1 e0       	ldi	r30, 0x01	; 1
     c18:	f0 e0       	ldi	r31, 0x00	; 0
     c1a:	79 01       	movw	r14, r18
     c1c:	8a 01       	movw	r16, r20
     c1e:	27 c0       	rjmp	.+78     	; 0xc6e <__pack_f+0x162>
     c20:	60 38       	cpi	r22, 0x80	; 128
     c22:	71 05       	cpc	r23, r1
     c24:	64 f5       	brge	.+88     	; 0xc7e <__pack_f+0x172>
     c26:	fb 01       	movw	r30, r22
     c28:	e1 58       	subi	r30, 0x81	; 129
     c2a:	ff 4f       	sbci	r31, 0xFF	; 255
     c2c:	d8 01       	movw	r26, r16
     c2e:	c7 01       	movw	r24, r14
     c30:	8f 77       	andi	r24, 0x7F	; 127
     c32:	90 70       	andi	r25, 0x00	; 0
     c34:	a0 70       	andi	r26, 0x00	; 0
     c36:	b0 70       	andi	r27, 0x00	; 0
     c38:	80 34       	cpi	r24, 0x40	; 64
     c3a:	91 05       	cpc	r25, r1
     c3c:	a1 05       	cpc	r26, r1
     c3e:	b1 05       	cpc	r27, r1
     c40:	39 f4       	brne	.+14     	; 0xc50 <__pack_f+0x144>
     c42:	e7 fe       	sbrs	r14, 7
     c44:	0d c0       	rjmp	.+26     	; 0xc60 <__pack_f+0x154>
     c46:	80 e4       	ldi	r24, 0x40	; 64
     c48:	90 e0       	ldi	r25, 0x00	; 0
     c4a:	a0 e0       	ldi	r26, 0x00	; 0
     c4c:	b0 e0       	ldi	r27, 0x00	; 0
     c4e:	04 c0       	rjmp	.+8      	; 0xc58 <__pack_f+0x14c>
     c50:	8f e3       	ldi	r24, 0x3F	; 63
     c52:	90 e0       	ldi	r25, 0x00	; 0
     c54:	a0 e0       	ldi	r26, 0x00	; 0
     c56:	b0 e0       	ldi	r27, 0x00	; 0
     c58:	e8 0e       	add	r14, r24
     c5a:	f9 1e       	adc	r15, r25
     c5c:	0a 1f       	adc	r16, r26
     c5e:	1b 1f       	adc	r17, r27
     c60:	17 ff       	sbrs	r17, 7
     c62:	05 c0       	rjmp	.+10     	; 0xc6e <__pack_f+0x162>
     c64:	16 95       	lsr	r17
     c66:	07 95       	ror	r16
     c68:	f7 94       	ror	r15
     c6a:	e7 94       	ror	r14
     c6c:	31 96       	adiw	r30, 0x01	; 1
     c6e:	87 e0       	ldi	r24, 0x07	; 7
     c70:	16 95       	lsr	r17
     c72:	07 95       	ror	r16
     c74:	f7 94       	ror	r15
     c76:	e7 94       	ror	r14
     c78:	8a 95       	dec	r24
     c7a:	d1 f7       	brne	.-12     	; 0xc70 <__pack_f+0x164>
     c7c:	05 c0       	rjmp	.+10     	; 0xc88 <__pack_f+0x17c>
     c7e:	ee 24       	eor	r14, r14
     c80:	ff 24       	eor	r15, r15
     c82:	87 01       	movw	r16, r14
     c84:	ef ef       	ldi	r30, 0xFF	; 255
     c86:	f0 e0       	ldi	r31, 0x00	; 0
     c88:	6e 2f       	mov	r22, r30
     c8a:	67 95       	ror	r22
     c8c:	66 27       	eor	r22, r22
     c8e:	67 95       	ror	r22
     c90:	90 2f       	mov	r25, r16
     c92:	9f 77       	andi	r25, 0x7F	; 127
     c94:	d7 94       	ror	r13
     c96:	dd 24       	eor	r13, r13
     c98:	d7 94       	ror	r13
     c9a:	8e 2f       	mov	r24, r30
     c9c:	86 95       	lsr	r24
     c9e:	49 2f       	mov	r20, r25
     ca0:	46 2b       	or	r20, r22
     ca2:	58 2f       	mov	r21, r24
     ca4:	5d 29       	or	r21, r13
     ca6:	b7 01       	movw	r22, r14
     ca8:	ca 01       	movw	r24, r20
     caa:	1f 91       	pop	r17
     cac:	0f 91       	pop	r16
     cae:	ff 90       	pop	r15
     cb0:	ef 90       	pop	r14
     cb2:	df 90       	pop	r13
     cb4:	08 95       	ret

00000cb6 <__unpack_f>:
     cb6:	fc 01       	movw	r30, r24
     cb8:	db 01       	movw	r26, r22
     cba:	40 81       	ld	r20, Z
     cbc:	51 81       	ldd	r21, Z+1	; 0x01
     cbe:	22 81       	ldd	r18, Z+2	; 0x02
     cc0:	62 2f       	mov	r22, r18
     cc2:	6f 77       	andi	r22, 0x7F	; 127
     cc4:	70 e0       	ldi	r23, 0x00	; 0
     cc6:	22 1f       	adc	r18, r18
     cc8:	22 27       	eor	r18, r18
     cca:	22 1f       	adc	r18, r18
     ccc:	93 81       	ldd	r25, Z+3	; 0x03
     cce:	89 2f       	mov	r24, r25
     cd0:	88 0f       	add	r24, r24
     cd2:	82 2b       	or	r24, r18
     cd4:	28 2f       	mov	r18, r24
     cd6:	30 e0       	ldi	r19, 0x00	; 0
     cd8:	99 1f       	adc	r25, r25
     cda:	99 27       	eor	r25, r25
     cdc:	99 1f       	adc	r25, r25
     cde:	11 96       	adiw	r26, 0x01	; 1
     ce0:	9c 93       	st	X, r25
     ce2:	11 97       	sbiw	r26, 0x01	; 1
     ce4:	21 15       	cp	r18, r1
     ce6:	31 05       	cpc	r19, r1
     ce8:	a9 f5       	brne	.+106    	; 0xd54 <__unpack_f+0x9e>
     cea:	41 15       	cp	r20, r1
     cec:	51 05       	cpc	r21, r1
     cee:	61 05       	cpc	r22, r1
     cf0:	71 05       	cpc	r23, r1
     cf2:	11 f4       	brne	.+4      	; 0xcf8 <__unpack_f+0x42>
     cf4:	82 e0       	ldi	r24, 0x02	; 2
     cf6:	37 c0       	rjmp	.+110    	; 0xd66 <__unpack_f+0xb0>
     cf8:	82 e8       	ldi	r24, 0x82	; 130
     cfa:	9f ef       	ldi	r25, 0xFF	; 255
     cfc:	13 96       	adiw	r26, 0x03	; 3
     cfe:	9c 93       	st	X, r25
     d00:	8e 93       	st	-X, r24
     d02:	12 97       	sbiw	r26, 0x02	; 2
     d04:	9a 01       	movw	r18, r20
     d06:	ab 01       	movw	r20, r22
     d08:	67 e0       	ldi	r22, 0x07	; 7
     d0a:	22 0f       	add	r18, r18
     d0c:	33 1f       	adc	r19, r19
     d0e:	44 1f       	adc	r20, r20
     d10:	55 1f       	adc	r21, r21
     d12:	6a 95       	dec	r22
     d14:	d1 f7       	brne	.-12     	; 0xd0a <__unpack_f+0x54>
     d16:	83 e0       	ldi	r24, 0x03	; 3
     d18:	8c 93       	st	X, r24
     d1a:	0d c0       	rjmp	.+26     	; 0xd36 <__unpack_f+0x80>
     d1c:	22 0f       	add	r18, r18
     d1e:	33 1f       	adc	r19, r19
     d20:	44 1f       	adc	r20, r20
     d22:	55 1f       	adc	r21, r21
     d24:	12 96       	adiw	r26, 0x02	; 2
     d26:	8d 91       	ld	r24, X+
     d28:	9c 91       	ld	r25, X
     d2a:	13 97       	sbiw	r26, 0x03	; 3
     d2c:	01 97       	sbiw	r24, 0x01	; 1
     d2e:	13 96       	adiw	r26, 0x03	; 3
     d30:	9c 93       	st	X, r25
     d32:	8e 93       	st	-X, r24
     d34:	12 97       	sbiw	r26, 0x02	; 2
     d36:	20 30       	cpi	r18, 0x00	; 0
     d38:	80 e0       	ldi	r24, 0x00	; 0
     d3a:	38 07       	cpc	r19, r24
     d3c:	80 e0       	ldi	r24, 0x00	; 0
     d3e:	48 07       	cpc	r20, r24
     d40:	80 e4       	ldi	r24, 0x40	; 64
     d42:	58 07       	cpc	r21, r24
     d44:	58 f3       	brcs	.-42     	; 0xd1c <__unpack_f+0x66>
     d46:	14 96       	adiw	r26, 0x04	; 4
     d48:	2d 93       	st	X+, r18
     d4a:	3d 93       	st	X+, r19
     d4c:	4d 93       	st	X+, r20
     d4e:	5c 93       	st	X, r21
     d50:	17 97       	sbiw	r26, 0x07	; 7
     d52:	08 95       	ret
     d54:	2f 3f       	cpi	r18, 0xFF	; 255
     d56:	31 05       	cpc	r19, r1
     d58:	79 f4       	brne	.+30     	; 0xd78 <__unpack_f+0xc2>
     d5a:	41 15       	cp	r20, r1
     d5c:	51 05       	cpc	r21, r1
     d5e:	61 05       	cpc	r22, r1
     d60:	71 05       	cpc	r23, r1
     d62:	19 f4       	brne	.+6      	; 0xd6a <__unpack_f+0xb4>
     d64:	84 e0       	ldi	r24, 0x04	; 4
     d66:	8c 93       	st	X, r24
     d68:	08 95       	ret
     d6a:	64 ff       	sbrs	r22, 4
     d6c:	03 c0       	rjmp	.+6      	; 0xd74 <__unpack_f+0xbe>
     d6e:	81 e0       	ldi	r24, 0x01	; 1
     d70:	8c 93       	st	X, r24
     d72:	12 c0       	rjmp	.+36     	; 0xd98 <__unpack_f+0xe2>
     d74:	1c 92       	st	X, r1
     d76:	10 c0       	rjmp	.+32     	; 0xd98 <__unpack_f+0xe2>
     d78:	2f 57       	subi	r18, 0x7F	; 127
     d7a:	30 40       	sbci	r19, 0x00	; 0
     d7c:	13 96       	adiw	r26, 0x03	; 3
     d7e:	3c 93       	st	X, r19
     d80:	2e 93       	st	-X, r18
     d82:	12 97       	sbiw	r26, 0x02	; 2
     d84:	83 e0       	ldi	r24, 0x03	; 3
     d86:	8c 93       	st	X, r24
     d88:	87 e0       	ldi	r24, 0x07	; 7
     d8a:	44 0f       	add	r20, r20
     d8c:	55 1f       	adc	r21, r21
     d8e:	66 1f       	adc	r22, r22
     d90:	77 1f       	adc	r23, r23
     d92:	8a 95       	dec	r24
     d94:	d1 f7       	brne	.-12     	; 0xd8a <__unpack_f+0xd4>
     d96:	70 64       	ori	r23, 0x40	; 64
     d98:	14 96       	adiw	r26, 0x04	; 4
     d9a:	4d 93       	st	X+, r20
     d9c:	5d 93       	st	X+, r21
     d9e:	6d 93       	st	X+, r22
     da0:	7c 93       	st	X, r23
     da2:	17 97       	sbiw	r26, 0x07	; 7
     da4:	08 95       	ret

00000da6 <__fpcmp_parts_f>:
     da6:	1f 93       	push	r17
     da8:	dc 01       	movw	r26, r24
     daa:	fb 01       	movw	r30, r22
     dac:	9c 91       	ld	r25, X
     dae:	92 30       	cpi	r25, 0x02	; 2
     db0:	08 f4       	brcc	.+2      	; 0xdb4 <__fpcmp_parts_f+0xe>
     db2:	47 c0       	rjmp	.+142    	; 0xe42 <__fpcmp_parts_f+0x9c>
     db4:	80 81       	ld	r24, Z
     db6:	82 30       	cpi	r24, 0x02	; 2
     db8:	08 f4       	brcc	.+2      	; 0xdbc <__fpcmp_parts_f+0x16>
     dba:	43 c0       	rjmp	.+134    	; 0xe42 <__fpcmp_parts_f+0x9c>
     dbc:	94 30       	cpi	r25, 0x04	; 4
     dbe:	51 f4       	brne	.+20     	; 0xdd4 <__fpcmp_parts_f+0x2e>
     dc0:	11 96       	adiw	r26, 0x01	; 1
     dc2:	1c 91       	ld	r17, X
     dc4:	84 30       	cpi	r24, 0x04	; 4
     dc6:	99 f5       	brne	.+102    	; 0xe2e <__fpcmp_parts_f+0x88>
     dc8:	81 81       	ldd	r24, Z+1	; 0x01
     dca:	68 2f       	mov	r22, r24
     dcc:	70 e0       	ldi	r23, 0x00	; 0
     dce:	61 1b       	sub	r22, r17
     dd0:	71 09       	sbc	r23, r1
     dd2:	3f c0       	rjmp	.+126    	; 0xe52 <__fpcmp_parts_f+0xac>
     dd4:	84 30       	cpi	r24, 0x04	; 4
     dd6:	21 f0       	breq	.+8      	; 0xde0 <__fpcmp_parts_f+0x3a>
     dd8:	92 30       	cpi	r25, 0x02	; 2
     dda:	31 f4       	brne	.+12     	; 0xde8 <__fpcmp_parts_f+0x42>
     ddc:	82 30       	cpi	r24, 0x02	; 2
     dde:	b9 f1       	breq	.+110    	; 0xe4e <__fpcmp_parts_f+0xa8>
     de0:	81 81       	ldd	r24, Z+1	; 0x01
     de2:	88 23       	and	r24, r24
     de4:	89 f1       	breq	.+98     	; 0xe48 <__fpcmp_parts_f+0xa2>
     de6:	2d c0       	rjmp	.+90     	; 0xe42 <__fpcmp_parts_f+0x9c>
     de8:	11 96       	adiw	r26, 0x01	; 1
     dea:	1c 91       	ld	r17, X
     dec:	11 97       	sbiw	r26, 0x01	; 1
     dee:	82 30       	cpi	r24, 0x02	; 2
     df0:	f1 f0       	breq	.+60     	; 0xe2e <__fpcmp_parts_f+0x88>
     df2:	81 81       	ldd	r24, Z+1	; 0x01
     df4:	18 17       	cp	r17, r24
     df6:	d9 f4       	brne	.+54     	; 0xe2e <__fpcmp_parts_f+0x88>
     df8:	12 96       	adiw	r26, 0x02	; 2
     dfa:	2d 91       	ld	r18, X+
     dfc:	3c 91       	ld	r19, X
     dfe:	13 97       	sbiw	r26, 0x03	; 3
     e00:	82 81       	ldd	r24, Z+2	; 0x02
     e02:	93 81       	ldd	r25, Z+3	; 0x03
     e04:	82 17       	cp	r24, r18
     e06:	93 07       	cpc	r25, r19
     e08:	94 f0       	brlt	.+36     	; 0xe2e <__fpcmp_parts_f+0x88>
     e0a:	28 17       	cp	r18, r24
     e0c:	39 07       	cpc	r19, r25
     e0e:	bc f0       	brlt	.+46     	; 0xe3e <__fpcmp_parts_f+0x98>
     e10:	14 96       	adiw	r26, 0x04	; 4
     e12:	8d 91       	ld	r24, X+
     e14:	9d 91       	ld	r25, X+
     e16:	0d 90       	ld	r0, X+
     e18:	bc 91       	ld	r27, X
     e1a:	a0 2d       	mov	r26, r0
     e1c:	24 81       	ldd	r18, Z+4	; 0x04
     e1e:	35 81       	ldd	r19, Z+5	; 0x05
     e20:	46 81       	ldd	r20, Z+6	; 0x06
     e22:	57 81       	ldd	r21, Z+7	; 0x07
     e24:	28 17       	cp	r18, r24
     e26:	39 07       	cpc	r19, r25
     e28:	4a 07       	cpc	r20, r26
     e2a:	5b 07       	cpc	r21, r27
     e2c:	18 f4       	brcc	.+6      	; 0xe34 <__fpcmp_parts_f+0x8e>
     e2e:	11 23       	and	r17, r17
     e30:	41 f0       	breq	.+16     	; 0xe42 <__fpcmp_parts_f+0x9c>
     e32:	0a c0       	rjmp	.+20     	; 0xe48 <__fpcmp_parts_f+0xa2>
     e34:	82 17       	cp	r24, r18
     e36:	93 07       	cpc	r25, r19
     e38:	a4 07       	cpc	r26, r20
     e3a:	b5 07       	cpc	r27, r21
     e3c:	40 f4       	brcc	.+16     	; 0xe4e <__fpcmp_parts_f+0xa8>
     e3e:	11 23       	and	r17, r17
     e40:	19 f0       	breq	.+6      	; 0xe48 <__fpcmp_parts_f+0xa2>
     e42:	61 e0       	ldi	r22, 0x01	; 1
     e44:	70 e0       	ldi	r23, 0x00	; 0
     e46:	05 c0       	rjmp	.+10     	; 0xe52 <__fpcmp_parts_f+0xac>
     e48:	6f ef       	ldi	r22, 0xFF	; 255
     e4a:	7f ef       	ldi	r23, 0xFF	; 255
     e4c:	02 c0       	rjmp	.+4      	; 0xe52 <__fpcmp_parts_f+0xac>
     e4e:	60 e0       	ldi	r22, 0x00	; 0
     e50:	70 e0       	ldi	r23, 0x00	; 0
     e52:	cb 01       	movw	r24, r22
     e54:	1f 91       	pop	r17
     e56:	08 95       	ret

00000e58 <vStartPolledQueueTasks>:
static volatile BaseType_t xPollingConsumerCount = pollqINITIAL_VALUE, xPollingProducerCount = pollqINITIAL_VALUE;

/*-----------------------------------------------------------*/

void vStartPolledQueueTasks( UBaseType_t uxPriority )
{
     e58:	af 92       	push	r10
     e5a:	bf 92       	push	r11
     e5c:	cf 92       	push	r12
     e5e:	df 92       	push	r13
     e60:	ef 92       	push	r14
     e62:	ff 92       	push	r15
     e64:	0f 93       	push	r16
     e66:	df 93       	push	r29
     e68:	cf 93       	push	r28
     e6a:	0f 92       	push	r0
     e6c:	cd b7       	in	r28, 0x3d	; 61
     e6e:	de b7       	in	r29, 0x3e	; 62
     e70:	89 83       	std	Y+1, r24	; 0x01
static QueueHandle_t xPolledQueue;

	/* Create the queue used by the producer and consumer. */
	xPolledQueue = xQueueCreate( pollqQUEUE_SIZE, ( UBaseType_t ) sizeof( uint16_t ) );
     e72:	8a e0       	ldi	r24, 0x0A	; 10
     e74:	62 e0       	ldi	r22, 0x02	; 2
     e76:	40 e0       	ldi	r20, 0x00	; 0
     e78:	0e 94 0c 14 	call	0x2818	; 0x2818 <xQueueGenericCreate>
     e7c:	90 93 0b 02 	sts	0x020B, r25
     e80:	80 93 0a 02 	sts	0x020A, r24
	by the pre-processor if configQUEUE_REGISTRY_SIZE is not defined or is 
	defined to be less than 1. */
	vQueueAddToRegistry( xPolledQueue, "Poll_Test_Queue" );

	/* Spawn the producer and consumer. */
	xTaskCreate( vPolledQueueConsumer, "QConsNB", pollqSTACK_SIZE, ( void * ) &xPolledQueue, uxPriority, ( TaskHandle_t * ) NULL );
     e84:	80 eb       	ldi	r24, 0xB0	; 176
     e86:	97 e0       	ldi	r25, 0x07	; 7
     e88:	20 e6       	ldi	r18, 0x60	; 96
     e8a:	30 e0       	ldi	r19, 0x00	; 0
     e8c:	ea e0       	ldi	r30, 0x0A	; 10
     e8e:	f2 e0       	ldi	r31, 0x02	; 2
     e90:	b9 01       	movw	r22, r18
     e92:	45 e5       	ldi	r20, 0x55	; 85
     e94:	50 e0       	ldi	r21, 0x00	; 0
     e96:	9f 01       	movw	r18, r30
     e98:	09 81       	ldd	r16, Y+1	; 0x01
     e9a:	ee 24       	eor	r14, r14
     e9c:	ff 24       	eor	r15, r15
     e9e:	cc 24       	eor	r12, r12
     ea0:	dd 24       	eor	r13, r13
     ea2:	aa 24       	eor	r10, r10
     ea4:	bb 24       	eor	r11, r11
     ea6:	0e 94 32 1b 	call	0x3664	; 0x3664 <xTaskGenericCreate>
	xTaskCreate( vPolledQueueProducer, "QProdNB", pollqSTACK_SIZE, ( void * ) &xPolledQueue, uxPriority, ( TaskHandle_t * ) NULL );
     eaa:	83 e7       	ldi	r24, 0x73	; 115
     eac:	97 e0       	ldi	r25, 0x07	; 7
     eae:	28 e6       	ldi	r18, 0x68	; 104
     eb0:	30 e0       	ldi	r19, 0x00	; 0
     eb2:	ea e0       	ldi	r30, 0x0A	; 10
     eb4:	f2 e0       	ldi	r31, 0x02	; 2
     eb6:	b9 01       	movw	r22, r18
     eb8:	45 e5       	ldi	r20, 0x55	; 85
     eba:	50 e0       	ldi	r21, 0x00	; 0
     ebc:	9f 01       	movw	r18, r30
     ebe:	09 81       	ldd	r16, Y+1	; 0x01
     ec0:	ee 24       	eor	r14, r14
     ec2:	ff 24       	eor	r15, r15
     ec4:	cc 24       	eor	r12, r12
     ec6:	dd 24       	eor	r13, r13
     ec8:	aa 24       	eor	r10, r10
     eca:	bb 24       	eor	r11, r11
     ecc:	0e 94 32 1b 	call	0x3664	; 0x3664 <xTaskGenericCreate>
}
     ed0:	0f 90       	pop	r0
     ed2:	cf 91       	pop	r28
     ed4:	df 91       	pop	r29
     ed6:	0f 91       	pop	r16
     ed8:	ff 90       	pop	r15
     eda:	ef 90       	pop	r14
     edc:	df 90       	pop	r13
     ede:	cf 90       	pop	r12
     ee0:	bf 90       	pop	r11
     ee2:	af 90       	pop	r10
     ee4:	08 95       	ret

00000ee6 <vPolledQueueProducer>:
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vPolledQueueProducer, pvParameters )
{
     ee6:	df 93       	push	r29
     ee8:	cf 93       	push	r28
     eea:	00 d0       	rcall	.+0      	; 0xeec <vPolledQueueProducer+0x6>
     eec:	00 d0       	rcall	.+0      	; 0xeee <vPolledQueueProducer+0x8>
     eee:	00 d0       	rcall	.+0      	; 0xef0 <vPolledQueueProducer+0xa>
     ef0:	cd b7       	in	r28, 0x3d	; 61
     ef2:	de b7       	in	r29, 0x3e	; 62
     ef4:	9e 83       	std	Y+6, r25	; 0x06
     ef6:	8d 83       	std	Y+5, r24	; 0x05
uint16_t usValue = ( uint16_t ) 0;
     ef8:	1c 82       	std	Y+4, r1	; 0x04
     efa:	1b 82       	std	Y+3, r1	; 0x03
BaseType_t xError = pdFALSE, xLoop;
     efc:	1a 82       	std	Y+2, r1	; 0x02

	for( ;; )
	{		
		for( xLoop = 0; xLoop < pollqVALUES_TO_PRODUCE; xLoop++ )
     efe:	19 82       	std	Y+1, r1	; 0x01
     f00:	27 c0       	rjmp	.+78     	; 0xf50 <vPolledQueueProducer+0x6a>
		{
			/* Send an incrementing number on the queue without blocking. */
			if( xQueueSend( *( ( QueueHandle_t * ) pvParameters ), ( void * ) &usValue, pollqNO_DELAY ) != pdPASS )
     f02:	ed 81       	ldd	r30, Y+5	; 0x05
     f04:	fe 81       	ldd	r31, Y+6	; 0x06
     f06:	80 81       	ld	r24, Z
     f08:	91 81       	ldd	r25, Z+1	; 0x01
     f0a:	9e 01       	movw	r18, r28
     f0c:	2d 5f       	subi	r18, 0xFD	; 253
     f0e:	3f 4f       	sbci	r19, 0xFF	; 255
     f10:	b9 01       	movw	r22, r18
     f12:	40 e0       	ldi	r20, 0x00	; 0
     f14:	50 e0       	ldi	r21, 0x00	; 0
     f16:	20 e0       	ldi	r18, 0x00	; 0
     f18:	0e 94 d7 14 	call	0x29ae	; 0x29ae <xQueueGenericSend>
     f1c:	81 30       	cpi	r24, 0x01	; 1
     f1e:	19 f0       	breq	.+6      	; 0xf26 <vPolledQueueProducer+0x40>
			{
				/* We should never find the queue full so if we get here there
				has been an error. */
				xError = pdTRUE;
     f20:	81 e0       	ldi	r24, 0x01	; 1
     f22:	8a 83       	std	Y+2, r24	; 0x02
     f24:	12 c0       	rjmp	.+36     	; 0xf4a <vPolledQueueProducer+0x64>
			}
			else
			{
				if( xError == pdFALSE )
     f26:	8a 81       	ldd	r24, Y+2	; 0x02
     f28:	88 23       	and	r24, r24
     f2a:	51 f4       	brne	.+20     	; 0xf40 <vPolledQueueProducer+0x5a>
				{
					/* If an error has ever been recorded we stop incrementing the
					check variable. */
					portENTER_CRITICAL();
     f2c:	0f b6       	in	r0, 0x3f	; 63
     f2e:	f8 94       	cli
     f30:	0f 92       	push	r0
						xPollingProducerCount++;
     f32:	80 91 09 02 	lds	r24, 0x0209
     f36:	8f 5f       	subi	r24, 0xFF	; 255
     f38:	80 93 09 02 	sts	0x0209, r24
					portEXIT_CRITICAL();
     f3c:	0f 90       	pop	r0
     f3e:	0f be       	out	0x3f, r0	; 63
				}

				/* Update the value we are going to post next time around. */
				usValue++;
     f40:	8b 81       	ldd	r24, Y+3	; 0x03
     f42:	9c 81       	ldd	r25, Y+4	; 0x04
     f44:	01 96       	adiw	r24, 0x01	; 1
     f46:	9c 83       	std	Y+4, r25	; 0x04
     f48:	8b 83       	std	Y+3, r24	; 0x03
uint16_t usValue = ( uint16_t ) 0;
BaseType_t xError = pdFALSE, xLoop;

	for( ;; )
	{		
		for( xLoop = 0; xLoop < pollqVALUES_TO_PRODUCE; xLoop++ )
     f4a:	89 81       	ldd	r24, Y+1	; 0x01
     f4c:	8f 5f       	subi	r24, 0xFF	; 255
     f4e:	89 83       	std	Y+1, r24	; 0x01
     f50:	89 81       	ldd	r24, Y+1	; 0x01
     f52:	83 30       	cpi	r24, 0x03	; 3
     f54:	b4 f2       	brlt	.-84     	; 0xf02 <vPolledQueueProducer+0x1c>
			}
		}

		/* Wait before we start posting again to ensure the consumer runs and
		empties the queue. */
		vTaskDelay( pollqPRODUCER_DELAY );
     f56:	88 ec       	ldi	r24, 0xC8	; 200
     f58:	90 e0       	ldi	r25, 0x00	; 0
     f5a:	0e 94 ec 1c 	call	0x39d8	; 0x39d8 <vTaskDelay>
     f5e:	cf cf       	rjmp	.-98     	; 0xefe <vPolledQueueProducer+0x18>

00000f60 <vPolledQueueConsumer>:
	}
}  /*lint !e818 Function prototype must conform to API. */
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vPolledQueueConsumer, pvParameters )
{
     f60:	df 93       	push	r29
     f62:	cf 93       	push	r28
     f64:	cd b7       	in	r28, 0x3d	; 61
     f66:	de b7       	in	r29, 0x3e	; 62
     f68:	27 97       	sbiw	r28, 0x07	; 7
     f6a:	0f b6       	in	r0, 0x3f	; 63
     f6c:	f8 94       	cli
     f6e:	de bf       	out	0x3e, r29	; 62
     f70:	0f be       	out	0x3f, r0	; 63
     f72:	cd bf       	out	0x3d, r28	; 61
     f74:	9f 83       	std	Y+7, r25	; 0x07
     f76:	8e 83       	std	Y+6, r24	; 0x06
uint16_t usData, usExpectedValue = ( uint16_t ) 0;
     f78:	1b 82       	std	Y+3, r1	; 0x03
     f7a:	1a 82       	std	Y+2, r1	; 0x02
BaseType_t xError = pdFALSE;
     f7c:	19 82       	std	Y+1, r1	; 0x01
     f7e:	2f c0       	rjmp	.+94     	; 0xfde <vPolledQueueConsumer+0x7e>
	for( ;; )
	{		
		/* Loop until the queue is empty. */
		while( uxQueueMessagesWaiting( *( ( QueueHandle_t * ) pvParameters ) ) )
		{
			if( xQueueReceive( *( ( QueueHandle_t * ) pvParameters ), &usData, pollqNO_DELAY ) == pdPASS )
     f80:	ee 81       	ldd	r30, Y+6	; 0x06
     f82:	ff 81       	ldd	r31, Y+7	; 0x07
     f84:	80 81       	ld	r24, Z
     f86:	91 81       	ldd	r25, Z+1	; 0x01
     f88:	9e 01       	movw	r18, r28
     f8a:	2c 5f       	subi	r18, 0xFC	; 252
     f8c:	3f 4f       	sbci	r19, 0xFF	; 255
     f8e:	b9 01       	movw	r22, r18
     f90:	40 e0       	ldi	r20, 0x00	; 0
     f92:	50 e0       	ldi	r21, 0x00	; 0
     f94:	20 e0       	ldi	r18, 0x00	; 0
     f96:	0e 94 e5 15 	call	0x2bca	; 0x2bca <xQueueGenericReceive>
     f9a:	81 30       	cpi	r24, 0x01	; 1
     f9c:	01 f5       	brne	.+64     	; 0xfde <vPolledQueueConsumer+0x7e>
			{
				if( usData != usExpectedValue )
     f9e:	2c 81       	ldd	r18, Y+4	; 0x04
     fa0:	3d 81       	ldd	r19, Y+5	; 0x05
     fa2:	8a 81       	ldd	r24, Y+2	; 0x02
     fa4:	9b 81       	ldd	r25, Y+3	; 0x03
     fa6:	28 17       	cp	r18, r24
     fa8:	39 07       	cpc	r19, r25
     faa:	39 f0       	breq	.+14     	; 0xfba <vPolledQueueConsumer+0x5a>
				{
					/* This is not what we expected to receive so an error has
					occurred. */
					xError = pdTRUE;
     fac:	81 e0       	ldi	r24, 0x01	; 1
     fae:	89 83       	std	Y+1, r24	; 0x01

					/* Catch-up to the value we received so our next expected
					value should again be correct. */
					usExpectedValue = usData;
     fb0:	8c 81       	ldd	r24, Y+4	; 0x04
     fb2:	9d 81       	ldd	r25, Y+5	; 0x05
     fb4:	9b 83       	std	Y+3, r25	; 0x03
     fb6:	8a 83       	std	Y+2, r24	; 0x02
     fb8:	0d c0       	rjmp	.+26     	; 0xfd4 <vPolledQueueConsumer+0x74>
				}
				else
				{
					if( xError == pdFALSE )
     fba:	89 81       	ldd	r24, Y+1	; 0x01
     fbc:	88 23       	and	r24, r24
     fbe:	51 f4       	brne	.+20     	; 0xfd4 <vPolledQueueConsumer+0x74>
					{
						/* Only increment the check variable if no errors have
						occurred. */
						portENTER_CRITICAL();
     fc0:	0f b6       	in	r0, 0x3f	; 63
     fc2:	f8 94       	cli
     fc4:	0f 92       	push	r0
							xPollingConsumerCount++;
     fc6:	80 91 08 02 	lds	r24, 0x0208
     fca:	8f 5f       	subi	r24, 0xFF	; 255
     fcc:	80 93 08 02 	sts	0x0208, r24
						portEXIT_CRITICAL();
     fd0:	0f 90       	pop	r0
     fd2:	0f be       	out	0x3f, r0	; 63
					}
				}

				/* Next time round we would expect the number to be one higher. */
				usExpectedValue++;
     fd4:	8a 81       	ldd	r24, Y+2	; 0x02
     fd6:	9b 81       	ldd	r25, Y+3	; 0x03
     fd8:	01 96       	adiw	r24, 0x01	; 1
     fda:	9b 83       	std	Y+3, r25	; 0x03
     fdc:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xError = pdFALSE;

	for( ;; )
	{		
		/* Loop until the queue is empty. */
		while( uxQueueMessagesWaiting( *( ( QueueHandle_t * ) pvParameters ) ) )
     fde:	ee 81       	ldd	r30, Y+6	; 0x06
     fe0:	ff 81       	ldd	r31, Y+7	; 0x07
     fe2:	80 81       	ld	r24, Z
     fe4:	91 81       	ldd	r25, Z+1	; 0x01
     fe6:	0e 94 56 17 	call	0x2eac	; 0x2eac <uxQueueMessagesWaiting>
     fea:	88 23       	and	r24, r24
     fec:	49 f6       	brne	.-110    	; 0xf80 <vPolledQueueConsumer+0x20>
			}
		}

		/* Now the queue is empty we block, allowing the producer to place more
		items in the queue. */
		vTaskDelay( pollqCONSUMER_DELAY );
     fee:	84 eb       	ldi	r24, 0xB4	; 180
     ff0:	90 e0       	ldi	r25, 0x00	; 0
     ff2:	0e 94 ec 1c 	call	0x39d8	; 0x39d8 <vTaskDelay>
     ff6:	f3 cf       	rjmp	.-26     	; 0xfde <vPolledQueueConsumer+0x7e>

00000ff8 <xArePollingQueuesStillRunning>:
} /*lint !e818 Function prototype must conform to API. */
/*-----------------------------------------------------------*/

/* This is called to check that all the created tasks are still running with no errors. */
BaseType_t xArePollingQueuesStillRunning( void )
{
     ff8:	df 93       	push	r29
     ffa:	cf 93       	push	r28
     ffc:	0f 92       	push	r0
     ffe:	cd b7       	in	r28, 0x3d	; 61
    1000:	de b7       	in	r29, 0x3e	; 62

	/* Check both the consumer and producer poll count to check they have both
	been changed since out last trip round.  We do not need a critical section
	around the check variables as this is called from a higher priority than
	the other tasks that access the same variables. */
	if( ( xPollingConsumerCount == pollqINITIAL_VALUE ) ||
    1002:	80 91 08 02 	lds	r24, 0x0208
    1006:	88 23       	and	r24, r24
    1008:	21 f0       	breq	.+8      	; 0x1012 <xArePollingQueuesStillRunning+0x1a>
    100a:	80 91 09 02 	lds	r24, 0x0209
    100e:	88 23       	and	r24, r24
    1010:	11 f4       	brne	.+4      	; 0x1016 <xArePollingQueuesStillRunning+0x1e>
		( xPollingProducerCount == pollqINITIAL_VALUE )
	  )
	{
		xReturn = pdFALSE;
    1012:	19 82       	std	Y+1, r1	; 0x01
    1014:	02 c0       	rjmp	.+4      	; 0x101a <xArePollingQueuesStillRunning+0x22>
	}
	else
	{
		xReturn = pdTRUE;
    1016:	81 e0       	ldi	r24, 0x01	; 1
    1018:	89 83       	std	Y+1, r24	; 0x01
	}

	/* Set the check variables back down so we know if they have been
	incremented the next time around. */
	xPollingConsumerCount = pollqINITIAL_VALUE;
    101a:	10 92 08 02 	sts	0x0208, r1
	xPollingProducerCount = pollqINITIAL_VALUE;
    101e:	10 92 09 02 	sts	0x0209, r1

	return xReturn;
    1022:	89 81       	ldd	r24, Y+1	; 0x01
}
    1024:	0f 90       	pop	r0
    1026:	cf 91       	pop	r28
    1028:	df 91       	pop	r29
    102a:	08 95       	ret

0000102c <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

BaseType_t xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, UBaseType_t uxPriority, UBaseType_t uxIndex )
{
    102c:	df 93       	push	r29
    102e:	cf 93       	push	r28
    1030:	cd b7       	in	r28, 0x3d	; 61
    1032:	de b7       	in	r29, 0x3e	; 62
    1034:	27 97       	sbiw	r28, 0x07	; 7
    1036:	0f b6       	in	r0, 0x3f	; 63
    1038:	f8 94       	cli
    103a:	de bf       	out	0x3e, r29	; 62
    103c:	0f be       	out	0x3f, r0	; 63
    103e:	cd bf       	out	0x3d, r28	; 61
    1040:	9d 83       	std	Y+5, r25	; 0x05
    1042:	8c 83       	std	Y+4, r24	; 0x04
    1044:	6e 83       	std	Y+6, r22	; 0x06
    1046:	4f 83       	std	Y+7, r20	; 0x07
BaseType_t xReturn;
CRCB_t *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( CRCB_t * ) pvPortMalloc( sizeof( CRCB_t ) );
    1048:	8a e1       	ldi	r24, 0x1A	; 26
    104a:	90 e0       	ldi	r25, 0x00	; 0
    104c:	0e 94 2e 0e 	call	0x1c5c	; 0x1c5c <pvPortMalloc>
    1050:	9a 83       	std	Y+2, r25	; 0x02
    1052:	89 83       	std	Y+1, r24	; 0x01
	if( pxCoRoutine )
    1054:	89 81       	ldd	r24, Y+1	; 0x01
    1056:	9a 81       	ldd	r25, Y+2	; 0x02
    1058:	00 97       	sbiw	r24, 0x00	; 0
    105a:	09 f4       	brne	.+2      	; 0x105e <xCoRoutineCreate+0x32>
    105c:	6f c0       	rjmp	.+222    	; 0x113c <xCoRoutineCreate+0x110>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
    105e:	80 91 0c 02 	lds	r24, 0x020C
    1062:	90 91 0d 02 	lds	r25, 0x020D
    1066:	00 97       	sbiw	r24, 0x00	; 0
    1068:	41 f4       	brne	.+16     	; 0x107a <xCoRoutineCreate+0x4e>
		{
			pxCurrentCoRoutine = pxCoRoutine;
    106a:	89 81       	ldd	r24, Y+1	; 0x01
    106c:	9a 81       	ldd	r25, Y+2	; 0x02
    106e:	90 93 0d 02 	sts	0x020D, r25
    1072:	80 93 0c 02 	sts	0x020C, r24
			prvInitialiseCoRoutineLists();
    1076:	0e 94 7d 0a 	call	0x14fa	; 0x14fa <prvInitialiseCoRoutineLists>
		}

		/* Check the priority is within limits. */
		if( uxPriority >= configMAX_CO_ROUTINE_PRIORITIES )
    107a:	8e 81       	ldd	r24, Y+6	; 0x06
    107c:	82 30       	cpi	r24, 0x02	; 2
    107e:	10 f0       	brcs	.+4      	; 0x1084 <xCoRoutineCreate+0x58>
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
    1080:	81 e0       	ldi	r24, 0x01	; 1
    1082:	8e 83       	std	Y+6, r24	; 0x06
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
    1084:	e9 81       	ldd	r30, Y+1	; 0x01
    1086:	fa 81       	ldd	r31, Y+2	; 0x02
    1088:	11 8e       	std	Z+25, r1	; 0x19
    108a:	10 8e       	std	Z+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
    108c:	e9 81       	ldd	r30, Y+1	; 0x01
    108e:	fa 81       	ldd	r31, Y+2	; 0x02
    1090:	8e 81       	ldd	r24, Y+6	; 0x06
    1092:	86 8b       	std	Z+22, r24	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
    1094:	e9 81       	ldd	r30, Y+1	; 0x01
    1096:	fa 81       	ldd	r31, Y+2	; 0x02
    1098:	8f 81       	ldd	r24, Y+7	; 0x07
    109a:	87 8b       	std	Z+23, r24	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
    109c:	e9 81       	ldd	r30, Y+1	; 0x01
    109e:	fa 81       	ldd	r31, Y+2	; 0x02
    10a0:	8c 81       	ldd	r24, Y+4	; 0x04
    10a2:	9d 81       	ldd	r25, Y+5	; 0x05
    10a4:	91 83       	std	Z+1, r25	; 0x01
    10a6:	80 83       	st	Z, r24

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
    10a8:	89 81       	ldd	r24, Y+1	; 0x01
    10aa:	9a 81       	ldd	r25, Y+2	; 0x02
    10ac:	02 96       	adiw	r24, 0x02	; 2
    10ae:	0e 94 a6 0f 	call	0x1f4c	; 0x1f4c <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
    10b2:	89 81       	ldd	r24, Y+1	; 0x01
    10b4:	9a 81       	ldd	r25, Y+2	; 0x02
    10b6:	0c 96       	adiw	r24, 0x0c	; 12
    10b8:	0e 94 a6 0f 	call	0x1f4c	; 0x1f4c <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the ListItem_t.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
    10bc:	e9 81       	ldd	r30, Y+1	; 0x01
    10be:	fa 81       	ldd	r31, Y+2	; 0x02
    10c0:	89 81       	ldd	r24, Y+1	; 0x01
    10c2:	9a 81       	ldd	r25, Y+2	; 0x02
    10c4:	91 87       	std	Z+9, r25	; 0x09
    10c6:	80 87       	std	Z+8, r24	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
    10c8:	e9 81       	ldd	r30, Y+1	; 0x01
    10ca:	fa 81       	ldd	r31, Y+2	; 0x02
    10cc:	89 81       	ldd	r24, Y+1	; 0x01
    10ce:	9a 81       	ldd	r25, Y+2	; 0x02
    10d0:	93 8b       	std	Z+19, r25	; 0x13
    10d2:	82 8b       	std	Z+18, r24	; 0x12

		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), ( ( TickType_t ) configMAX_CO_ROUTINE_PRIORITIES - ( TickType_t ) uxPriority ) );
    10d4:	8e 81       	ldd	r24, Y+6	; 0x06
    10d6:	28 2f       	mov	r18, r24
    10d8:	30 e0       	ldi	r19, 0x00	; 0
    10da:	82 e0       	ldi	r24, 0x02	; 2
    10dc:	90 e0       	ldi	r25, 0x00	; 0
    10de:	82 1b       	sub	r24, r18
    10e0:	93 0b       	sbc	r25, r19
    10e2:	e9 81       	ldd	r30, Y+1	; 0x01
    10e4:	fa 81       	ldd	r31, Y+2	; 0x02
    10e6:	95 87       	std	Z+13, r25	; 0x0d
    10e8:	84 87       	std	Z+12, r24	; 0x0c

		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
    10ea:	e9 81       	ldd	r30, Y+1	; 0x01
    10ec:	fa 81       	ldd	r31, Y+2	; 0x02
    10ee:	96 89       	ldd	r25, Z+22	; 0x16
    10f0:	80 91 0e 02 	lds	r24, 0x020E
    10f4:	89 17       	cp	r24, r25
    10f6:	28 f4       	brcc	.+10     	; 0x1102 <xCoRoutineCreate+0xd6>
    10f8:	e9 81       	ldd	r30, Y+1	; 0x01
    10fa:	fa 81       	ldd	r31, Y+2	; 0x02
    10fc:	86 89       	ldd	r24, Z+22	; 0x16
    10fe:	80 93 0e 02 	sts	0x020E, r24
    1102:	e9 81       	ldd	r30, Y+1	; 0x01
    1104:	fa 81       	ldd	r31, Y+2	; 0x02
    1106:	86 89       	ldd	r24, Z+22	; 0x16
    1108:	28 2f       	mov	r18, r24
    110a:	30 e0       	ldi	r19, 0x00	; 0
    110c:	c9 01       	movw	r24, r18
    110e:	88 0f       	add	r24, r24
    1110:	99 1f       	adc	r25, r25
    1112:	88 0f       	add	r24, r24
    1114:	99 1f       	adc	r25, r25
    1116:	88 0f       	add	r24, r24
    1118:	99 1f       	adc	r25, r25
    111a:	82 0f       	add	r24, r18
    111c:	93 1f       	adc	r25, r19
    111e:	ac 01       	movw	r20, r24
    1120:	4b 5e       	subi	r20, 0xEB	; 235
    1122:	5d 4f       	sbci	r21, 0xFD	; 253
    1124:	89 81       	ldd	r24, Y+1	; 0x01
    1126:	9a 81       	ldd	r25, Y+2	; 0x02
    1128:	9c 01       	movw	r18, r24
    112a:	2e 5f       	subi	r18, 0xFE	; 254
    112c:	3f 4f       	sbci	r19, 0xFF	; 255
    112e:	ca 01       	movw	r24, r20
    1130:	b9 01       	movw	r22, r18
    1132:	0e 94 b6 0f 	call	0x1f6c	; 0x1f6c <vListInsertEnd>

		xReturn = pdPASS;
    1136:	81 e0       	ldi	r24, 0x01	; 1
    1138:	8b 83       	std	Y+3, r24	; 0x03
    113a:	02 c0       	rjmp	.+4      	; 0x1140 <xCoRoutineCreate+0x114>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    113c:	8f ef       	ldi	r24, 0xFF	; 255
    113e:	8b 83       	std	Y+3, r24	; 0x03
	}

	return xReturn;
    1140:	8b 81       	ldd	r24, Y+3	; 0x03
}
    1142:	27 96       	adiw	r28, 0x07	; 7
    1144:	0f b6       	in	r0, 0x3f	; 63
    1146:	f8 94       	cli
    1148:	de bf       	out	0x3e, r29	; 62
    114a:	0f be       	out	0x3f, r0	; 63
    114c:	cd bf       	out	0x3d, r28	; 61
    114e:	cf 91       	pop	r28
    1150:	df 91       	pop	r29
    1152:	08 95       	ret

00001154 <vCoRoutineAddToDelayedList>:
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( TickType_t xTicksToDelay, List_t *pxEventList )
{
    1154:	df 93       	push	r29
    1156:	cf 93       	push	r28
    1158:	00 d0       	rcall	.+0      	; 0x115a <vCoRoutineAddToDelayedList+0x6>
    115a:	00 d0       	rcall	.+0      	; 0x115c <vCoRoutineAddToDelayedList+0x8>
    115c:	00 d0       	rcall	.+0      	; 0x115e <vCoRoutineAddToDelayedList+0xa>
    115e:	cd b7       	in	r28, 0x3d	; 61
    1160:	de b7       	in	r29, 0x3e	; 62
    1162:	9c 83       	std	Y+4, r25	; 0x04
    1164:	8b 83       	std	Y+3, r24	; 0x03
    1166:	7e 83       	std	Y+6, r23	; 0x06
    1168:	6d 83       	std	Y+5, r22	; 0x05
TickType_t xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
    116a:	20 91 0f 02 	lds	r18, 0x020F
    116e:	30 91 10 02 	lds	r19, 0x0210
    1172:	8b 81       	ldd	r24, Y+3	; 0x03
    1174:	9c 81       	ldd	r25, Y+4	; 0x04
    1176:	82 0f       	add	r24, r18
    1178:	93 1f       	adc	r25, r19
    117a:	9a 83       	std	Y+2, r25	; 0x02
    117c:	89 83       	std	Y+1, r24	; 0x01

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	( void ) uxListRemove( ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    117e:	80 91 0c 02 	lds	r24, 0x020C
    1182:	90 91 0d 02 	lds	r25, 0x020D
    1186:	02 96       	adiw	r24, 0x02	; 2
    1188:	0e 94 66 10 	call	0x20cc	; 0x20cc <uxListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
    118c:	e0 91 0c 02 	lds	r30, 0x020C
    1190:	f0 91 0d 02 	lds	r31, 0x020D
    1194:	89 81       	ldd	r24, Y+1	; 0x01
    1196:	9a 81       	ldd	r25, Y+2	; 0x02
    1198:	93 83       	std	Z+3, r25	; 0x03
    119a:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
    119c:	20 91 0f 02 	lds	r18, 0x020F
    11a0:	30 91 10 02 	lds	r19, 0x0210
    11a4:	89 81       	ldd	r24, Y+1	; 0x01
    11a6:	9a 81       	ldd	r25, Y+2	; 0x02
    11a8:	82 17       	cp	r24, r18
    11aa:	93 07       	cpc	r25, r19
    11ac:	70 f4       	brcc	.+28     	; 0x11ca <vCoRoutineAddToDelayedList+0x76>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( List_t * ) pxOverflowDelayedCoRoutineList, ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    11ae:	80 91 3b 02 	lds	r24, 0x023B
    11b2:	90 91 3c 02 	lds	r25, 0x023C
    11b6:	20 91 0c 02 	lds	r18, 0x020C
    11ba:	30 91 0d 02 	lds	r19, 0x020D
    11be:	2e 5f       	subi	r18, 0xFE	; 254
    11c0:	3f 4f       	sbci	r19, 0xFF	; 255
    11c2:	b9 01       	movw	r22, r18
    11c4:	0e 94 fa 0f 	call	0x1ff4	; 0x1ff4 <vListInsert>
    11c8:	0d c0       	rjmp	.+26     	; 0x11e4 <vCoRoutineAddToDelayedList+0x90>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( List_t * ) pxDelayedCoRoutineList, ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    11ca:	80 91 39 02 	lds	r24, 0x0239
    11ce:	90 91 3a 02 	lds	r25, 0x023A
    11d2:	20 91 0c 02 	lds	r18, 0x020C
    11d6:	30 91 0d 02 	lds	r19, 0x020D
    11da:	2e 5f       	subi	r18, 0xFE	; 254
    11dc:	3f 4f       	sbci	r19, 0xFF	; 255
    11de:	b9 01       	movw	r22, r18
    11e0:	0e 94 fa 0f 	call	0x1ff4	; 0x1ff4 <vListInsert>
	}

	if( pxEventList )
    11e4:	8d 81       	ldd	r24, Y+5	; 0x05
    11e6:	9e 81       	ldd	r25, Y+6	; 0x06
    11e8:	00 97       	sbiw	r24, 0x00	; 0
    11ea:	61 f0       	breq	.+24     	; 0x1204 <vCoRoutineAddToDelayedList+0xb0>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
    11ec:	80 91 0c 02 	lds	r24, 0x020C
    11f0:	90 91 0d 02 	lds	r25, 0x020D
    11f4:	9c 01       	movw	r18, r24
    11f6:	24 5f       	subi	r18, 0xF4	; 244
    11f8:	3f 4f       	sbci	r19, 0xFF	; 255
    11fa:	8d 81       	ldd	r24, Y+5	; 0x05
    11fc:	9e 81       	ldd	r25, Y+6	; 0x06
    11fe:	b9 01       	movw	r22, r18
    1200:	0e 94 fa 0f 	call	0x1ff4	; 0x1ff4 <vListInsert>
	}
}
    1204:	26 96       	adiw	r28, 0x06	; 6
    1206:	0f b6       	in	r0, 0x3f	; 63
    1208:	f8 94       	cli
    120a:	de bf       	out	0x3e, r29	; 62
    120c:	0f be       	out	0x3f, r0	; 63
    120e:	cd bf       	out	0x3d, r28	; 61
    1210:	cf 91       	pop	r28
    1212:	df 91       	pop	r29
    1214:	08 95       	ret

00001216 <prvCheckPendingReadyList>:
/*-----------------------------------------------------------*/

static void prvCheckPendingReadyList( void )
{
    1216:	df 93       	push	r29
    1218:	cf 93       	push	r28
    121a:	00 d0       	rcall	.+0      	; 0x121c <prvCheckPendingReadyList+0x6>
    121c:	cd b7       	in	r28, 0x3d	; 61
    121e:	de b7       	in	r29, 0x3e	; 62
    1220:	3a c0       	rjmp	.+116    	; 0x1296 <prvCheckPendingReadyList+0x80>
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
	{
		CRCB_t *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
    1222:	f8 94       	cli
		{
			pxUnblockedCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );
    1224:	e0 91 42 02 	lds	r30, 0x0242
    1228:	f0 91 43 02 	lds	r31, 0x0243
    122c:	86 81       	ldd	r24, Z+6	; 0x06
    122e:	97 81       	ldd	r25, Z+7	; 0x07
    1230:	9a 83       	std	Y+2, r25	; 0x02
    1232:	89 83       	std	Y+1, r24	; 0x01
			( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    1234:	89 81       	ldd	r24, Y+1	; 0x01
    1236:	9a 81       	ldd	r25, Y+2	; 0x02
    1238:	0c 96       	adiw	r24, 0x0c	; 12
    123a:	0e 94 66 10 	call	0x20cc	; 0x20cc <uxListRemove>
		}
		portENABLE_INTERRUPTS();
    123e:	78 94       	sei

		( void ) uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
    1240:	89 81       	ldd	r24, Y+1	; 0x01
    1242:	9a 81       	ldd	r25, Y+2	; 0x02
    1244:	02 96       	adiw	r24, 0x02	; 2
    1246:	0e 94 66 10 	call	0x20cc	; 0x20cc <uxListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );
    124a:	e9 81       	ldd	r30, Y+1	; 0x01
    124c:	fa 81       	ldd	r31, Y+2	; 0x02
    124e:	96 89       	ldd	r25, Z+22	; 0x16
    1250:	80 91 0e 02 	lds	r24, 0x020E
    1254:	89 17       	cp	r24, r25
    1256:	28 f4       	brcc	.+10     	; 0x1262 <prvCheckPendingReadyList+0x4c>
    1258:	e9 81       	ldd	r30, Y+1	; 0x01
    125a:	fa 81       	ldd	r31, Y+2	; 0x02
    125c:	86 89       	ldd	r24, Z+22	; 0x16
    125e:	80 93 0e 02 	sts	0x020E, r24
    1262:	e9 81       	ldd	r30, Y+1	; 0x01
    1264:	fa 81       	ldd	r31, Y+2	; 0x02
    1266:	86 89       	ldd	r24, Z+22	; 0x16
    1268:	28 2f       	mov	r18, r24
    126a:	30 e0       	ldi	r19, 0x00	; 0
    126c:	c9 01       	movw	r24, r18
    126e:	88 0f       	add	r24, r24
    1270:	99 1f       	adc	r25, r25
    1272:	88 0f       	add	r24, r24
    1274:	99 1f       	adc	r25, r25
    1276:	88 0f       	add	r24, r24
    1278:	99 1f       	adc	r25, r25
    127a:	82 0f       	add	r24, r18
    127c:	93 1f       	adc	r25, r19
    127e:	ac 01       	movw	r20, r24
    1280:	4b 5e       	subi	r20, 0xEB	; 235
    1282:	5d 4f       	sbci	r21, 0xFD	; 253
    1284:	89 81       	ldd	r24, Y+1	; 0x01
    1286:	9a 81       	ldd	r25, Y+2	; 0x02
    1288:	9c 01       	movw	r18, r24
    128a:	2e 5f       	subi	r18, 0xFE	; 254
    128c:	3f 4f       	sbci	r19, 0xFF	; 255
    128e:	ca 01       	movw	r24, r20
    1290:	b9 01       	movw	r22, r18
    1292:	0e 94 b6 0f 	call	0x1f6c	; 0x1f6c <vListInsertEnd>
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
    1296:	80 91 3d 02 	lds	r24, 0x023D
    129a:	88 23       	and	r24, r24
    129c:	09 f0       	breq	.+2      	; 0x12a0 <prvCheckPendingReadyList+0x8a>
    129e:	c1 cf       	rjmp	.-126    	; 0x1222 <prvCheckPendingReadyList+0xc>
		portENABLE_INTERRUPTS();

		( void ) uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );
	}
}
    12a0:	0f 90       	pop	r0
    12a2:	0f 90       	pop	r0
    12a4:	cf 91       	pop	r28
    12a6:	df 91       	pop	r29
    12a8:	08 95       	ret

000012aa <prvCheckDelayedList>:
/*-----------------------------------------------------------*/

static void prvCheckDelayedList( void )
{
    12aa:	df 93       	push	r29
    12ac:	cf 93       	push	r28
    12ae:	00 d0       	rcall	.+0      	; 0x12b0 <prvCheckDelayedList+0x6>
    12b0:	00 d0       	rcall	.+0      	; 0x12b2 <prvCheckDelayedList+0x8>
    12b2:	cd b7       	in	r28, 0x3d	; 61
    12b4:	de b7       	in	r29, 0x3e	; 62
CRCB_t *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
    12b6:	0e 94 f6 1e 	call	0x3dec	; 0x3dec <xTaskGetTickCount>
    12ba:	20 91 11 02 	lds	r18, 0x0211
    12be:	30 91 12 02 	lds	r19, 0x0212
    12c2:	82 1b       	sub	r24, r18
    12c4:	93 0b       	sbc	r25, r19
    12c6:	90 93 14 02 	sts	0x0214, r25
    12ca:	80 93 13 02 	sts	0x0213, r24
    12ce:	85 c0       	rjmp	.+266    	; 0x13da <prvCheckDelayedList+0x130>
	while( xPassedTicks )
	{
		xCoRoutineTickCount++;
    12d0:	80 91 0f 02 	lds	r24, 0x020F
    12d4:	90 91 10 02 	lds	r25, 0x0210
    12d8:	01 96       	adiw	r24, 0x01	; 1
    12da:	90 93 10 02 	sts	0x0210, r25
    12de:	80 93 0f 02 	sts	0x020F, r24
		xPassedTicks--;
    12e2:	80 91 13 02 	lds	r24, 0x0213
    12e6:	90 91 14 02 	lds	r25, 0x0214
    12ea:	01 97       	sbiw	r24, 0x01	; 1
    12ec:	90 93 14 02 	sts	0x0214, r25
    12f0:	80 93 13 02 	sts	0x0213, r24

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
    12f4:	80 91 0f 02 	lds	r24, 0x020F
    12f8:	90 91 10 02 	lds	r25, 0x0210
    12fc:	00 97       	sbiw	r24, 0x00	; 0
    12fe:	09 f0       	breq	.+2      	; 0x1302 <prvCheckDelayedList+0x58>
    1300:	64 c0       	rjmp	.+200    	; 0x13ca <prvCheckDelayedList+0x120>
		{
			List_t * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
    1302:	80 91 39 02 	lds	r24, 0x0239
    1306:	90 91 3a 02 	lds	r25, 0x023A
    130a:	9a 83       	std	Y+2, r25	; 0x02
    130c:	89 83       	std	Y+1, r24	; 0x01
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
    130e:	80 91 3b 02 	lds	r24, 0x023B
    1312:	90 91 3c 02 	lds	r25, 0x023C
    1316:	90 93 3a 02 	sts	0x023A, r25
    131a:	80 93 39 02 	sts	0x0239, r24
			pxOverflowDelayedCoRoutineList = pxTemp;
    131e:	89 81       	ldd	r24, Y+1	; 0x01
    1320:	9a 81       	ldd	r25, Y+2	; 0x02
    1322:	90 93 3c 02 	sts	0x023C, r25
    1326:	80 93 3b 02 	sts	0x023B, r24
    132a:	4f c0       	rjmp	.+158    	; 0x13ca <prvCheckDelayedList+0x120>
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
		{
			pxCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
    132c:	e0 91 39 02 	lds	r30, 0x0239
    1330:	f0 91 3a 02 	lds	r31, 0x023A
    1334:	05 80       	ldd	r0, Z+5	; 0x05
    1336:	f6 81       	ldd	r31, Z+6	; 0x06
    1338:	e0 2d       	mov	r30, r0
    133a:	86 81       	ldd	r24, Z+6	; 0x06
    133c:	97 81       	ldd	r25, Z+7	; 0x07
    133e:	9c 83       	std	Y+4, r25	; 0x04
    1340:	8b 83       	std	Y+3, r24	; 0x03

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )
    1342:	eb 81       	ldd	r30, Y+3	; 0x03
    1344:	fc 81       	ldd	r31, Y+4	; 0x04
    1346:	22 81       	ldd	r18, Z+2	; 0x02
    1348:	33 81       	ldd	r19, Z+3	; 0x03
    134a:	80 91 0f 02 	lds	r24, 0x020F
    134e:	90 91 10 02 	lds	r25, 0x0210
    1352:	82 17       	cp	r24, r18
    1354:	93 07       	cpc	r25, r19
    1356:	08 f4       	brcc	.+2      	; 0x135a <prvCheckDelayedList+0xb0>
    1358:	40 c0       	rjmp	.+128    	; 0x13da <prvCheckDelayedList+0x130>
			{
				/* Timeout not yet expired. */
				break;
			}

			portDISABLE_INTERRUPTS();
    135a:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				( void ) uxListRemove( &( pxCRCB->xGenericListItem ) );
    135c:	8b 81       	ldd	r24, Y+3	; 0x03
    135e:	9c 81       	ldd	r25, Y+4	; 0x04
    1360:	02 96       	adiw	r24, 0x02	; 2
    1362:	0e 94 66 10 	call	0x20cc	; 0x20cc <uxListRemove>

				/* Is the co-routine waiting on an event also? */
				if( pxCRCB->xEventListItem.pvContainer )
    1366:	eb 81       	ldd	r30, Y+3	; 0x03
    1368:	fc 81       	ldd	r31, Y+4	; 0x04
    136a:	84 89       	ldd	r24, Z+20	; 0x14
    136c:	95 89       	ldd	r25, Z+21	; 0x15
    136e:	00 97       	sbiw	r24, 0x00	; 0
    1370:	29 f0       	breq	.+10     	; 0x137c <prvCheckDelayedList+0xd2>
				{
					( void ) uxListRemove( &( pxCRCB->xEventListItem ) );
    1372:	8b 81       	ldd	r24, Y+3	; 0x03
    1374:	9c 81       	ldd	r25, Y+4	; 0x04
    1376:	0c 96       	adiw	r24, 0x0c	; 12
    1378:	0e 94 66 10 	call	0x20cc	; 0x20cc <uxListRemove>
				}
			}
			portENABLE_INTERRUPTS();
    137c:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );
    137e:	eb 81       	ldd	r30, Y+3	; 0x03
    1380:	fc 81       	ldd	r31, Y+4	; 0x04
    1382:	96 89       	ldd	r25, Z+22	; 0x16
    1384:	80 91 0e 02 	lds	r24, 0x020E
    1388:	89 17       	cp	r24, r25
    138a:	28 f4       	brcc	.+10     	; 0x1396 <prvCheckDelayedList+0xec>
    138c:	eb 81       	ldd	r30, Y+3	; 0x03
    138e:	fc 81       	ldd	r31, Y+4	; 0x04
    1390:	86 89       	ldd	r24, Z+22	; 0x16
    1392:	80 93 0e 02 	sts	0x020E, r24
    1396:	eb 81       	ldd	r30, Y+3	; 0x03
    1398:	fc 81       	ldd	r31, Y+4	; 0x04
    139a:	86 89       	ldd	r24, Z+22	; 0x16
    139c:	28 2f       	mov	r18, r24
    139e:	30 e0       	ldi	r19, 0x00	; 0
    13a0:	c9 01       	movw	r24, r18
    13a2:	88 0f       	add	r24, r24
    13a4:	99 1f       	adc	r25, r25
    13a6:	88 0f       	add	r24, r24
    13a8:	99 1f       	adc	r25, r25
    13aa:	88 0f       	add	r24, r24
    13ac:	99 1f       	adc	r25, r25
    13ae:	82 0f       	add	r24, r18
    13b0:	93 1f       	adc	r25, r19
    13b2:	ac 01       	movw	r20, r24
    13b4:	4b 5e       	subi	r20, 0xEB	; 235
    13b6:	5d 4f       	sbci	r21, 0xFD	; 253
    13b8:	8b 81       	ldd	r24, Y+3	; 0x03
    13ba:	9c 81       	ldd	r25, Y+4	; 0x04
    13bc:	9c 01       	movw	r18, r24
    13be:	2e 5f       	subi	r18, 0xFE	; 254
    13c0:	3f 4f       	sbci	r19, 0xFF	; 255
    13c2:	ca 01       	movw	r24, r20
    13c4:	b9 01       	movw	r22, r18
    13c6:	0e 94 b6 0f 	call	0x1f6c	; 0x1f6c <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
    13ca:	e0 91 39 02 	lds	r30, 0x0239
    13ce:	f0 91 3a 02 	lds	r31, 0x023A
    13d2:	80 81       	ld	r24, Z
    13d4:	88 23       	and	r24, r24
    13d6:	09 f0       	breq	.+2      	; 0x13da <prvCheckDelayedList+0x130>
    13d8:	a9 cf       	rjmp	.-174    	; 0x132c <prvCheckDelayedList+0x82>
static void prvCheckDelayedList( void )
{
CRCB_t *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
    13da:	80 91 13 02 	lds	r24, 0x0213
    13de:	90 91 14 02 	lds	r25, 0x0214
    13e2:	00 97       	sbiw	r24, 0x00	; 0
    13e4:	09 f0       	breq	.+2      	; 0x13e8 <prvCheckDelayedList+0x13e>
    13e6:	74 cf       	rjmp	.-280    	; 0x12d0 <prvCheckDelayedList+0x26>

			prvAddCoRoutineToReadyQueue( pxCRCB );
		}
	}

	xLastTickCount = xCoRoutineTickCount;
    13e8:	80 91 0f 02 	lds	r24, 0x020F
    13ec:	90 91 10 02 	lds	r25, 0x0210
    13f0:	90 93 12 02 	sts	0x0212, r25
    13f4:	80 93 11 02 	sts	0x0211, r24
}
    13f8:	0f 90       	pop	r0
    13fa:	0f 90       	pop	r0
    13fc:	0f 90       	pop	r0
    13fe:	0f 90       	pop	r0
    1400:	cf 91       	pop	r28
    1402:	df 91       	pop	r29
    1404:	08 95       	ret

00001406 <vCoRoutineSchedule>:
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
    1406:	df 93       	push	r29
    1408:	cf 93       	push	r28
    140a:	00 d0       	rcall	.+0      	; 0x140c <vCoRoutineSchedule+0x6>
    140c:	cd b7       	in	r28, 0x3d	; 61
    140e:	de b7       	in	r29, 0x3e	; 62
	/* See if any co-routines readied by events need moving to the ready lists. */
	prvCheckPendingReadyList();
    1410:	0e 94 0b 09 	call	0x1216	; 0x1216 <prvCheckPendingReadyList>

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();
    1414:	0e 94 55 09 	call	0x12aa	; 0x12aa <prvCheckDelayedList>
    1418:	0a c0       	rjmp	.+20     	; 0x142e <vCoRoutineSchedule+0x28>

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
	{
		if( uxTopCoRoutineReadyPriority == 0 )
    141a:	80 91 0e 02 	lds	r24, 0x020E
    141e:	88 23       	and	r24, r24
    1420:	09 f4       	brne	.+2      	; 0x1424 <vCoRoutineSchedule+0x1e>
    1422:	66 c0       	rjmp	.+204    	; 0x14f0 <vCoRoutineSchedule+0xea>
		{
			/* No more co-routines to check. */
			return;
		}
		--uxTopCoRoutineReadyPriority;
    1424:	80 91 0e 02 	lds	r24, 0x020E
    1428:	81 50       	subi	r24, 0x01	; 1
    142a:	80 93 0e 02 	sts	0x020E, r24

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    142e:	80 91 0e 02 	lds	r24, 0x020E
    1432:	28 2f       	mov	r18, r24
    1434:	30 e0       	ldi	r19, 0x00	; 0
    1436:	c9 01       	movw	r24, r18
    1438:	88 0f       	add	r24, r24
    143a:	99 1f       	adc	r25, r25
    143c:	88 0f       	add	r24, r24
    143e:	99 1f       	adc	r25, r25
    1440:	88 0f       	add	r24, r24
    1442:	99 1f       	adc	r25, r25
    1444:	82 0f       	add	r24, r18
    1446:	93 1f       	adc	r25, r19
    1448:	fc 01       	movw	r30, r24
    144a:	eb 5e       	subi	r30, 0xEB	; 235
    144c:	fd 4f       	sbci	r31, 0xFD	; 253
    144e:	80 81       	ld	r24, Z
    1450:	88 23       	and	r24, r24
    1452:	19 f3       	breq	.-58     	; 0x141a <vCoRoutineSchedule+0x14>
		--uxTopCoRoutineReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
    1454:	80 91 0e 02 	lds	r24, 0x020E
    1458:	28 2f       	mov	r18, r24
    145a:	30 e0       	ldi	r19, 0x00	; 0
    145c:	c9 01       	movw	r24, r18
    145e:	88 0f       	add	r24, r24
    1460:	99 1f       	adc	r25, r25
    1462:	88 0f       	add	r24, r24
    1464:	99 1f       	adc	r25, r25
    1466:	88 0f       	add	r24, r24
    1468:	99 1f       	adc	r25, r25
    146a:	82 0f       	add	r24, r18
    146c:	93 1f       	adc	r25, r19
    146e:	8b 5e       	subi	r24, 0xEB	; 235
    1470:	9d 4f       	sbci	r25, 0xFD	; 253
    1472:	9a 83       	std	Y+2, r25	; 0x02
    1474:	89 83       	std	Y+1, r24	; 0x01
    1476:	e9 81       	ldd	r30, Y+1	; 0x01
    1478:	fa 81       	ldd	r31, Y+2	; 0x02
    147a:	01 80       	ldd	r0, Z+1	; 0x01
    147c:	f2 81       	ldd	r31, Z+2	; 0x02
    147e:	e0 2d       	mov	r30, r0
    1480:	82 81       	ldd	r24, Z+2	; 0x02
    1482:	93 81       	ldd	r25, Z+3	; 0x03
    1484:	e9 81       	ldd	r30, Y+1	; 0x01
    1486:	fa 81       	ldd	r31, Y+2	; 0x02
    1488:	92 83       	std	Z+2, r25	; 0x02
    148a:	81 83       	std	Z+1, r24	; 0x01
    148c:	e9 81       	ldd	r30, Y+1	; 0x01
    148e:	fa 81       	ldd	r31, Y+2	; 0x02
    1490:	21 81       	ldd	r18, Z+1	; 0x01
    1492:	32 81       	ldd	r19, Z+2	; 0x02
    1494:	89 81       	ldd	r24, Y+1	; 0x01
    1496:	9a 81       	ldd	r25, Y+2	; 0x02
    1498:	03 96       	adiw	r24, 0x03	; 3
    149a:	28 17       	cp	r18, r24
    149c:	39 07       	cpc	r19, r25
    149e:	59 f4       	brne	.+22     	; 0x14b6 <vCoRoutineSchedule+0xb0>
    14a0:	e9 81       	ldd	r30, Y+1	; 0x01
    14a2:	fa 81       	ldd	r31, Y+2	; 0x02
    14a4:	01 80       	ldd	r0, Z+1	; 0x01
    14a6:	f2 81       	ldd	r31, Z+2	; 0x02
    14a8:	e0 2d       	mov	r30, r0
    14aa:	82 81       	ldd	r24, Z+2	; 0x02
    14ac:	93 81       	ldd	r25, Z+3	; 0x03
    14ae:	e9 81       	ldd	r30, Y+1	; 0x01
    14b0:	fa 81       	ldd	r31, Y+2	; 0x02
    14b2:	92 83       	std	Z+2, r25	; 0x02
    14b4:	81 83       	std	Z+1, r24	; 0x01
    14b6:	e9 81       	ldd	r30, Y+1	; 0x01
    14b8:	fa 81       	ldd	r31, Y+2	; 0x02
    14ba:	01 80       	ldd	r0, Z+1	; 0x01
    14bc:	f2 81       	ldd	r31, Z+2	; 0x02
    14be:	e0 2d       	mov	r30, r0
    14c0:	86 81       	ldd	r24, Z+6	; 0x06
    14c2:	97 81       	ldd	r25, Z+7	; 0x07
    14c4:	90 93 0d 02 	sts	0x020D, r25
    14c8:	80 93 0c 02 	sts	0x020C, r24

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
    14cc:	e0 91 0c 02 	lds	r30, 0x020C
    14d0:	f0 91 0d 02 	lds	r31, 0x020D
    14d4:	40 81       	ld	r20, Z
    14d6:	51 81       	ldd	r21, Z+1	; 0x01
    14d8:	80 91 0c 02 	lds	r24, 0x020C
    14dc:	90 91 0d 02 	lds	r25, 0x020D
    14e0:	e0 91 0c 02 	lds	r30, 0x020C
    14e4:	f0 91 0d 02 	lds	r31, 0x020D
    14e8:	27 89       	ldd	r18, Z+23	; 0x17
    14ea:	62 2f       	mov	r22, r18
    14ec:	fa 01       	movw	r30, r20
    14ee:	09 95       	icall

	return;
}
    14f0:	0f 90       	pop	r0
    14f2:	0f 90       	pop	r0
    14f4:	cf 91       	pop	r28
    14f6:	df 91       	pop	r29
    14f8:	08 95       	ret

000014fa <prvInitialiseCoRoutineLists>:
/*-----------------------------------------------------------*/

static void prvInitialiseCoRoutineLists( void )
{
    14fa:	df 93       	push	r29
    14fc:	cf 93       	push	r28
    14fe:	0f 92       	push	r0
    1500:	cd b7       	in	r28, 0x3d	; 61
    1502:	de b7       	in	r29, 0x3e	; 62
UBaseType_t uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
    1504:	19 82       	std	Y+1, r1	; 0x01
    1506:	13 c0       	rjmp	.+38     	; 0x152e <prvInitialiseCoRoutineLists+0x34>
	{
		vListInitialise( ( List_t * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
    1508:	89 81       	ldd	r24, Y+1	; 0x01
    150a:	28 2f       	mov	r18, r24
    150c:	30 e0       	ldi	r19, 0x00	; 0
    150e:	c9 01       	movw	r24, r18
    1510:	88 0f       	add	r24, r24
    1512:	99 1f       	adc	r25, r25
    1514:	88 0f       	add	r24, r24
    1516:	99 1f       	adc	r25, r25
    1518:	88 0f       	add	r24, r24
    151a:	99 1f       	adc	r25, r25
    151c:	82 0f       	add	r24, r18
    151e:	93 1f       	adc	r25, r19
    1520:	8b 5e       	subi	r24, 0xEB	; 235
    1522:	9d 4f       	sbci	r25, 0xFD	; 253
    1524:	0e 94 7c 0f 	call	0x1ef8	; 0x1ef8 <vListInitialise>

static void prvInitialiseCoRoutineLists( void )
{
UBaseType_t uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
    1528:	89 81       	ldd	r24, Y+1	; 0x01
    152a:	8f 5f       	subi	r24, 0xFF	; 255
    152c:	89 83       	std	Y+1, r24	; 0x01
    152e:	89 81       	ldd	r24, Y+1	; 0x01
    1530:	82 30       	cpi	r24, 0x02	; 2
    1532:	50 f3       	brcs	.-44     	; 0x1508 <prvInitialiseCoRoutineLists+0xe>
	{
		vListInitialise( ( List_t * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
	}

	vListInitialise( ( List_t * ) &xDelayedCoRoutineList1 );
    1534:	87 e2       	ldi	r24, 0x27	; 39
    1536:	92 e0       	ldi	r25, 0x02	; 2
    1538:	0e 94 7c 0f 	call	0x1ef8	; 0x1ef8 <vListInitialise>
	vListInitialise( ( List_t * ) &xDelayedCoRoutineList2 );
    153c:	80 e3       	ldi	r24, 0x30	; 48
    153e:	92 e0       	ldi	r25, 0x02	; 2
    1540:	0e 94 7c 0f 	call	0x1ef8	; 0x1ef8 <vListInitialise>
	vListInitialise( ( List_t * ) &xPendingReadyCoRoutineList );
    1544:	8d e3       	ldi	r24, 0x3D	; 61
    1546:	92 e0       	ldi	r25, 0x02	; 2
    1548:	0e 94 7c 0f 	call	0x1ef8	; 0x1ef8 <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
    154c:	87 e2       	ldi	r24, 0x27	; 39
    154e:	92 e0       	ldi	r25, 0x02	; 2
    1550:	90 93 3a 02 	sts	0x023A, r25
    1554:	80 93 39 02 	sts	0x0239, r24
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
    1558:	80 e3       	ldi	r24, 0x30	; 48
    155a:	92 e0       	ldi	r25, 0x02	; 2
    155c:	90 93 3c 02 	sts	0x023C, r25
    1560:	80 93 3b 02 	sts	0x023B, r24
}
    1564:	0f 90       	pop	r0
    1566:	cf 91       	pop	r28
    1568:	df 91       	pop	r29
    156a:	08 95       	ret

0000156c <xCoRoutineRemoveFromEventList>:
/*-----------------------------------------------------------*/

BaseType_t xCoRoutineRemoveFromEventList( const List_t *pxEventList )
{
    156c:	df 93       	push	r29
    156e:	cf 93       	push	r28
    1570:	00 d0       	rcall	.+0      	; 0x1572 <xCoRoutineRemoveFromEventList+0x6>
    1572:	00 d0       	rcall	.+0      	; 0x1574 <xCoRoutineRemoveFromEventList+0x8>
    1574:	0f 92       	push	r0
    1576:	cd b7       	in	r28, 0x3d	; 61
    1578:	de b7       	in	r29, 0x3e	; 62
    157a:	9d 83       	std	Y+5, r25	; 0x05
    157c:	8c 83       	std	Y+4, r24	; 0x04
BaseType_t xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list.  This function assumes that a
	check has already been made to ensure pxEventList is not empty. */
	pxUnblockedCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    157e:	ec 81       	ldd	r30, Y+4	; 0x04
    1580:	fd 81       	ldd	r31, Y+5	; 0x05
    1582:	05 80       	ldd	r0, Z+5	; 0x05
    1584:	f6 81       	ldd	r31, Z+6	; 0x06
    1586:	e0 2d       	mov	r30, r0
    1588:	86 81       	ldd	r24, Z+6	; 0x06
    158a:	97 81       	ldd	r25, Z+7	; 0x07
    158c:	9b 83       	std	Y+3, r25	; 0x03
    158e:	8a 83       	std	Y+2, r24	; 0x02
	( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    1590:	8a 81       	ldd	r24, Y+2	; 0x02
    1592:	9b 81       	ldd	r25, Y+3	; 0x03
    1594:	0c 96       	adiw	r24, 0x0c	; 12
    1596:	0e 94 66 10 	call	0x20cc	; 0x20cc <uxListRemove>
	vListInsertEnd( ( List_t * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
    159a:	8a 81       	ldd	r24, Y+2	; 0x02
    159c:	9b 81       	ldd	r25, Y+3	; 0x03
    159e:	9c 01       	movw	r18, r24
    15a0:	24 5f       	subi	r18, 0xF4	; 244
    15a2:	3f 4f       	sbci	r19, 0xFF	; 255
    15a4:	8d e3       	ldi	r24, 0x3D	; 61
    15a6:	92 e0       	ldi	r25, 0x02	; 2
    15a8:	b9 01       	movw	r22, r18
    15aa:	0e 94 b6 0f 	call	0x1f6c	; 0x1f6c <vListInsertEnd>

	if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
    15ae:	ea 81       	ldd	r30, Y+2	; 0x02
    15b0:	fb 81       	ldd	r31, Y+3	; 0x03
    15b2:	96 89       	ldd	r25, Z+22	; 0x16
    15b4:	e0 91 0c 02 	lds	r30, 0x020C
    15b8:	f0 91 0d 02 	lds	r31, 0x020D
    15bc:	86 89       	ldd	r24, Z+22	; 0x16
    15be:	98 17       	cp	r25, r24
    15c0:	18 f0       	brcs	.+6      	; 0x15c8 <xCoRoutineRemoveFromEventList+0x5c>
	{
		xReturn = pdTRUE;
    15c2:	81 e0       	ldi	r24, 0x01	; 1
    15c4:	89 83       	std	Y+1, r24	; 0x01
    15c6:	01 c0       	rjmp	.+2      	; 0x15ca <xCoRoutineRemoveFromEventList+0x5e>
	}
	else
	{
		xReturn = pdFALSE;
    15c8:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    15ca:	89 81       	ldd	r24, Y+1	; 0x01
}
    15cc:	0f 90       	pop	r0
    15ce:	0f 90       	pop	r0
    15d0:	0f 90       	pop	r0
    15d2:	0f 90       	pop	r0
    15d4:	0f 90       	pop	r0
    15d6:	cf 91       	pop	r28
    15d8:	df 91       	pop	r29
    15da:	08 95       	ret

000015dc <xEventGroupCreate>:
static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits );

/*-----------------------------------------------------------*/

EventGroupHandle_t xEventGroupCreate( void )
{
    15dc:	df 93       	push	r29
    15de:	cf 93       	push	r28
    15e0:	00 d0       	rcall	.+0      	; 0x15e2 <xEventGroupCreate+0x6>
    15e2:	cd b7       	in	r28, 0x3d	; 61
    15e4:	de b7       	in	r29, 0x3e	; 62
EventGroup_t *pxEventBits;

	pxEventBits = pvPortMalloc( sizeof( EventGroup_t ) );
    15e6:	8b e0       	ldi	r24, 0x0B	; 11
    15e8:	90 e0       	ldi	r25, 0x00	; 0
    15ea:	0e 94 2e 0e 	call	0x1c5c	; 0x1c5c <pvPortMalloc>
    15ee:	9a 83       	std	Y+2, r25	; 0x02
    15f0:	89 83       	std	Y+1, r24	; 0x01
	if( pxEventBits != NULL )
    15f2:	89 81       	ldd	r24, Y+1	; 0x01
    15f4:	9a 81       	ldd	r25, Y+2	; 0x02
    15f6:	00 97       	sbiw	r24, 0x00	; 0
    15f8:	49 f0       	breq	.+18     	; 0x160c <xEventGroupCreate+0x30>
	{
		pxEventBits->uxEventBits = 0;
    15fa:	e9 81       	ldd	r30, Y+1	; 0x01
    15fc:	fa 81       	ldd	r31, Y+2	; 0x02
    15fe:	11 82       	std	Z+1, r1	; 0x01
    1600:	10 82       	st	Z, r1
		vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );
    1602:	89 81       	ldd	r24, Y+1	; 0x01
    1604:	9a 81       	ldd	r25, Y+2	; 0x02
    1606:	02 96       	adiw	r24, 0x02	; 2
    1608:	0e 94 7c 0f 	call	0x1ef8	; 0x1ef8 <vListInitialise>
	else
	{
		traceEVENT_GROUP_CREATE_FAILED();
	}

	return ( EventGroupHandle_t ) pxEventBits;
    160c:	89 81       	ldd	r24, Y+1	; 0x01
    160e:	9a 81       	ldd	r25, Y+2	; 0x02
}
    1610:	0f 90       	pop	r0
    1612:	0f 90       	pop	r0
    1614:	cf 91       	pop	r28
    1616:	df 91       	pop	r29
    1618:	08 95       	ret

0000161a <xEventGroupSync>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSync( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, const EventBits_t uxBitsToWaitFor, TickType_t xTicksToWait )
{
    161a:	df 93       	push	r29
    161c:	cf 93       	push	r28
    161e:	cd b7       	in	r28, 0x3d	; 61
    1620:	de b7       	in	r29, 0x3e	; 62
    1622:	60 97       	sbiw	r28, 0x10	; 16
    1624:	0f b6       	in	r0, 0x3f	; 63
    1626:	f8 94       	cli
    1628:	de bf       	out	0x3e, r29	; 62
    162a:	0f be       	out	0x3f, r0	; 63
    162c:	cd bf       	out	0x3d, r28	; 61
    162e:	9a 87       	std	Y+10, r25	; 0x0a
    1630:	89 87       	std	Y+9, r24	; 0x09
    1632:	7c 87       	std	Y+12, r23	; 0x0c
    1634:	6b 87       	std	Y+11, r22	; 0x0b
    1636:	5e 87       	std	Y+14, r21	; 0x0e
    1638:	4d 87       	std	Y+13, r20	; 0x0d
    163a:	38 8b       	std	Y+16, r19	; 0x10
    163c:	2f 87       	std	Y+15, r18	; 0x0f
EventBits_t uxOriginalBitValue, uxReturn;
EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
    163e:	89 85       	ldd	r24, Y+9	; 0x09
    1640:	9a 85       	ldd	r25, Y+10	; 0x0a
    1642:	9c 83       	std	Y+4, r25	; 0x04
    1644:	8b 83       	std	Y+3, r24	; 0x03
BaseType_t xAlreadyYielded;
BaseType_t xTimeoutOccurred = pdFALSE;
    1646:	19 82       	std	Y+1, r1	; 0x01
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
	}
	#endif

	vTaskSuspendAll();
    1648:	0e 94 60 1e 	call	0x3cc0	; 0x3cc0 <vTaskSuspendAll>
	{
		uxOriginalBitValue = pxEventBits->uxEventBits;
    164c:	eb 81       	ldd	r30, Y+3	; 0x03
    164e:	fc 81       	ldd	r31, Y+4	; 0x04
    1650:	80 81       	ld	r24, Z
    1652:	91 81       	ldd	r25, Z+1	; 0x01
    1654:	98 87       	std	Y+8, r25	; 0x08
    1656:	8f 83       	std	Y+7, r24	; 0x07

		( void ) xEventGroupSetBits( xEventGroup, uxBitsToSet );
    1658:	89 85       	ldd	r24, Y+9	; 0x09
    165a:	9a 85       	ldd	r25, Y+10	; 0x0a
    165c:	2b 85       	ldd	r18, Y+11	; 0x0b
    165e:	3c 85       	ldd	r19, Y+12	; 0x0c
    1660:	b9 01       	movw	r22, r18
    1662:	0e 94 df 0c 	call	0x19be	; 0x19be <xEventGroupSetBits>

		if( ( ( uxOriginalBitValue | uxBitsToSet ) & uxBitsToWaitFor ) == uxBitsToWaitFor )
    1666:	2f 81       	ldd	r18, Y+7	; 0x07
    1668:	38 85       	ldd	r19, Y+8	; 0x08
    166a:	8b 85       	ldd	r24, Y+11	; 0x0b
    166c:	9c 85       	ldd	r25, Y+12	; 0x0c
    166e:	28 2b       	or	r18, r24
    1670:	39 2b       	or	r19, r25
    1672:	8d 85       	ldd	r24, Y+13	; 0x0d
    1674:	9e 85       	ldd	r25, Y+14	; 0x0e
    1676:	28 23       	and	r18, r24
    1678:	39 23       	and	r19, r25
    167a:	8d 85       	ldd	r24, Y+13	; 0x0d
    167c:	9e 85       	ldd	r25, Y+14	; 0x0e
    167e:	28 17       	cp	r18, r24
    1680:	39 07       	cpc	r19, r25
    1682:	c9 f4       	brne	.+50     	; 0x16b6 <xEventGroupSync+0x9c>
		{
			/* All the rendezvous bits are now set - no need to block. */
			uxReturn = ( uxOriginalBitValue | uxBitsToSet );
    1684:	2f 81       	ldd	r18, Y+7	; 0x07
    1686:	38 85       	ldd	r19, Y+8	; 0x08
    1688:	8b 85       	ldd	r24, Y+11	; 0x0b
    168a:	9c 85       	ldd	r25, Y+12	; 0x0c
    168c:	82 2b       	or	r24, r18
    168e:	93 2b       	or	r25, r19
    1690:	9e 83       	std	Y+6, r25	; 0x06
    1692:	8d 83       	std	Y+5, r24	; 0x05

			/* Rendezvous always clear the bits.  They will have been cleared
			already unless this is the only task in the rendezvous. */
			pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    1694:	eb 81       	ldd	r30, Y+3	; 0x03
    1696:	fc 81       	ldd	r31, Y+4	; 0x04
    1698:	20 81       	ld	r18, Z
    169a:	31 81       	ldd	r19, Z+1	; 0x01
    169c:	8d 85       	ldd	r24, Y+13	; 0x0d
    169e:	9e 85       	ldd	r25, Y+14	; 0x0e
    16a0:	80 95       	com	r24
    16a2:	90 95       	com	r25
    16a4:	82 23       	and	r24, r18
    16a6:	93 23       	and	r25, r19
    16a8:	eb 81       	ldd	r30, Y+3	; 0x03
    16aa:	fc 81       	ldd	r31, Y+4	; 0x04
    16ac:	91 83       	std	Z+1, r25	; 0x01
    16ae:	80 83       	st	Z, r24

			xTicksToWait = 0;
    16b0:	18 8a       	std	Y+16, r1	; 0x10
    16b2:	1f 86       	std	Y+15, r1	; 0x0f
    16b4:	1c c0       	rjmp	.+56     	; 0x16ee <xEventGroupSync+0xd4>
		}
		else
		{
			if( xTicksToWait != ( TickType_t ) 0 )
    16b6:	8f 85       	ldd	r24, Y+15	; 0x0f
    16b8:	98 89       	ldd	r25, Y+16	; 0x10
    16ba:	00 97       	sbiw	r24, 0x00	; 0
    16bc:	91 f0       	breq	.+36     	; 0x16e2 <xEventGroupSync+0xc8>
				traceEVENT_GROUP_SYNC_BLOCK( xEventGroup, uxBitsToSet, uxBitsToWaitFor );

				/* Store the bits that the calling task is waiting for in the
				task's event list item so the kernel knows when a match is
				found.  Then enter the blocked state. */
				vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | eventCLEAR_EVENTS_ON_EXIT_BIT | eventWAIT_FOR_ALL_BITS ), xTicksToWait );
    16be:	8b 81       	ldd	r24, Y+3	; 0x03
    16c0:	9c 81       	ldd	r25, Y+4	; 0x04
    16c2:	bc 01       	movw	r22, r24
    16c4:	6e 5f       	subi	r22, 0xFE	; 254
    16c6:	7f 4f       	sbci	r23, 0xFF	; 255
    16c8:	8d 85       	ldd	r24, Y+13	; 0x0d
    16ca:	9e 85       	ldd	r25, Y+14	; 0x0e
    16cc:	9c 01       	movw	r18, r24
    16ce:	35 60       	ori	r19, 0x05	; 5
    16d0:	4f 85       	ldd	r20, Y+15	; 0x0f
    16d2:	58 89       	ldd	r21, Y+16	; 0x10
    16d4:	cb 01       	movw	r24, r22
    16d6:	b9 01       	movw	r22, r18
    16d8:	0e 94 b0 20 	call	0x4160	; 0x4160 <vTaskPlaceOnUnorderedEventList>

				/* This assignment is obsolete as uxReturn will get set after
				the task unblocks, but some compilers mistakenly generate a
				warning about uxReturn being returned without being set if the
				assignment is omitted. */
				uxReturn = 0;
    16dc:	1e 82       	std	Y+6, r1	; 0x06
    16de:	1d 82       	std	Y+5, r1	; 0x05
    16e0:	06 c0       	rjmp	.+12     	; 0x16ee <xEventGroupSync+0xd4>
			}
			else
			{
				/* The rendezvous bits were not set, but no block time was
				specified - just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
    16e2:	eb 81       	ldd	r30, Y+3	; 0x03
    16e4:	fc 81       	ldd	r31, Y+4	; 0x04
    16e6:	80 81       	ld	r24, Z
    16e8:	91 81       	ldd	r25, Z+1	; 0x01
    16ea:	9e 83       	std	Y+6, r25	; 0x06
    16ec:	8d 83       	std	Y+5, r24	; 0x05
			}
		}
	}
	xAlreadyYielded = xTaskResumeAll();
    16ee:	0e 94 6c 1e 	call	0x3cd8	; 0x3cd8 <xTaskResumeAll>
    16f2:	8a 83       	std	Y+2, r24	; 0x02

	if( xTicksToWait != ( TickType_t ) 0 )
    16f4:	8f 85       	ldd	r24, Y+15	; 0x0f
    16f6:	98 89       	ldd	r25, Y+16	; 0x10
    16f8:	00 97       	sbiw	r24, 0x00	; 0
    16fa:	09 f4       	brne	.+2      	; 0x16fe <xEventGroupSync+0xe4>
    16fc:	3a c0       	rjmp	.+116    	; 0x1772 <xEventGroupSync+0x158>
	{
		if( xAlreadyYielded == pdFALSE )
    16fe:	8a 81       	ldd	r24, Y+2	; 0x02
    1700:	88 23       	and	r24, r24
    1702:	11 f4       	brne	.+4      	; 0x1708 <xEventGroupSync+0xee>
		{
			portYIELD_WITHIN_API();
    1704:	0e 94 71 12 	call	0x24e2	; 0x24e2 <vPortYield>

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
    1708:	0e 94 2c 25 	call	0x4a58	; 0x4a58 <uxTaskResetEventItemValue>
    170c:	9e 83       	std	Y+6, r25	; 0x06
    170e:	8d 83       	std	Y+5, r24	; 0x05

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
    1710:	8d 81       	ldd	r24, Y+5	; 0x05
    1712:	9e 81       	ldd	r25, Y+6	; 0x06
    1714:	80 70       	andi	r24, 0x00	; 0
    1716:	92 70       	andi	r25, 0x02	; 2
    1718:	00 97       	sbiw	r24, 0x00	; 0
    171a:	31 f5       	brne	.+76     	; 0x1768 <xEventGroupSync+0x14e>
		{
			/* The task timed out, just return the current event bit value. */
			taskENTER_CRITICAL();
    171c:	0f b6       	in	r0, 0x3f	; 63
    171e:	f8 94       	cli
    1720:	0f 92       	push	r0
			{
				uxReturn = pxEventBits->uxEventBits;
    1722:	eb 81       	ldd	r30, Y+3	; 0x03
    1724:	fc 81       	ldd	r31, Y+4	; 0x04
    1726:	80 81       	ld	r24, Z
    1728:	91 81       	ldd	r25, Z+1	; 0x01
    172a:	9e 83       	std	Y+6, r25	; 0x06
    172c:	8d 83       	std	Y+5, r24	; 0x05

				/* Although the task got here because it timed out before the
				bits it was waiting for were set, it is possible that since it
				unblocked another task has set the bits.  If this is the case
				then it needs to clear the bits before exiting. */
				if( ( uxReturn & uxBitsToWaitFor ) == uxBitsToWaitFor )
    172e:	2d 81       	ldd	r18, Y+5	; 0x05
    1730:	3e 81       	ldd	r19, Y+6	; 0x06
    1732:	8d 85       	ldd	r24, Y+13	; 0x0d
    1734:	9e 85       	ldd	r25, Y+14	; 0x0e
    1736:	28 23       	and	r18, r24
    1738:	39 23       	and	r19, r25
    173a:	8d 85       	ldd	r24, Y+13	; 0x0d
    173c:	9e 85       	ldd	r25, Y+14	; 0x0e
    173e:	28 17       	cp	r18, r24
    1740:	39 07       	cpc	r19, r25
    1742:	71 f4       	brne	.+28     	; 0x1760 <xEventGroupSync+0x146>
				{
					pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    1744:	eb 81       	ldd	r30, Y+3	; 0x03
    1746:	fc 81       	ldd	r31, Y+4	; 0x04
    1748:	20 81       	ld	r18, Z
    174a:	31 81       	ldd	r19, Z+1	; 0x01
    174c:	8d 85       	ldd	r24, Y+13	; 0x0d
    174e:	9e 85       	ldd	r25, Y+14	; 0x0e
    1750:	80 95       	com	r24
    1752:	90 95       	com	r25
    1754:	82 23       	and	r24, r18
    1756:	93 23       	and	r25, r19
    1758:	eb 81       	ldd	r30, Y+3	; 0x03
    175a:	fc 81       	ldd	r31, Y+4	; 0x04
    175c:	91 83       	std	Z+1, r25	; 0x01
    175e:	80 83       	st	Z, r24
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
    1760:	0f 90       	pop	r0
    1762:	0f be       	out	0x3f, r0	; 63

			xTimeoutOccurred = pdTRUE;
    1764:	81 e0       	ldi	r24, 0x01	; 1
    1766:	89 83       	std	Y+1, r24	; 0x01
			/* The task unblocked because the bits were set. */
		}

		/* Control bits might be set as the task had blocked should not be
		returned. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
    1768:	8d 81       	ldd	r24, Y+5	; 0x05
    176a:	9e 81       	ldd	r25, Y+6	; 0x06
    176c:	90 70       	andi	r25, 0x00	; 0
    176e:	9e 83       	std	Y+6, r25	; 0x06
    1770:	8d 83       	std	Y+5, r24	; 0x05
	}

	traceEVENT_GROUP_SYNC_END( xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTimeoutOccurred );

	return uxReturn;
    1772:	8d 81       	ldd	r24, Y+5	; 0x05
    1774:	9e 81       	ldd	r25, Y+6	; 0x06
}
    1776:	60 96       	adiw	r28, 0x10	; 16
    1778:	0f b6       	in	r0, 0x3f	; 63
    177a:	f8 94       	cli
    177c:	de bf       	out	0x3e, r29	; 62
    177e:	0f be       	out	0x3f, r0	; 63
    1780:	cd bf       	out	0x3d, r28	; 61
    1782:	cf 91       	pop	r28
    1784:	df 91       	pop	r29
    1786:	08 95       	ret

00001788 <xEventGroupWaitBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait )
{
    1788:	0f 93       	push	r16
    178a:	1f 93       	push	r17
    178c:	df 93       	push	r29
    178e:	cf 93       	push	r28
    1790:	cd b7       	in	r28, 0x3d	; 61
    1792:	de b7       	in	r29, 0x3e	; 62
    1794:	63 97       	sbiw	r28, 0x13	; 19
    1796:	0f b6       	in	r0, 0x3f	; 63
    1798:	f8 94       	cli
    179a:	de bf       	out	0x3e, r29	; 62
    179c:	0f be       	out	0x3f, r0	; 63
    179e:	cd bf       	out	0x3d, r28	; 61
    17a0:	9d 87       	std	Y+13, r25	; 0x0d
    17a2:	8c 87       	std	Y+12, r24	; 0x0c
    17a4:	7f 87       	std	Y+15, r23	; 0x0f
    17a6:	6e 87       	std	Y+14, r22	; 0x0e
    17a8:	48 8b       	std	Y+16, r20	; 0x10
    17aa:	29 8b       	std	Y+17, r18	; 0x11
    17ac:	1b 8b       	std	Y+19, r17	; 0x13
    17ae:	0a 8b       	std	Y+18, r16	; 0x12
EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
    17b0:	8c 85       	ldd	r24, Y+12	; 0x0c
    17b2:	9d 85       	ldd	r25, Y+13	; 0x0d
    17b4:	9b 87       	std	Y+11, r25	; 0x0b
    17b6:	8a 87       	std	Y+10, r24	; 0x0a
EventBits_t uxReturn, uxControlBits = 0;
    17b8:	1f 82       	std	Y+7, r1	; 0x07
    17ba:	1e 82       	std	Y+6, r1	; 0x06
BaseType_t xWaitConditionMet, xAlreadyYielded;
BaseType_t xTimeoutOccurred = pdFALSE;
    17bc:	1b 82       	std	Y+3, r1	; 0x03
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
	}
	#endif

	vTaskSuspendAll();
    17be:	0e 94 60 1e 	call	0x3cc0	; 0x3cc0 <vTaskSuspendAll>
	{
		const EventBits_t uxCurrentEventBits = pxEventBits->uxEventBits;
    17c2:	ea 85       	ldd	r30, Y+10	; 0x0a
    17c4:	fb 85       	ldd	r31, Y+11	; 0x0b
    17c6:	80 81       	ld	r24, Z
    17c8:	91 81       	ldd	r25, Z+1	; 0x01
    17ca:	9a 83       	std	Y+2, r25	; 0x02
    17cc:	89 83       	std	Y+1, r24	; 0x01

		/* Check to see if the wait condition is already met or not. */
		xWaitConditionMet = prvTestWaitCondition( uxCurrentEventBits, uxBitsToWaitFor, xWaitForAllBits );
    17ce:	89 81       	ldd	r24, Y+1	; 0x01
    17d0:	9a 81       	ldd	r25, Y+2	; 0x02
    17d2:	2e 85       	ldd	r18, Y+14	; 0x0e
    17d4:	3f 85       	ldd	r19, Y+15	; 0x0f
    17d6:	b9 01       	movw	r22, r18
    17d8:	49 89       	ldd	r20, Y+17	; 0x11
    17da:	0e 94 fc 0d 	call	0x1bf8	; 0x1bf8 <prvTestWaitCondition>
    17de:	8d 83       	std	Y+5, r24	; 0x05

		if( xWaitConditionMet != pdFALSE )
    17e0:	8d 81       	ldd	r24, Y+5	; 0x05
    17e2:	88 23       	and	r24, r24
    17e4:	c1 f0       	breq	.+48     	; 0x1816 <xEventGroupWaitBits+0x8e>
		{
			/* The wait condition has already been met so there is no need to
			block. */
			uxReturn = uxCurrentEventBits;
    17e6:	89 81       	ldd	r24, Y+1	; 0x01
    17e8:	9a 81       	ldd	r25, Y+2	; 0x02
    17ea:	99 87       	std	Y+9, r25	; 0x09
    17ec:	88 87       	std	Y+8, r24	; 0x08
			xTicksToWait = ( TickType_t ) 0;
    17ee:	1b 8a       	std	Y+19, r1	; 0x13
    17f0:	1a 8a       	std	Y+18, r1	; 0x12

			/* Clear the wait bits if requested to do so. */
			if( xClearOnExit != pdFALSE )
    17f2:	88 89       	ldd	r24, Y+16	; 0x10
    17f4:	88 23       	and	r24, r24
    17f6:	d9 f1       	breq	.+118    	; 0x186e <xEventGroupWaitBits+0xe6>
			{
				pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    17f8:	ea 85       	ldd	r30, Y+10	; 0x0a
    17fa:	fb 85       	ldd	r31, Y+11	; 0x0b
    17fc:	20 81       	ld	r18, Z
    17fe:	31 81       	ldd	r19, Z+1	; 0x01
    1800:	8e 85       	ldd	r24, Y+14	; 0x0e
    1802:	9f 85       	ldd	r25, Y+15	; 0x0f
    1804:	80 95       	com	r24
    1806:	90 95       	com	r25
    1808:	82 23       	and	r24, r18
    180a:	93 23       	and	r25, r19
    180c:	ea 85       	ldd	r30, Y+10	; 0x0a
    180e:	fb 85       	ldd	r31, Y+11	; 0x0b
    1810:	91 83       	std	Z+1, r25	; 0x01
    1812:	80 83       	st	Z, r24
    1814:	2c c0       	rjmp	.+88     	; 0x186e <xEventGroupWaitBits+0xe6>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		else if( xTicksToWait == ( TickType_t ) 0 )
    1816:	8a 89       	ldd	r24, Y+18	; 0x12
    1818:	9b 89       	ldd	r25, Y+19	; 0x13
    181a:	00 97       	sbiw	r24, 0x00	; 0
    181c:	29 f4       	brne	.+10     	; 0x1828 <xEventGroupWaitBits+0xa0>
		{
			/* The wait condition has not been met, but no block time was
			specified, so just return the current value. */
			uxReturn = uxCurrentEventBits;
    181e:	89 81       	ldd	r24, Y+1	; 0x01
    1820:	9a 81       	ldd	r25, Y+2	; 0x02
    1822:	99 87       	std	Y+9, r25	; 0x09
    1824:	88 87       	std	Y+8, r24	; 0x08
    1826:	23 c0       	rjmp	.+70     	; 0x186e <xEventGroupWaitBits+0xe6>
		{
			/* The task is going to block to wait for its required bits to be
			set.  uxControlBits are used to remember the specified behaviour of
			this call to xEventGroupWaitBits() - for use when the event bits
			unblock the task. */
			if( xClearOnExit != pdFALSE )
    1828:	88 89       	ldd	r24, Y+16	; 0x10
    182a:	88 23       	and	r24, r24
    182c:	29 f0       	breq	.+10     	; 0x1838 <xEventGroupWaitBits+0xb0>
			{
				uxControlBits |= eventCLEAR_EVENTS_ON_EXIT_BIT;
    182e:	8e 81       	ldd	r24, Y+6	; 0x06
    1830:	9f 81       	ldd	r25, Y+7	; 0x07
    1832:	91 60       	ori	r25, 0x01	; 1
    1834:	9f 83       	std	Y+7, r25	; 0x07
    1836:	8e 83       	std	Y+6, r24	; 0x06
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			if( xWaitForAllBits != pdFALSE )
    1838:	89 89       	ldd	r24, Y+17	; 0x11
    183a:	88 23       	and	r24, r24
    183c:	29 f0       	breq	.+10     	; 0x1848 <xEventGroupWaitBits+0xc0>
			{
				uxControlBits |= eventWAIT_FOR_ALL_BITS;
    183e:	8e 81       	ldd	r24, Y+6	; 0x06
    1840:	9f 81       	ldd	r25, Y+7	; 0x07
    1842:	94 60       	ori	r25, 0x04	; 4
    1844:	9f 83       	std	Y+7, r25	; 0x07
    1846:	8e 83       	std	Y+6, r24	; 0x06
			}

			/* Store the bits that the calling task is waiting for in the
			task's event list item so the kernel knows when a match is
			found.  Then enter the blocked state. */
			vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | uxControlBits ), xTicksToWait );
    1848:	8a 85       	ldd	r24, Y+10	; 0x0a
    184a:	9b 85       	ldd	r25, Y+11	; 0x0b
    184c:	bc 01       	movw	r22, r24
    184e:	6e 5f       	subi	r22, 0xFE	; 254
    1850:	7f 4f       	sbci	r23, 0xFF	; 255
    1852:	2e 85       	ldd	r18, Y+14	; 0x0e
    1854:	3f 85       	ldd	r19, Y+15	; 0x0f
    1856:	8e 81       	ldd	r24, Y+6	; 0x06
    1858:	9f 81       	ldd	r25, Y+7	; 0x07
    185a:	28 2b       	or	r18, r24
    185c:	39 2b       	or	r19, r25
    185e:	4a 89       	ldd	r20, Y+18	; 0x12
    1860:	5b 89       	ldd	r21, Y+19	; 0x13
    1862:	cb 01       	movw	r24, r22
    1864:	b9 01       	movw	r22, r18
    1866:	0e 94 b0 20 	call	0x4160	; 0x4160 <vTaskPlaceOnUnorderedEventList>

			/* This is obsolete as it will get set after the task unblocks, but
			some compilers mistakenly generate a warning about the variable
			being returned without being set if it is not done. */
			uxReturn = 0;
    186a:	19 86       	std	Y+9, r1	; 0x09
    186c:	18 86       	std	Y+8, r1	; 0x08

			traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
		}
	}
	xAlreadyYielded = xTaskResumeAll();
    186e:	0e 94 6c 1e 	call	0x3cd8	; 0x3cd8 <xTaskResumeAll>
    1872:	8c 83       	std	Y+4, r24	; 0x04

	if( xTicksToWait != ( TickType_t ) 0 )
    1874:	8a 89       	ldd	r24, Y+18	; 0x12
    1876:	9b 89       	ldd	r25, Y+19	; 0x13
    1878:	00 97       	sbiw	r24, 0x00	; 0
    187a:	09 f4       	brne	.+2      	; 0x187e <xEventGroupWaitBits+0xf6>
    187c:	3b c0       	rjmp	.+118    	; 0x18f4 <xEventGroupWaitBits+0x16c>
	{
		if( xAlreadyYielded == pdFALSE )
    187e:	8c 81       	ldd	r24, Y+4	; 0x04
    1880:	88 23       	and	r24, r24
    1882:	11 f4       	brne	.+4      	; 0x1888 <xEventGroupWaitBits+0x100>
		{
			portYIELD_WITHIN_API();
    1884:	0e 94 71 12 	call	0x24e2	; 0x24e2 <vPortYield>

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
    1888:	0e 94 2c 25 	call	0x4a58	; 0x4a58 <uxTaskResetEventItemValue>
    188c:	99 87       	std	Y+9, r25	; 0x09
    188e:	88 87       	std	Y+8, r24	; 0x08

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
    1890:	88 85       	ldd	r24, Y+8	; 0x08
    1892:	99 85       	ldd	r25, Y+9	; 0x09
    1894:	80 70       	andi	r24, 0x00	; 0
    1896:	92 70       	andi	r25, 0x02	; 2
    1898:	00 97       	sbiw	r24, 0x00	; 0
    189a:	39 f5       	brne	.+78     	; 0x18ea <xEventGroupWaitBits+0x162>
		{
			taskENTER_CRITICAL();
    189c:	0f b6       	in	r0, 0x3f	; 63
    189e:	f8 94       	cli
    18a0:	0f 92       	push	r0
			{
				/* The task timed out, just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
    18a2:	ea 85       	ldd	r30, Y+10	; 0x0a
    18a4:	fb 85       	ldd	r31, Y+11	; 0x0b
    18a6:	80 81       	ld	r24, Z
    18a8:	91 81       	ldd	r25, Z+1	; 0x01
    18aa:	99 87       	std	Y+9, r25	; 0x09
    18ac:	88 87       	std	Y+8, r24	; 0x08

				/* It is possible that the event bits were updated between this
				task leaving the Blocked state and running again. */
				if( prvTestWaitCondition( uxReturn, uxBitsToWaitFor, xWaitForAllBits ) != pdFALSE )
    18ae:	88 85       	ldd	r24, Y+8	; 0x08
    18b0:	99 85       	ldd	r25, Y+9	; 0x09
    18b2:	2e 85       	ldd	r18, Y+14	; 0x0e
    18b4:	3f 85       	ldd	r19, Y+15	; 0x0f
    18b6:	b9 01       	movw	r22, r18
    18b8:	49 89       	ldd	r20, Y+17	; 0x11
    18ba:	0e 94 fc 0d 	call	0x1bf8	; 0x1bf8 <prvTestWaitCondition>
    18be:	88 23       	and	r24, r24
    18c0:	89 f0       	breq	.+34     	; 0x18e4 <xEventGroupWaitBits+0x15c>
				{
					if( xClearOnExit != pdFALSE )
    18c2:	88 89       	ldd	r24, Y+16	; 0x10
    18c4:	88 23       	and	r24, r24
    18c6:	71 f0       	breq	.+28     	; 0x18e4 <xEventGroupWaitBits+0x15c>
					{
						pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    18c8:	ea 85       	ldd	r30, Y+10	; 0x0a
    18ca:	fb 85       	ldd	r31, Y+11	; 0x0b
    18cc:	20 81       	ld	r18, Z
    18ce:	31 81       	ldd	r19, Z+1	; 0x01
    18d0:	8e 85       	ldd	r24, Y+14	; 0x0e
    18d2:	9f 85       	ldd	r25, Y+15	; 0x0f
    18d4:	80 95       	com	r24
    18d6:	90 95       	com	r25
    18d8:	82 23       	and	r24, r18
    18da:	93 23       	and	r25, r19
    18dc:	ea 85       	ldd	r30, Y+10	; 0x0a
    18de:	fb 85       	ldd	r31, Y+11	; 0x0b
    18e0:	91 83       	std	Z+1, r25	; 0x01
    18e2:	80 83       	st	Z, r24
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
    18e4:	0f 90       	pop	r0
    18e6:	0f be       	out	0x3f, r0	; 63

			/* Prevent compiler warnings when trace macros are not used. */
			xTimeoutOccurred = pdFALSE;
    18e8:	1b 82       	std	Y+3, r1	; 0x03
		{
			/* The task unblocked because the bits were set. */
		}

		/* The task blocked so control bits may have been set. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
    18ea:	88 85       	ldd	r24, Y+8	; 0x08
    18ec:	99 85       	ldd	r25, Y+9	; 0x09
    18ee:	90 70       	andi	r25, 0x00	; 0
    18f0:	99 87       	std	Y+9, r25	; 0x09
    18f2:	88 87       	std	Y+8, r24	; 0x08
	}
	traceEVENT_GROUP_WAIT_BITS_END( xEventGroup, uxBitsToWaitFor, xTimeoutOccurred );

	return uxReturn;
    18f4:	88 85       	ldd	r24, Y+8	; 0x08
    18f6:	99 85       	ldd	r25, Y+9	; 0x09
}
    18f8:	63 96       	adiw	r28, 0x13	; 19
    18fa:	0f b6       	in	r0, 0x3f	; 63
    18fc:	f8 94       	cli
    18fe:	de bf       	out	0x3e, r29	; 62
    1900:	0f be       	out	0x3f, r0	; 63
    1902:	cd bf       	out	0x3d, r28	; 61
    1904:	cf 91       	pop	r28
    1906:	df 91       	pop	r29
    1908:	1f 91       	pop	r17
    190a:	0f 91       	pop	r16
    190c:	08 95       	ret

0000190e <xEventGroupClearBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear )
{
    190e:	df 93       	push	r29
    1910:	cf 93       	push	r28
    1912:	cd b7       	in	r28, 0x3d	; 61
    1914:	de b7       	in	r29, 0x3e	; 62
    1916:	28 97       	sbiw	r28, 0x08	; 8
    1918:	0f b6       	in	r0, 0x3f	; 63
    191a:	f8 94       	cli
    191c:	de bf       	out	0x3e, r29	; 62
    191e:	0f be       	out	0x3f, r0	; 63
    1920:	cd bf       	out	0x3d, r28	; 61
    1922:	9e 83       	std	Y+6, r25	; 0x06
    1924:	8d 83       	std	Y+5, r24	; 0x05
    1926:	78 87       	std	Y+8, r23	; 0x08
    1928:	6f 83       	std	Y+7, r22	; 0x07
EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
    192a:	8d 81       	ldd	r24, Y+5	; 0x05
    192c:	9e 81       	ldd	r25, Y+6	; 0x06
    192e:	9c 83       	std	Y+4, r25	; 0x04
    1930:	8b 83       	std	Y+3, r24	; 0x03

	/* Check the user is not attempting to clear the bits used by the kernel
	itself. */
	configASSERT( ( uxBitsToClear & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

	taskENTER_CRITICAL();
    1932:	0f b6       	in	r0, 0x3f	; 63
    1934:	f8 94       	cli
    1936:	0f 92       	push	r0
	{
		traceEVENT_GROUP_CLEAR_BITS( xEventGroup, uxBitsToClear );

		/* The value returned is the event group value prior to the bits being
		cleared. */
		uxReturn = pxEventBits->uxEventBits;
    1938:	eb 81       	ldd	r30, Y+3	; 0x03
    193a:	fc 81       	ldd	r31, Y+4	; 0x04
    193c:	80 81       	ld	r24, Z
    193e:	91 81       	ldd	r25, Z+1	; 0x01
    1940:	9a 83       	std	Y+2, r25	; 0x02
    1942:	89 83       	std	Y+1, r24	; 0x01

		/* Clear the bits. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
    1944:	eb 81       	ldd	r30, Y+3	; 0x03
    1946:	fc 81       	ldd	r31, Y+4	; 0x04
    1948:	20 81       	ld	r18, Z
    194a:	31 81       	ldd	r19, Z+1	; 0x01
    194c:	8f 81       	ldd	r24, Y+7	; 0x07
    194e:	98 85       	ldd	r25, Y+8	; 0x08
    1950:	80 95       	com	r24
    1952:	90 95       	com	r25
    1954:	82 23       	and	r24, r18
    1956:	93 23       	and	r25, r19
    1958:	eb 81       	ldd	r30, Y+3	; 0x03
    195a:	fc 81       	ldd	r31, Y+4	; 0x04
    195c:	91 83       	std	Z+1, r25	; 0x01
    195e:	80 83       	st	Z, r24
	}
	taskEXIT_CRITICAL();
    1960:	0f 90       	pop	r0
    1962:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    1964:	89 81       	ldd	r24, Y+1	; 0x01
    1966:	9a 81       	ldd	r25, Y+2	; 0x02
}
    1968:	28 96       	adiw	r28, 0x08	; 8
    196a:	0f b6       	in	r0, 0x3f	; 63
    196c:	f8 94       	cli
    196e:	de bf       	out	0x3e, r29	; 62
    1970:	0f be       	out	0x3f, r0	; 63
    1972:	cd bf       	out	0x3d, r28	; 61
    1974:	cf 91       	pop	r28
    1976:	df 91       	pop	r29
    1978:	08 95       	ret

0000197a <xEventGroupGetBitsFromISR>:

#endif
/*-----------------------------------------------------------*/

EventBits_t xEventGroupGetBitsFromISR( EventGroupHandle_t xEventGroup )
{
    197a:	df 93       	push	r29
    197c:	cf 93       	push	r28
    197e:	cd b7       	in	r28, 0x3d	; 61
    1980:	de b7       	in	r29, 0x3e	; 62
    1982:	27 97       	sbiw	r28, 0x07	; 7
    1984:	0f b6       	in	r0, 0x3f	; 63
    1986:	f8 94       	cli
    1988:	de bf       	out	0x3e, r29	; 62
    198a:	0f be       	out	0x3f, r0	; 63
    198c:	cd bf       	out	0x3d, r28	; 61
    198e:	9f 83       	std	Y+7, r25	; 0x07
    1990:	8e 83       	std	Y+6, r24	; 0x06
UBaseType_t uxSavedInterruptStatus;
EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
    1992:	8e 81       	ldd	r24, Y+6	; 0x06
    1994:	9f 81       	ldd	r25, Y+7	; 0x07
    1996:	9c 83       	std	Y+4, r25	; 0x04
    1998:	8b 83       	std	Y+3, r24	; 0x03
EventBits_t uxReturn;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    199a:	1d 82       	std	Y+5, r1	; 0x05
	{
		uxReturn = pxEventBits->uxEventBits;
    199c:	eb 81       	ldd	r30, Y+3	; 0x03
    199e:	fc 81       	ldd	r31, Y+4	; 0x04
    19a0:	80 81       	ld	r24, Z
    19a2:	91 81       	ldd	r25, Z+1	; 0x01
    19a4:	9a 83       	std	Y+2, r25	; 0x02
    19a6:	89 83       	std	Y+1, r24	; 0x01
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return uxReturn;
    19a8:	89 81       	ldd	r24, Y+1	; 0x01
    19aa:	9a 81       	ldd	r25, Y+2	; 0x02
}
    19ac:	27 96       	adiw	r28, 0x07	; 7
    19ae:	0f b6       	in	r0, 0x3f	; 63
    19b0:	f8 94       	cli
    19b2:	de bf       	out	0x3e, r29	; 62
    19b4:	0f be       	out	0x3f, r0	; 63
    19b6:	cd bf       	out	0x3d, r28	; 61
    19b8:	cf 91       	pop	r28
    19ba:	df 91       	pop	r29
    19bc:	08 95       	ret

000019be <xEventGroupSetBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )
{
    19be:	df 93       	push	r29
    19c0:	cf 93       	push	r28
    19c2:	cd b7       	in	r28, 0x3d	; 61
    19c4:	de b7       	in	r29, 0x3e	; 62
    19c6:	65 97       	sbiw	r28, 0x15	; 21
    19c8:	0f b6       	in	r0, 0x3f	; 63
    19ca:	f8 94       	cli
    19cc:	de bf       	out	0x3e, r29	; 62
    19ce:	0f be       	out	0x3f, r0	; 63
    19d0:	cd bf       	out	0x3d, r28	; 61
    19d2:	9b 8b       	std	Y+19, r25	; 0x13
    19d4:	8a 8b       	std	Y+18, r24	; 0x12
    19d6:	7d 8b       	std	Y+21, r23	; 0x15
    19d8:	6c 8b       	std	Y+20, r22	; 0x14
ListItem_t *pxListItem, *pxNext;
ListItem_t const *pxListEnd;
List_t *pxList;
EventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
    19da:	19 86       	std	Y+9, r1	; 0x09
    19dc:	18 86       	std	Y+8, r1	; 0x08
EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
    19de:	8a 89       	ldd	r24, Y+18	; 0x12
    19e0:	9b 89       	ldd	r25, Y+19	; 0x13
    19e2:	9b 83       	std	Y+3, r25	; 0x03
    19e4:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xMatchFound = pdFALSE;
    19e6:	19 82       	std	Y+1, r1	; 0x01

	/* Check the user is not attempting to set the bits used by the kernel
	itself. */
	configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

	pxList = &( pxEventBits->xTasksWaitingForBits );
    19e8:	8a 81       	ldd	r24, Y+2	; 0x02
    19ea:	9b 81       	ldd	r25, Y+3	; 0x03
    19ec:	02 96       	adiw	r24, 0x02	; 2
    19ee:	9b 87       	std	Y+11, r25	; 0x0b
    19f0:	8a 87       	std	Y+10, r24	; 0x0a
	pxListEnd = listGET_END_MARKER( pxList ); /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    19f2:	8a 85       	ldd	r24, Y+10	; 0x0a
    19f4:	9b 85       	ldd	r25, Y+11	; 0x0b
    19f6:	03 96       	adiw	r24, 0x03	; 3
    19f8:	9d 87       	std	Y+13, r25	; 0x0d
    19fa:	8c 87       	std	Y+12, r24	; 0x0c
	vTaskSuspendAll();
    19fc:	0e 94 60 1e 	call	0x3cc0	; 0x3cc0 <vTaskSuspendAll>
	{
		traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet );

		pxListItem = listGET_HEAD_ENTRY( pxList );
    1a00:	ea 85       	ldd	r30, Y+10	; 0x0a
    1a02:	fb 85       	ldd	r31, Y+11	; 0x0b
    1a04:	85 81       	ldd	r24, Z+5	; 0x05
    1a06:	96 81       	ldd	r25, Z+6	; 0x06
    1a08:	99 8b       	std	Y+17, r25	; 0x11
    1a0a:	88 8b       	std	Y+16, r24	; 0x10

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;
    1a0c:	ea 81       	ldd	r30, Y+2	; 0x02
    1a0e:	fb 81       	ldd	r31, Y+3	; 0x03
    1a10:	20 81       	ld	r18, Z
    1a12:	31 81       	ldd	r19, Z+1	; 0x01
    1a14:	8c 89       	ldd	r24, Y+20	; 0x14
    1a16:	9d 89       	ldd	r25, Y+21	; 0x15
    1a18:	82 2b       	or	r24, r18
    1a1a:	93 2b       	or	r25, r19
    1a1c:	ea 81       	ldd	r30, Y+2	; 0x02
    1a1e:	fb 81       	ldd	r31, Y+3	; 0x03
    1a20:	91 83       	std	Z+1, r25	; 0x01
    1a22:	80 83       	st	Z, r24
    1a24:	59 c0       	rjmp	.+178    	; 0x1ad8 <xEventGroupSetBits+0x11a>

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
		{
			pxNext = listGET_NEXT( pxListItem );
    1a26:	e8 89       	ldd	r30, Y+16	; 0x10
    1a28:	f9 89       	ldd	r31, Y+17	; 0x11
    1a2a:	82 81       	ldd	r24, Z+2	; 0x02
    1a2c:	93 81       	ldd	r25, Z+3	; 0x03
    1a2e:	9f 87       	std	Y+15, r25	; 0x0f
    1a30:	8e 87       	std	Y+14, r24	; 0x0e
			uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
    1a32:	e8 89       	ldd	r30, Y+16	; 0x10
    1a34:	f9 89       	ldd	r31, Y+17	; 0x11
    1a36:	80 81       	ld	r24, Z
    1a38:	91 81       	ldd	r25, Z+1	; 0x01
    1a3a:	9f 83       	std	Y+7, r25	; 0x07
    1a3c:	8e 83       	std	Y+6, r24	; 0x06
			xMatchFound = pdFALSE;
    1a3e:	19 82       	std	Y+1, r1	; 0x01

			/* Split the bits waited for from the control bits. */
			uxControlBits = uxBitsWaitedFor & eventEVENT_BITS_CONTROL_BYTES;
    1a40:	8e 81       	ldd	r24, Y+6	; 0x06
    1a42:	9f 81       	ldd	r25, Y+7	; 0x07
    1a44:	80 70       	andi	r24, 0x00	; 0
    1a46:	9d 83       	std	Y+5, r25	; 0x05
    1a48:	8c 83       	std	Y+4, r24	; 0x04
			uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;
    1a4a:	8e 81       	ldd	r24, Y+6	; 0x06
    1a4c:	9f 81       	ldd	r25, Y+7	; 0x07
    1a4e:	90 70       	andi	r25, 0x00	; 0
    1a50:	9f 83       	std	Y+7, r25	; 0x07
    1a52:	8e 83       	std	Y+6, r24	; 0x06

			if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
    1a54:	8c 81       	ldd	r24, Y+4	; 0x04
    1a56:	9d 81       	ldd	r25, Y+5	; 0x05
    1a58:	80 70       	andi	r24, 0x00	; 0
    1a5a:	94 70       	andi	r25, 0x04	; 4
    1a5c:	00 97       	sbiw	r24, 0x00	; 0
    1a5e:	69 f4       	brne	.+26     	; 0x1a7a <xEventGroupSetBits+0xbc>
			{
				/* Just looking for single bit being set. */
				if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
    1a60:	ea 81       	ldd	r30, Y+2	; 0x02
    1a62:	fb 81       	ldd	r31, Y+3	; 0x03
    1a64:	20 81       	ld	r18, Z
    1a66:	31 81       	ldd	r19, Z+1	; 0x01
    1a68:	8e 81       	ldd	r24, Y+6	; 0x06
    1a6a:	9f 81       	ldd	r25, Y+7	; 0x07
    1a6c:	82 23       	and	r24, r18
    1a6e:	93 23       	and	r25, r19
    1a70:	00 97       	sbiw	r24, 0x00	; 0
    1a72:	91 f0       	breq	.+36     	; 0x1a98 <xEventGroupSetBits+0xda>
				{
					xMatchFound = pdTRUE;
    1a74:	81 e0       	ldi	r24, 0x01	; 1
    1a76:	89 83       	std	Y+1, r24	; 0x01
    1a78:	0f c0       	rjmp	.+30     	; 0x1a98 <xEventGroupSetBits+0xda>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
    1a7a:	ea 81       	ldd	r30, Y+2	; 0x02
    1a7c:	fb 81       	ldd	r31, Y+3	; 0x03
    1a7e:	20 81       	ld	r18, Z
    1a80:	31 81       	ldd	r19, Z+1	; 0x01
    1a82:	8e 81       	ldd	r24, Y+6	; 0x06
    1a84:	9f 81       	ldd	r25, Y+7	; 0x07
    1a86:	28 23       	and	r18, r24
    1a88:	39 23       	and	r19, r25
    1a8a:	8e 81       	ldd	r24, Y+6	; 0x06
    1a8c:	9f 81       	ldd	r25, Y+7	; 0x07
    1a8e:	28 17       	cp	r18, r24
    1a90:	39 07       	cpc	r19, r25
    1a92:	11 f4       	brne	.+4      	; 0x1a98 <xEventGroupSetBits+0xda>
			{
				/* All bits are set. */
				xMatchFound = pdTRUE;
    1a94:	81 e0       	ldi	r24, 0x01	; 1
    1a96:	89 83       	std	Y+1, r24	; 0x01
			else
			{
				/* Need all bits to be set, but not all the bits were set. */
			}

			if( xMatchFound != pdFALSE )
    1a98:	89 81       	ldd	r24, Y+1	; 0x01
    1a9a:	88 23       	and	r24, r24
    1a9c:	c9 f0       	breq	.+50     	; 0x1ad0 <xEventGroupSetBits+0x112>
			{
				/* The bits match.  Should the bits be cleared on exit? */
				if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
    1a9e:	8c 81       	ldd	r24, Y+4	; 0x04
    1aa0:	9d 81       	ldd	r25, Y+5	; 0x05
    1aa2:	80 70       	andi	r24, 0x00	; 0
    1aa4:	91 70       	andi	r25, 0x01	; 1
    1aa6:	00 97       	sbiw	r24, 0x00	; 0
    1aa8:	41 f0       	breq	.+16     	; 0x1aba <xEventGroupSetBits+0xfc>
				{
					uxBitsToClear |= uxBitsWaitedFor;
    1aaa:	88 85       	ldd	r24, Y+8	; 0x08
    1aac:	99 85       	ldd	r25, Y+9	; 0x09
    1aae:	2e 81       	ldd	r18, Y+6	; 0x06
    1ab0:	3f 81       	ldd	r19, Y+7	; 0x07
    1ab2:	82 2b       	or	r24, r18
    1ab4:	93 2b       	or	r25, r19
    1ab6:	99 87       	std	Y+9, r25	; 0x09
    1ab8:	88 87       	std	Y+8, r24	; 0x08
				/* Store the actual event flag value in the task's event list
				item before removing the task from the event list.  The
				eventUNBLOCKED_DUE_TO_BIT_SET bit is set so the task knows
				that is was unblocked due to its required bits matching, rather
				than because it timed out. */
				( void ) xTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
    1aba:	ea 81       	ldd	r30, Y+2	; 0x02
    1abc:	fb 81       	ldd	r31, Y+3	; 0x03
    1abe:	80 81       	ld	r24, Z
    1ac0:	91 81       	ldd	r25, Z+1	; 0x01
    1ac2:	9c 01       	movw	r18, r24
    1ac4:	32 60       	ori	r19, 0x02	; 2
    1ac6:	88 89       	ldd	r24, Y+16	; 0x10
    1ac8:	99 89       	ldd	r25, Y+17	; 0x11
    1aca:	b9 01       	movw	r22, r18
    1acc:	0e 94 5e 21 	call	0x42bc	; 0x42bc <xTaskRemoveFromUnorderedEventList>
			}

			/* Move onto the next list item.  Note pxListItem->pxNext is not
			used here as the list item may have been removed from the event list
			and inserted into the ready/pending reading list. */
			pxListItem = pxNext;
    1ad0:	8e 85       	ldd	r24, Y+14	; 0x0e
    1ad2:	9f 85       	ldd	r25, Y+15	; 0x0f
    1ad4:	99 8b       	std	Y+17, r25	; 0x11
    1ad6:	88 8b       	std	Y+16, r24	; 0x10

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
    1ad8:	28 89       	ldd	r18, Y+16	; 0x10
    1ada:	39 89       	ldd	r19, Y+17	; 0x11
    1adc:	8c 85       	ldd	r24, Y+12	; 0x0c
    1ade:	9d 85       	ldd	r25, Y+13	; 0x0d
    1ae0:	28 17       	cp	r18, r24
    1ae2:	39 07       	cpc	r19, r25
    1ae4:	09 f0       	breq	.+2      	; 0x1ae8 <xEventGroupSetBits+0x12a>
    1ae6:	9f cf       	rjmp	.-194    	; 0x1a26 <xEventGroupSetBits+0x68>
			pxListItem = pxNext;
		}

		/* Clear any bits that matched when the eventCLEAR_EVENTS_ON_EXIT_BIT
		bit was set in the control word. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
    1ae8:	ea 81       	ldd	r30, Y+2	; 0x02
    1aea:	fb 81       	ldd	r31, Y+3	; 0x03
    1aec:	20 81       	ld	r18, Z
    1aee:	31 81       	ldd	r19, Z+1	; 0x01
    1af0:	88 85       	ldd	r24, Y+8	; 0x08
    1af2:	99 85       	ldd	r25, Y+9	; 0x09
    1af4:	80 95       	com	r24
    1af6:	90 95       	com	r25
    1af8:	82 23       	and	r24, r18
    1afa:	93 23       	and	r25, r19
    1afc:	ea 81       	ldd	r30, Y+2	; 0x02
    1afe:	fb 81       	ldd	r31, Y+3	; 0x03
    1b00:	91 83       	std	Z+1, r25	; 0x01
    1b02:	80 83       	st	Z, r24
	}
	( void ) xTaskResumeAll();
    1b04:	0e 94 6c 1e 	call	0x3cd8	; 0x3cd8 <xTaskResumeAll>

	return pxEventBits->uxEventBits;
    1b08:	ea 81       	ldd	r30, Y+2	; 0x02
    1b0a:	fb 81       	ldd	r31, Y+3	; 0x03
    1b0c:	80 81       	ld	r24, Z
    1b0e:	91 81       	ldd	r25, Z+1	; 0x01
}
    1b10:	65 96       	adiw	r28, 0x15	; 21
    1b12:	0f b6       	in	r0, 0x3f	; 63
    1b14:	f8 94       	cli
    1b16:	de bf       	out	0x3e, r29	; 62
    1b18:	0f be       	out	0x3f, r0	; 63
    1b1a:	cd bf       	out	0x3d, r28	; 61
    1b1c:	cf 91       	pop	r28
    1b1e:	df 91       	pop	r29
    1b20:	08 95       	ret

00001b22 <vEventGroupDelete>:
/*-----------------------------------------------------------*/

void vEventGroupDelete( EventGroupHandle_t xEventGroup )
{
    1b22:	df 93       	push	r29
    1b24:	cf 93       	push	r28
    1b26:	00 d0       	rcall	.+0      	; 0x1b28 <vEventGroupDelete+0x6>
    1b28:	00 d0       	rcall	.+0      	; 0x1b2a <vEventGroupDelete+0x8>
    1b2a:	00 d0       	rcall	.+0      	; 0x1b2c <vEventGroupDelete+0xa>
    1b2c:	cd b7       	in	r28, 0x3d	; 61
    1b2e:	de b7       	in	r29, 0x3e	; 62
    1b30:	9e 83       	std	Y+6, r25	; 0x06
    1b32:	8d 83       	std	Y+5, r24	; 0x05
EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
    1b34:	8d 81       	ldd	r24, Y+5	; 0x05
    1b36:	9e 81       	ldd	r25, Y+6	; 0x06
    1b38:	9c 83       	std	Y+4, r25	; 0x04
    1b3a:	8b 83       	std	Y+3, r24	; 0x03
const List_t *pxTasksWaitingForBits = &( pxEventBits->xTasksWaitingForBits );
    1b3c:	8b 81       	ldd	r24, Y+3	; 0x03
    1b3e:	9c 81       	ldd	r25, Y+4	; 0x04
    1b40:	02 96       	adiw	r24, 0x02	; 2
    1b42:	9a 83       	std	Y+2, r25	; 0x02
    1b44:	89 83       	std	Y+1, r24	; 0x01

	vTaskSuspendAll();
    1b46:	0e 94 60 1e 	call	0x3cc0	; 0x3cc0 <vTaskSuspendAll>
    1b4a:	08 c0       	rjmp	.+16     	; 0x1b5c <vEventGroupDelete+0x3a>
		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
		{
			/* Unblock the task, returning 0 as the event list is being deleted
			and	cannot therefore have any bits set. */
			configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
			( void ) xTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
    1b4c:	e9 81       	ldd	r30, Y+1	; 0x01
    1b4e:	fa 81       	ldd	r31, Y+2	; 0x02
    1b50:	85 81       	ldd	r24, Z+5	; 0x05
    1b52:	96 81       	ldd	r25, Z+6	; 0x06
    1b54:	60 e0       	ldi	r22, 0x00	; 0
    1b56:	72 e0       	ldi	r23, 0x02	; 2
    1b58:	0e 94 5e 21 	call	0x42bc	; 0x42bc <xTaskRemoveFromUnorderedEventList>

	vTaskSuspendAll();
	{
		traceEVENT_GROUP_DELETE( xEventGroup );

		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
    1b5c:	e9 81       	ldd	r30, Y+1	; 0x01
    1b5e:	fa 81       	ldd	r31, Y+2	; 0x02
    1b60:	80 81       	ld	r24, Z
    1b62:	88 23       	and	r24, r24
    1b64:	99 f7       	brne	.-26     	; 0x1b4c <vEventGroupDelete+0x2a>
			and	cannot therefore have any bits set. */
			configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
			( void ) xTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
		}

		vPortFree( pxEventBits );
    1b66:	8b 81       	ldd	r24, Y+3	; 0x03
    1b68:	9c 81       	ldd	r25, Y+4	; 0x04
    1b6a:	0e 94 84 0e 	call	0x1d08	; 0x1d08 <vPortFree>
	}
	( void ) xTaskResumeAll();
    1b6e:	0e 94 6c 1e 	call	0x3cd8	; 0x3cd8 <xTaskResumeAll>
}
    1b72:	26 96       	adiw	r28, 0x06	; 6
    1b74:	0f b6       	in	r0, 0x3f	; 63
    1b76:	f8 94       	cli
    1b78:	de bf       	out	0x3e, r29	; 62
    1b7a:	0f be       	out	0x3f, r0	; 63
    1b7c:	cd bf       	out	0x3d, r28	; 61
    1b7e:	cf 91       	pop	r28
    1b80:	df 91       	pop	r29
    1b82:	08 95       	ret

00001b84 <vEventGroupSetBitsCallback>:
/*-----------------------------------------------------------*/

/* For internal use only - execute a 'set bits' command that was pended from
an interrupt. */
void vEventGroupSetBitsCallback( void *pvEventGroup, const uint32_t ulBitsToSet )
{
    1b84:	df 93       	push	r29
    1b86:	cf 93       	push	r28
    1b88:	00 d0       	rcall	.+0      	; 0x1b8a <vEventGroupSetBitsCallback+0x6>
    1b8a:	00 d0       	rcall	.+0      	; 0x1b8c <vEventGroupSetBitsCallback+0x8>
    1b8c:	00 d0       	rcall	.+0      	; 0x1b8e <vEventGroupSetBitsCallback+0xa>
    1b8e:	cd b7       	in	r28, 0x3d	; 61
    1b90:	de b7       	in	r29, 0x3e	; 62
    1b92:	9a 83       	std	Y+2, r25	; 0x02
    1b94:	89 83       	std	Y+1, r24	; 0x01
    1b96:	4b 83       	std	Y+3, r20	; 0x03
    1b98:	5c 83       	std	Y+4, r21	; 0x04
    1b9a:	6d 83       	std	Y+5, r22	; 0x05
    1b9c:	7e 83       	std	Y+6, r23	; 0x06
	( void ) xEventGroupSetBits( pvEventGroup, ( EventBits_t ) ulBitsToSet );
    1b9e:	2b 81       	ldd	r18, Y+3	; 0x03
    1ba0:	3c 81       	ldd	r19, Y+4	; 0x04
    1ba2:	89 81       	ldd	r24, Y+1	; 0x01
    1ba4:	9a 81       	ldd	r25, Y+2	; 0x02
    1ba6:	b9 01       	movw	r22, r18
    1ba8:	0e 94 df 0c 	call	0x19be	; 0x19be <xEventGroupSetBits>
}
    1bac:	26 96       	adiw	r28, 0x06	; 6
    1bae:	0f b6       	in	r0, 0x3f	; 63
    1bb0:	f8 94       	cli
    1bb2:	de bf       	out	0x3e, r29	; 62
    1bb4:	0f be       	out	0x3f, r0	; 63
    1bb6:	cd bf       	out	0x3d, r28	; 61
    1bb8:	cf 91       	pop	r28
    1bba:	df 91       	pop	r29
    1bbc:	08 95       	ret

00001bbe <vEventGroupClearBitsCallback>:
/*-----------------------------------------------------------*/

/* For internal use only - execute a 'clear bits' command that was pended from
an interrupt. */
void vEventGroupClearBitsCallback( void *pvEventGroup, const uint32_t ulBitsToClear )
{
    1bbe:	df 93       	push	r29
    1bc0:	cf 93       	push	r28
    1bc2:	00 d0       	rcall	.+0      	; 0x1bc4 <vEventGroupClearBitsCallback+0x6>
    1bc4:	00 d0       	rcall	.+0      	; 0x1bc6 <vEventGroupClearBitsCallback+0x8>
    1bc6:	00 d0       	rcall	.+0      	; 0x1bc8 <vEventGroupClearBitsCallback+0xa>
    1bc8:	cd b7       	in	r28, 0x3d	; 61
    1bca:	de b7       	in	r29, 0x3e	; 62
    1bcc:	9a 83       	std	Y+2, r25	; 0x02
    1bce:	89 83       	std	Y+1, r24	; 0x01
    1bd0:	4b 83       	std	Y+3, r20	; 0x03
    1bd2:	5c 83       	std	Y+4, r21	; 0x04
    1bd4:	6d 83       	std	Y+5, r22	; 0x05
    1bd6:	7e 83       	std	Y+6, r23	; 0x06
	( void ) xEventGroupClearBits( pvEventGroup, ( EventBits_t ) ulBitsToClear );
    1bd8:	2b 81       	ldd	r18, Y+3	; 0x03
    1bda:	3c 81       	ldd	r19, Y+4	; 0x04
    1bdc:	89 81       	ldd	r24, Y+1	; 0x01
    1bde:	9a 81       	ldd	r25, Y+2	; 0x02
    1be0:	b9 01       	movw	r22, r18
    1be2:	0e 94 87 0c 	call	0x190e	; 0x190e <xEventGroupClearBits>
}
    1be6:	26 96       	adiw	r28, 0x06	; 6
    1be8:	0f b6       	in	r0, 0x3f	; 63
    1bea:	f8 94       	cli
    1bec:	de bf       	out	0x3e, r29	; 62
    1bee:	0f be       	out	0x3f, r0	; 63
    1bf0:	cd bf       	out	0x3d, r28	; 61
    1bf2:	cf 91       	pop	r28
    1bf4:	df 91       	pop	r29
    1bf6:	08 95       	ret

00001bf8 <prvTestWaitCondition>:
/*-----------------------------------------------------------*/

static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits )
{
    1bf8:	df 93       	push	r29
    1bfa:	cf 93       	push	r28
    1bfc:	00 d0       	rcall	.+0      	; 0x1bfe <prvTestWaitCondition+0x6>
    1bfe:	00 d0       	rcall	.+0      	; 0x1c00 <prvTestWaitCondition+0x8>
    1c00:	00 d0       	rcall	.+0      	; 0x1c02 <prvTestWaitCondition+0xa>
    1c02:	cd b7       	in	r28, 0x3d	; 61
    1c04:	de b7       	in	r29, 0x3e	; 62
    1c06:	9b 83       	std	Y+3, r25	; 0x03
    1c08:	8a 83       	std	Y+2, r24	; 0x02
    1c0a:	7d 83       	std	Y+5, r23	; 0x05
    1c0c:	6c 83       	std	Y+4, r22	; 0x04
    1c0e:	4e 83       	std	Y+6, r20	; 0x06
BaseType_t xWaitConditionMet = pdFALSE;
    1c10:	19 82       	std	Y+1, r1	; 0x01

	if( xWaitForAllBits == pdFALSE )
    1c12:	8e 81       	ldd	r24, Y+6	; 0x06
    1c14:	88 23       	and	r24, r24
    1c16:	59 f4       	brne	.+22     	; 0x1c2e <prvTestWaitCondition+0x36>
	{
		/* Task only has to wait for one bit within uxBitsToWaitFor to be
		set.  Is one already set? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
    1c18:	8a 81       	ldd	r24, Y+2	; 0x02
    1c1a:	9b 81       	ldd	r25, Y+3	; 0x03
    1c1c:	2c 81       	ldd	r18, Y+4	; 0x04
    1c1e:	3d 81       	ldd	r19, Y+5	; 0x05
    1c20:	82 23       	and	r24, r18
    1c22:	93 23       	and	r25, r19
    1c24:	00 97       	sbiw	r24, 0x00	; 0
    1c26:	81 f0       	breq	.+32     	; 0x1c48 <prvTestWaitCondition+0x50>
		{
			xWaitConditionMet = pdTRUE;
    1c28:	81 e0       	ldi	r24, 0x01	; 1
    1c2a:	89 83       	std	Y+1, r24	; 0x01
    1c2c:	0d c0       	rjmp	.+26     	; 0x1c48 <prvTestWaitCondition+0x50>
	}
	else
	{
		/* Task has to wait for all the bits in uxBitsToWaitFor to be set.
		Are they set already? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
    1c2e:	2a 81       	ldd	r18, Y+2	; 0x02
    1c30:	3b 81       	ldd	r19, Y+3	; 0x03
    1c32:	8c 81       	ldd	r24, Y+4	; 0x04
    1c34:	9d 81       	ldd	r25, Y+5	; 0x05
    1c36:	28 23       	and	r18, r24
    1c38:	39 23       	and	r19, r25
    1c3a:	8c 81       	ldd	r24, Y+4	; 0x04
    1c3c:	9d 81       	ldd	r25, Y+5	; 0x05
    1c3e:	28 17       	cp	r18, r24
    1c40:	39 07       	cpc	r19, r25
    1c42:	11 f4       	brne	.+4      	; 0x1c48 <prvTestWaitCondition+0x50>
		{
			xWaitConditionMet = pdTRUE;
    1c44:	81 e0       	ldi	r24, 0x01	; 1
    1c46:	89 83       	std	Y+1, r24	; 0x01
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	return xWaitConditionMet;
    1c48:	89 81       	ldd	r24, Y+1	; 0x01
}
    1c4a:	26 96       	adiw	r28, 0x06	; 6
    1c4c:	0f b6       	in	r0, 0x3f	; 63
    1c4e:	f8 94       	cli
    1c50:	de bf       	out	0x3e, r29	; 62
    1c52:	0f be       	out	0x3f, r0	; 63
    1c54:	cd bf       	out	0x3d, r28	; 61
    1c56:	cf 91       	pop	r28
    1c58:	df 91       	pop	r29
    1c5a:	08 95       	ret

00001c5c <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    1c5c:	df 93       	push	r29
    1c5e:	cf 93       	push	r28
    1c60:	00 d0       	rcall	.+0      	; 0x1c62 <pvPortMalloc+0x6>
    1c62:	00 d0       	rcall	.+0      	; 0x1c64 <pvPortMalloc+0x8>
    1c64:	cd b7       	in	r28, 0x3d	; 61
    1c66:	de b7       	in	r29, 0x3e	; 62
    1c68:	9c 83       	std	Y+4, r25	; 0x04
    1c6a:	8b 83       	std	Y+3, r24	; 0x03
void *pvReturn = NULL;
    1c6c:	1a 82       	std	Y+2, r1	; 0x02
    1c6e:	19 82       	std	Y+1, r1	; 0x01
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
    1c70:	0e 94 60 1e 	call	0x3cc0	; 0x3cc0 <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
    1c74:	80 91 48 02 	lds	r24, 0x0248
    1c78:	90 91 49 02 	lds	r25, 0x0249
    1c7c:	00 97       	sbiw	r24, 0x00	; 0
    1c7e:	31 f4       	brne	.+12     	; 0x1c8c <pvPortMalloc+0x30>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK ) );
    1c80:	8b e4       	ldi	r24, 0x4B	; 75
    1c82:	92 e0       	ldi	r25, 0x02	; 2
    1c84:	90 93 49 02 	sts	0x0249, r25
    1c88:	80 93 48 02 	sts	0x0248, r24
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
    1c8c:	80 91 46 02 	lds	r24, 0x0246
    1c90:	90 91 47 02 	lds	r25, 0x0247
    1c94:	2b 81       	ldd	r18, Y+3	; 0x03
    1c96:	3c 81       	ldd	r19, Y+4	; 0x04
    1c98:	82 0f       	add	r24, r18
    1c9a:	93 1f       	adc	r25, r19
    1c9c:	24 e0       	ldi	r18, 0x04	; 4
    1c9e:	8d 37       	cpi	r24, 0x7D	; 125
    1ca0:	92 07       	cpc	r25, r18
    1ca2:	38 f5       	brcc	.+78     	; 0x1cf2 <pvPortMalloc+0x96>
    1ca4:	20 91 46 02 	lds	r18, 0x0246
    1ca8:	30 91 47 02 	lds	r19, 0x0247
    1cac:	8b 81       	ldd	r24, Y+3	; 0x03
    1cae:	9c 81       	ldd	r25, Y+4	; 0x04
    1cb0:	28 0f       	add	r18, r24
    1cb2:	39 1f       	adc	r19, r25
    1cb4:	80 91 46 02 	lds	r24, 0x0246
    1cb8:	90 91 47 02 	lds	r25, 0x0247
    1cbc:	82 17       	cp	r24, r18
    1cbe:	93 07       	cpc	r25, r19
    1cc0:	c0 f4       	brcc	.+48     	; 0x1cf2 <pvPortMalloc+0x96>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
    1cc2:	20 91 48 02 	lds	r18, 0x0248
    1cc6:	30 91 49 02 	lds	r19, 0x0249
    1cca:	80 91 46 02 	lds	r24, 0x0246
    1cce:	90 91 47 02 	lds	r25, 0x0247
    1cd2:	82 0f       	add	r24, r18
    1cd4:	93 1f       	adc	r25, r19
    1cd6:	9a 83       	std	Y+2, r25	; 0x02
    1cd8:	89 83       	std	Y+1, r24	; 0x01
			xNextFreeByte += xWantedSize;
    1cda:	20 91 46 02 	lds	r18, 0x0246
    1cde:	30 91 47 02 	lds	r19, 0x0247
    1ce2:	8b 81       	ldd	r24, Y+3	; 0x03
    1ce4:	9c 81       	ldd	r25, Y+4	; 0x04
    1ce6:	82 0f       	add	r24, r18
    1ce8:	93 1f       	adc	r25, r19
    1cea:	90 93 47 02 	sts	0x0247, r25
    1cee:	80 93 46 02 	sts	0x0246, r24
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    1cf2:	0e 94 6c 1e 	call	0x3cd8	; 0x3cd8 <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif

	return pvReturn;
    1cf6:	89 81       	ldd	r24, Y+1	; 0x01
    1cf8:	9a 81       	ldd	r25, Y+2	; 0x02
}
    1cfa:	0f 90       	pop	r0
    1cfc:	0f 90       	pop	r0
    1cfe:	0f 90       	pop	r0
    1d00:	0f 90       	pop	r0
    1d02:	cf 91       	pop	r28
    1d04:	df 91       	pop	r29
    1d06:	08 95       	ret

00001d08 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    1d08:	df 93       	push	r29
    1d0a:	cf 93       	push	r28
    1d0c:	00 d0       	rcall	.+0      	; 0x1d0e <vPortFree+0x6>
    1d0e:	cd b7       	in	r28, 0x3d	; 61
    1d10:	de b7       	in	r29, 0x3e	; 62
    1d12:	9a 83       	std	Y+2, r25	; 0x02
    1d14:	89 83       	std	Y+1, r24	; 0x01
	http://www.FreeRTOS.org for more information. */
	( void ) pv;

	/* Force an assert as it is invalid to call this function. */
	configASSERT( pv == NULL );
}
    1d16:	0f 90       	pop	r0
    1d18:	0f 90       	pop	r0
    1d1a:	cf 91       	pop	r28
    1d1c:	df 91       	pop	r29
    1d1e:	08 95       	ret

00001d20 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
    1d20:	df 93       	push	r29
    1d22:	cf 93       	push	r28
    1d24:	cd b7       	in	r28, 0x3d	; 61
    1d26:	de b7       	in	r29, 0x3e	; 62
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
    1d28:	10 92 47 02 	sts	0x0247, r1
    1d2c:	10 92 46 02 	sts	0x0246, r1
}
    1d30:	cf 91       	pop	r28
    1d32:	df 91       	pop	r29
    1d34:	08 95       	ret

00001d36 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
    1d36:	df 93       	push	r29
    1d38:	cf 93       	push	r28
    1d3a:	cd b7       	in	r28, 0x3d	; 61
    1d3c:	de b7       	in	r29, 0x3e	; 62
	return ( configADJUSTED_HEAP_SIZE - xNextFreeByte );
    1d3e:	20 91 46 02 	lds	r18, 0x0246
    1d42:	30 91 47 02 	lds	r19, 0x0247
    1d46:	8d e7       	ldi	r24, 0x7D	; 125
    1d48:	94 e0       	ldi	r25, 0x04	; 4
    1d4a:	82 1b       	sub	r24, r18
    1d4c:	93 0b       	sbc	r25, r19
}
    1d4e:	cf 91       	pop	r28
    1d50:	df 91       	pop	r29
    1d52:	08 95       	ret

00001d54 <vStartIntegerMathTasks>:
static volatile BaseType_t xTaskCheck[ intgNUMBER_OF_TASKS ] = { ( BaseType_t ) pdFALSE };

/*-----------------------------------------------------------*/

void vStartIntegerMathTasks( UBaseType_t uxPriority )
{
    1d54:	af 92       	push	r10
    1d56:	bf 92       	push	r11
    1d58:	cf 92       	push	r12
    1d5a:	df 92       	push	r13
    1d5c:	ef 92       	push	r14
    1d5e:	ff 92       	push	r15
    1d60:	0f 93       	push	r16
    1d62:	df 93       	push	r29
    1d64:	cf 93       	push	r28
    1d66:	00 d0       	rcall	.+0      	; 0x1d68 <vStartIntegerMathTasks+0x14>
    1d68:	0f 92       	push	r0
    1d6a:	cd b7       	in	r28, 0x3d	; 61
    1d6c:	de b7       	in	r29, 0x3e	; 62
    1d6e:	8b 83       	std	Y+3, r24	; 0x03
short sTask;

	for( sTask = 0; sTask < intgNUMBER_OF_TASKS; sTask++ )
    1d70:	1a 82       	std	Y+2, r1	; 0x02
    1d72:	19 82       	std	Y+1, r1	; 0x01
    1d74:	1b c0       	rjmp	.+54     	; 0x1dac <vStartIntegerMathTasks+0x58>
	{
		xTaskCreate( vCompeteingIntMathTask, "IntMath", intgSTACK_SIZE, ( void * ) &( xTaskCheck[ sTask ] ), uxPriority, ( TaskHandle_t * ) NULL );
    1d76:	89 81       	ldd	r24, Y+1	; 0x01
    1d78:	9a 81       	ldd	r25, Y+2	; 0x02
    1d7a:	fc 01       	movw	r30, r24
    1d7c:	e8 53       	subi	r30, 0x38	; 56
    1d7e:	f9 4f       	sbci	r31, 0xF9	; 249
    1d80:	88 ee       	ldi	r24, 0xE8	; 232
    1d82:	9e e0       	ldi	r25, 0x0E	; 14
    1d84:	20 e7       	ldi	r18, 0x70	; 112
    1d86:	30 e0       	ldi	r19, 0x00	; 0
    1d88:	b9 01       	movw	r22, r18
    1d8a:	45 e5       	ldi	r20, 0x55	; 85
    1d8c:	50 e0       	ldi	r21, 0x00	; 0
    1d8e:	9f 01       	movw	r18, r30
    1d90:	0b 81       	ldd	r16, Y+3	; 0x03
    1d92:	ee 24       	eor	r14, r14
    1d94:	ff 24       	eor	r15, r15
    1d96:	cc 24       	eor	r12, r12
    1d98:	dd 24       	eor	r13, r13
    1d9a:	aa 24       	eor	r10, r10
    1d9c:	bb 24       	eor	r11, r11
    1d9e:	0e 94 32 1b 	call	0x3664	; 0x3664 <xTaskGenericCreate>

void vStartIntegerMathTasks( UBaseType_t uxPriority )
{
short sTask;

	for( sTask = 0; sTask < intgNUMBER_OF_TASKS; sTask++ )
    1da2:	89 81       	ldd	r24, Y+1	; 0x01
    1da4:	9a 81       	ldd	r25, Y+2	; 0x02
    1da6:	01 96       	adiw	r24, 0x01	; 1
    1da8:	9a 83       	std	Y+2, r25	; 0x02
    1daa:	89 83       	std	Y+1, r24	; 0x01
    1dac:	89 81       	ldd	r24, Y+1	; 0x01
    1dae:	9a 81       	ldd	r25, Y+2	; 0x02
    1db0:	18 16       	cp	r1, r24
    1db2:	19 06       	cpc	r1, r25
    1db4:	04 f7       	brge	.-64     	; 0x1d76 <vStartIntegerMathTasks+0x22>
	{
		xTaskCreate( vCompeteingIntMathTask, "IntMath", intgSTACK_SIZE, ( void * ) &( xTaskCheck[ sTask ] ), uxPriority, ( TaskHandle_t * ) NULL );
	}
}
    1db6:	0f 90       	pop	r0
    1db8:	0f 90       	pop	r0
    1dba:	0f 90       	pop	r0
    1dbc:	cf 91       	pop	r28
    1dbe:	df 91       	pop	r29
    1dc0:	0f 91       	pop	r16
    1dc2:	ff 90       	pop	r15
    1dc4:	ef 90       	pop	r14
    1dc6:	df 90       	pop	r13
    1dc8:	cf 90       	pop	r12
    1dca:	bf 90       	pop	r11
    1dcc:	af 90       	pop	r10
    1dce:	08 95       	ret

00001dd0 <vCompeteingIntMathTask>:
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vCompeteingIntMathTask, pvParameters )
{
    1dd0:	df 93       	push	r29
    1dd2:	cf 93       	push	r28
    1dd4:	cd b7       	in	r28, 0x3d	; 61
    1dd6:	de b7       	in	r29, 0x3e	; 62
    1dd8:	2a 97       	sbiw	r28, 0x0a	; 10
    1dda:	0f b6       	in	r0, 0x3f	; 63
    1ddc:	f8 94       	cli
    1dde:	de bf       	out	0x3e, r29	; 62
    1de0:	0f be       	out	0x3f, r0	; 63
    1de2:	cd bf       	out	0x3d, r28	; 61
    1de4:	9a 87       	std	Y+10, r25	; 0x0a
    1de6:	89 87       	std	Y+9, r24	; 0x09
/* These variables are all effectively set to constants so they are volatile to
ensure the compiler does not just get rid of them. */
volatile long lValue;
short sError = pdFALSE;
    1de8:	1c 82       	std	Y+4, r1	; 0x04
    1dea:	1b 82       	std	Y+3, r1	; 0x03
volatile BaseType_t *pxTaskHasExecuted;

	/* Set a pointer to the variable we are going to set to true each
	iteration.  This is also a good test of the parameter passing mechanism
	within each port. */
	pxTaskHasExecuted = ( volatile BaseType_t * ) pvParameters;
    1dec:	89 85       	ldd	r24, Y+9	; 0x09
    1dee:	9a 85       	ldd	r25, Y+10	; 0x0a
    1df0:	9a 83       	std	Y+2, r25	; 0x02
    1df2:	89 83       	std	Y+1, r24	; 0x01
	/* Keep performing a calculation and checking the result against a constant. */
	for( ;; )
	{
		/* Perform the calculation.  This will store partial value in
		registers, resulting in a good test of the context switch mechanism. */
		lValue = intgCONST1;
    1df4:	8b e7       	ldi	r24, 0x7B	; 123
    1df6:	90 e0       	ldi	r25, 0x00	; 0
    1df8:	a0 e0       	ldi	r26, 0x00	; 0
    1dfa:	b0 e0       	ldi	r27, 0x00	; 0
    1dfc:	8d 83       	std	Y+5, r24	; 0x05
    1dfe:	9e 83       	std	Y+6, r25	; 0x06
    1e00:	af 83       	std	Y+7, r26	; 0x07
    1e02:	b8 87       	std	Y+8, r27	; 0x08
		lValue += intgCONST2;
    1e04:	8d 81       	ldd	r24, Y+5	; 0x05
    1e06:	9e 81       	ldd	r25, Y+6	; 0x06
    1e08:	af 81       	ldd	r26, Y+7	; 0x07
    1e0a:	b8 85       	ldd	r27, Y+8	; 0x08
    1e0c:	89 5b       	subi	r24, 0xB9	; 185
    1e0e:	9b 46       	sbci	r25, 0x6B	; 107
    1e10:	ac 4f       	sbci	r26, 0xFC	; 252
    1e12:	bf 4f       	sbci	r27, 0xFF	; 255
    1e14:	8d 83       	std	Y+5, r24	; 0x05
    1e16:	9e 83       	std	Y+6, r25	; 0x06
    1e18:	af 83       	std	Y+7, r26	; 0x07
    1e1a:	b8 87       	std	Y+8, r27	; 0x08
			taskYIELD();
		}
		#endif

		/* Finish off the calculation. */
		lValue *= intgCONST3;
    1e1c:	8d 81       	ldd	r24, Y+5	; 0x05
    1e1e:	9e 81       	ldd	r25, Y+6	; 0x06
    1e20:	af 81       	ldd	r26, Y+7	; 0x07
    1e22:	b8 85       	ldd	r27, Y+8	; 0x08
    1e24:	2d ef       	ldi	r18, 0xFD	; 253
    1e26:	3f ef       	ldi	r19, 0xFF	; 255
    1e28:	4f ef       	ldi	r20, 0xFF	; 255
    1e2a:	5f ef       	ldi	r21, 0xFF	; 255
    1e2c:	bc 01       	movw	r22, r24
    1e2e:	cd 01       	movw	r24, r26
    1e30:	0e 94 50 36 	call	0x6ca0	; 0x6ca0 <__mulsi3>
    1e34:	dc 01       	movw	r26, r24
    1e36:	cb 01       	movw	r24, r22
    1e38:	8d 83       	std	Y+5, r24	; 0x05
    1e3a:	9e 83       	std	Y+6, r25	; 0x06
    1e3c:	af 83       	std	Y+7, r26	; 0x07
    1e3e:	b8 87       	std	Y+8, r27	; 0x08
		lValue /= intgCONST4;
    1e40:	8d 81       	ldd	r24, Y+5	; 0x05
    1e42:	9e 81       	ldd	r25, Y+6	; 0x06
    1e44:	af 81       	ldd	r26, Y+7	; 0x07
    1e46:	b8 85       	ldd	r27, Y+8	; 0x08
    1e48:	27 e0       	ldi	r18, 0x07	; 7
    1e4a:	30 e0       	ldi	r19, 0x00	; 0
    1e4c:	40 e0       	ldi	r20, 0x00	; 0
    1e4e:	50 e0       	ldi	r21, 0x00	; 0
    1e50:	bc 01       	movw	r22, r24
    1e52:	cd 01       	movw	r24, r26
    1e54:	0e 94 91 36 	call	0x6d22	; 0x6d22 <__divmodsi4>
    1e58:	da 01       	movw	r26, r20
    1e5a:	c9 01       	movw	r24, r18
    1e5c:	8d 83       	std	Y+5, r24	; 0x05
    1e5e:	9e 83       	std	Y+6, r25	; 0x06
    1e60:	af 83       	std	Y+7, r26	; 0x07
    1e62:	b8 87       	std	Y+8, r27	; 0x08

		/* If the calculation is found to be incorrect we stop setting the 
		TaskHasExecuted variable so the check task can see an error has 
		occurred. */
		if( lValue != intgEXPECTED_ANSWER ) /*lint !e774 volatile used to prevent this being optimised out. */
    1e64:	8d 81       	ldd	r24, Y+5	; 0x05
    1e66:	9e 81       	ldd	r25, Y+6	; 0x06
    1e68:	af 81       	ldd	r26, Y+7	; 0x07
    1e6a:	b8 85       	ldd	r27, Y+8	; 0x08
    1e6c:	8b 31       	cpi	r24, 0x1B	; 27
    1e6e:	27 e7       	ldi	r18, 0x77	; 119
    1e70:	92 07       	cpc	r25, r18
    1e72:	2e ef       	ldi	r18, 0xFE	; 254
    1e74:	a2 07       	cpc	r26, r18
    1e76:	2f ef       	ldi	r18, 0xFF	; 255
    1e78:	b2 07       	cpc	r27, r18
    1e7a:	21 f0       	breq	.+8      	; 0x1e84 <vCompeteingIntMathTask+0xb4>
		{
			sError = pdTRUE;
    1e7c:	81 e0       	ldi	r24, 0x01	; 1
    1e7e:	90 e0       	ldi	r25, 0x00	; 0
    1e80:	9c 83       	std	Y+4, r25	; 0x04
    1e82:	8b 83       	std	Y+3, r24	; 0x03
		}

		if( sError == pdFALSE )
    1e84:	8b 81       	ldd	r24, Y+3	; 0x03
    1e86:	9c 81       	ldd	r25, Y+4	; 0x04
    1e88:	00 97       	sbiw	r24, 0x00	; 0
    1e8a:	09 f0       	breq	.+2      	; 0x1e8e <vCompeteingIntMathTask+0xbe>
    1e8c:	b3 cf       	rjmp	.-154    	; 0x1df4 <vCompeteingIntMathTask+0x24>
		{
			/* We have not encountered any errors, so set the flag that show
			we are still executing.  This will be periodically cleared by
			the check task. */
			portENTER_CRITICAL();
    1e8e:	0f b6       	in	r0, 0x3f	; 63
    1e90:	f8 94       	cli
    1e92:	0f 92       	push	r0
				*pxTaskHasExecuted = pdTRUE;
    1e94:	e9 81       	ldd	r30, Y+1	; 0x01
    1e96:	fa 81       	ldd	r31, Y+2	; 0x02
    1e98:	81 e0       	ldi	r24, 0x01	; 1
    1e9a:	80 83       	st	Z, r24
			portEXIT_CRITICAL();
    1e9c:	0f 90       	pop	r0
    1e9e:	0f be       	out	0x3f, r0	; 63
    1ea0:	a9 cf       	rjmp	.-174    	; 0x1df4 <vCompeteingIntMathTask+0x24>

00001ea2 <xAreIntegerMathsTaskStillRunning>:
}
/*-----------------------------------------------------------*/

/* This is called to check that all the created tasks are still running. */
BaseType_t xAreIntegerMathsTaskStillRunning( void )
{
    1ea2:	df 93       	push	r29
    1ea4:	cf 93       	push	r28
    1ea6:	00 d0       	rcall	.+0      	; 0x1ea8 <xAreIntegerMathsTaskStillRunning+0x6>
    1ea8:	0f 92       	push	r0
    1eaa:	cd b7       	in	r28, 0x3d	; 61
    1eac:	de b7       	in	r29, 0x3e	; 62
BaseType_t xReturn = pdTRUE;
    1eae:	81 e0       	ldi	r24, 0x01	; 1
    1eb0:	8b 83       	std	Y+3, r24	; 0x03
short sTask;

	/* Check the maths tasks are still running by ensuring their check variables 
	are still being set to true. */
	for( sTask = 0; sTask < intgNUMBER_OF_TASKS; sTask++ )
    1eb2:	1a 82       	std	Y+2, r1	; 0x02
    1eb4:	19 82       	std	Y+1, r1	; 0x01
    1eb6:	14 c0       	rjmp	.+40     	; 0x1ee0 <xAreIntegerMathsTaskStillRunning+0x3e>
	{
		if( xTaskCheck[ sTask ] == pdFALSE )
    1eb8:	89 81       	ldd	r24, Y+1	; 0x01
    1eba:	9a 81       	ldd	r25, Y+2	; 0x02
    1ebc:	fc 01       	movw	r30, r24
    1ebe:	e8 53       	subi	r30, 0x38	; 56
    1ec0:	f9 4f       	sbci	r31, 0xF9	; 249
    1ec2:	80 81       	ld	r24, Z
    1ec4:	88 23       	and	r24, r24
    1ec6:	09 f4       	brne	.+2      	; 0x1eca <xAreIntegerMathsTaskStillRunning+0x28>
		{
			/* The check has not incremented so an error exists. */
			xReturn = pdFALSE;
    1ec8:	1b 82       	std	Y+3, r1	; 0x03
		}

		/* Reset the check variable so we can tell if it has been set by
		the next time around. */
		xTaskCheck[ sTask ] = pdFALSE;
    1eca:	89 81       	ldd	r24, Y+1	; 0x01
    1ecc:	9a 81       	ldd	r25, Y+2	; 0x02
    1ece:	fc 01       	movw	r30, r24
    1ed0:	e8 53       	subi	r30, 0x38	; 56
    1ed2:	f9 4f       	sbci	r31, 0xF9	; 249
    1ed4:	10 82       	st	Z, r1
BaseType_t xReturn = pdTRUE;
short sTask;

	/* Check the maths tasks are still running by ensuring their check variables 
	are still being set to true. */
	for( sTask = 0; sTask < intgNUMBER_OF_TASKS; sTask++ )
    1ed6:	89 81       	ldd	r24, Y+1	; 0x01
    1ed8:	9a 81       	ldd	r25, Y+2	; 0x02
    1eda:	01 96       	adiw	r24, 0x01	; 1
    1edc:	9a 83       	std	Y+2, r25	; 0x02
    1ede:	89 83       	std	Y+1, r24	; 0x01
    1ee0:	89 81       	ldd	r24, Y+1	; 0x01
    1ee2:	9a 81       	ldd	r25, Y+2	; 0x02
    1ee4:	18 16       	cp	r1, r24
    1ee6:	19 06       	cpc	r1, r25
    1ee8:	3c f7       	brge	.-50     	; 0x1eb8 <xAreIntegerMathsTaskStillRunning+0x16>
		/* Reset the check variable so we can tell if it has been set by
		the next time around. */
		xTaskCheck[ sTask ] = pdFALSE;
	}

	return xReturn;
    1eea:	8b 81       	ldd	r24, Y+3	; 0x03
}
    1eec:	0f 90       	pop	r0
    1eee:	0f 90       	pop	r0
    1ef0:	0f 90       	pop	r0
    1ef2:	cf 91       	pop	r28
    1ef4:	df 91       	pop	r29
    1ef6:	08 95       	ret

00001ef8 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    1ef8:	df 93       	push	r29
    1efa:	cf 93       	push	r28
    1efc:	00 d0       	rcall	.+0      	; 0x1efe <vListInitialise+0x6>
    1efe:	cd b7       	in	r28, 0x3d	; 61
    1f00:	de b7       	in	r29, 0x3e	; 62
    1f02:	9a 83       	std	Y+2, r25	; 0x02
    1f04:	89 83       	std	Y+1, r24	; 0x01
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1f06:	89 81       	ldd	r24, Y+1	; 0x01
    1f08:	9a 81       	ldd	r25, Y+2	; 0x02
    1f0a:	03 96       	adiw	r24, 0x03	; 3
    1f0c:	e9 81       	ldd	r30, Y+1	; 0x01
    1f0e:	fa 81       	ldd	r31, Y+2	; 0x02
    1f10:	92 83       	std	Z+2, r25	; 0x02
    1f12:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    1f14:	e9 81       	ldd	r30, Y+1	; 0x01
    1f16:	fa 81       	ldd	r31, Y+2	; 0x02
    1f18:	8f ef       	ldi	r24, 0xFF	; 255
    1f1a:	9f ef       	ldi	r25, 0xFF	; 255
    1f1c:	94 83       	std	Z+4, r25	; 0x04
    1f1e:	83 83       	std	Z+3, r24	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1f20:	89 81       	ldd	r24, Y+1	; 0x01
    1f22:	9a 81       	ldd	r25, Y+2	; 0x02
    1f24:	03 96       	adiw	r24, 0x03	; 3
    1f26:	e9 81       	ldd	r30, Y+1	; 0x01
    1f28:	fa 81       	ldd	r31, Y+2	; 0x02
    1f2a:	96 83       	std	Z+6, r25	; 0x06
    1f2c:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1f2e:	89 81       	ldd	r24, Y+1	; 0x01
    1f30:	9a 81       	ldd	r25, Y+2	; 0x02
    1f32:	03 96       	adiw	r24, 0x03	; 3
    1f34:	e9 81       	ldd	r30, Y+1	; 0x01
    1f36:	fa 81       	ldd	r31, Y+2	; 0x02
    1f38:	90 87       	std	Z+8, r25	; 0x08
    1f3a:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    1f3c:	e9 81       	ldd	r30, Y+1	; 0x01
    1f3e:	fa 81       	ldd	r31, Y+2	; 0x02
    1f40:	10 82       	st	Z, r1
}
    1f42:	0f 90       	pop	r0
    1f44:	0f 90       	pop	r0
    1f46:	cf 91       	pop	r28
    1f48:	df 91       	pop	r29
    1f4a:	08 95       	ret

00001f4c <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
    1f4c:	df 93       	push	r29
    1f4e:	cf 93       	push	r28
    1f50:	00 d0       	rcall	.+0      	; 0x1f52 <vListInitialiseItem+0x6>
    1f52:	cd b7       	in	r28, 0x3d	; 61
    1f54:	de b7       	in	r29, 0x3e	; 62
    1f56:	9a 83       	std	Y+2, r25	; 0x02
    1f58:	89 83       	std	Y+1, r24	; 0x01
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    1f5a:	e9 81       	ldd	r30, Y+1	; 0x01
    1f5c:	fa 81       	ldd	r31, Y+2	; 0x02
    1f5e:	11 86       	std	Z+9, r1	; 0x09
    1f60:	10 86       	std	Z+8, r1	; 0x08
}
    1f62:	0f 90       	pop	r0
    1f64:	0f 90       	pop	r0
    1f66:	cf 91       	pop	r28
    1f68:	df 91       	pop	r29
    1f6a:	08 95       	ret

00001f6c <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    1f6c:	df 93       	push	r29
    1f6e:	cf 93       	push	r28
    1f70:	00 d0       	rcall	.+0      	; 0x1f72 <vListInsertEnd+0x6>
    1f72:	00 d0       	rcall	.+0      	; 0x1f74 <vListInsertEnd+0x8>
    1f74:	00 d0       	rcall	.+0      	; 0x1f76 <vListInsertEnd+0xa>
    1f76:	cd b7       	in	r28, 0x3d	; 61
    1f78:	de b7       	in	r29, 0x3e	; 62
    1f7a:	9c 83       	std	Y+4, r25	; 0x04
    1f7c:	8b 83       	std	Y+3, r24	; 0x03
    1f7e:	7e 83       	std	Y+6, r23	; 0x06
    1f80:	6d 83       	std	Y+5, r22	; 0x05
ListItem_t * const pxIndex = pxList->pxIndex;
    1f82:	eb 81       	ldd	r30, Y+3	; 0x03
    1f84:	fc 81       	ldd	r31, Y+4	; 0x04
    1f86:	81 81       	ldd	r24, Z+1	; 0x01
    1f88:	92 81       	ldd	r25, Z+2	; 0x02
    1f8a:	9a 83       	std	Y+2, r25	; 0x02
    1f8c:	89 83       	std	Y+1, r24	; 0x01

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
    1f8e:	ed 81       	ldd	r30, Y+5	; 0x05
    1f90:	fe 81       	ldd	r31, Y+6	; 0x06
    1f92:	89 81       	ldd	r24, Y+1	; 0x01
    1f94:	9a 81       	ldd	r25, Y+2	; 0x02
    1f96:	93 83       	std	Z+3, r25	; 0x03
    1f98:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    1f9a:	e9 81       	ldd	r30, Y+1	; 0x01
    1f9c:	fa 81       	ldd	r31, Y+2	; 0x02
    1f9e:	84 81       	ldd	r24, Z+4	; 0x04
    1fa0:	95 81       	ldd	r25, Z+5	; 0x05
    1fa2:	ed 81       	ldd	r30, Y+5	; 0x05
    1fa4:	fe 81       	ldd	r31, Y+6	; 0x06
    1fa6:	95 83       	std	Z+5, r25	; 0x05
    1fa8:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxPrevious->pxNext = pxNewListItem;
    1faa:	e9 81       	ldd	r30, Y+1	; 0x01
    1fac:	fa 81       	ldd	r31, Y+2	; 0x02
    1fae:	04 80       	ldd	r0, Z+4	; 0x04
    1fb0:	f5 81       	ldd	r31, Z+5	; 0x05
    1fb2:	e0 2d       	mov	r30, r0
    1fb4:	8d 81       	ldd	r24, Y+5	; 0x05
    1fb6:	9e 81       	ldd	r25, Y+6	; 0x06
    1fb8:	93 83       	std	Z+3, r25	; 0x03
    1fba:	82 83       	std	Z+2, r24	; 0x02
	pxIndex->pxPrevious = pxNewListItem;
    1fbc:	e9 81       	ldd	r30, Y+1	; 0x01
    1fbe:	fa 81       	ldd	r31, Y+2	; 0x02
    1fc0:	8d 81       	ldd	r24, Y+5	; 0x05
    1fc2:	9e 81       	ldd	r25, Y+6	; 0x06
    1fc4:	95 83       	std	Z+5, r25	; 0x05
    1fc6:	84 83       	std	Z+4, r24	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1fc8:	ed 81       	ldd	r30, Y+5	; 0x05
    1fca:	fe 81       	ldd	r31, Y+6	; 0x06
    1fcc:	8b 81       	ldd	r24, Y+3	; 0x03
    1fce:	9c 81       	ldd	r25, Y+4	; 0x04
    1fd0:	91 87       	std	Z+9, r25	; 0x09
    1fd2:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    1fd4:	eb 81       	ldd	r30, Y+3	; 0x03
    1fd6:	fc 81       	ldd	r31, Y+4	; 0x04
    1fd8:	80 81       	ld	r24, Z
    1fda:	8f 5f       	subi	r24, 0xFF	; 255
    1fdc:	eb 81       	ldd	r30, Y+3	; 0x03
    1fde:	fc 81       	ldd	r31, Y+4	; 0x04
    1fe0:	80 83       	st	Z, r24
}
    1fe2:	26 96       	adiw	r28, 0x06	; 6
    1fe4:	0f b6       	in	r0, 0x3f	; 63
    1fe6:	f8 94       	cli
    1fe8:	de bf       	out	0x3e, r29	; 62
    1fea:	0f be       	out	0x3f, r0	; 63
    1fec:	cd bf       	out	0x3d, r28	; 61
    1fee:	cf 91       	pop	r28
    1ff0:	df 91       	pop	r29
    1ff2:	08 95       	ret

00001ff4 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    1ff4:	df 93       	push	r29
    1ff6:	cf 93       	push	r28
    1ff8:	cd b7       	in	r28, 0x3d	; 61
    1ffa:	de b7       	in	r29, 0x3e	; 62
    1ffc:	28 97       	sbiw	r28, 0x08	; 8
    1ffe:	0f b6       	in	r0, 0x3f	; 63
    2000:	f8 94       	cli
    2002:	de bf       	out	0x3e, r29	; 62
    2004:	0f be       	out	0x3f, r0	; 63
    2006:	cd bf       	out	0x3d, r28	; 61
    2008:	9e 83       	std	Y+6, r25	; 0x06
    200a:	8d 83       	std	Y+5, r24	; 0x05
    200c:	78 87       	std	Y+8, r23	; 0x08
    200e:	6f 83       	std	Y+7, r22	; 0x07
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    2010:	ef 81       	ldd	r30, Y+7	; 0x07
    2012:	f8 85       	ldd	r31, Y+8	; 0x08
    2014:	80 81       	ld	r24, Z
    2016:	91 81       	ldd	r25, Z+1	; 0x01
    2018:	9a 83       	std	Y+2, r25	; 0x02
    201a:	89 83       	std	Y+1, r24	; 0x01
	are stored in ready lists (all of which have the same xItemValue value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    201c:	89 81       	ldd	r24, Y+1	; 0x01
    201e:	9a 81       	ldd	r25, Y+2	; 0x02
    2020:	2f ef       	ldi	r18, 0xFF	; 255
    2022:	8f 3f       	cpi	r24, 0xFF	; 255
    2024:	92 07       	cpc	r25, r18
    2026:	39 f4       	brne	.+14     	; 0x2036 <vListInsert+0x42>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    2028:	ed 81       	ldd	r30, Y+5	; 0x05
    202a:	fe 81       	ldd	r31, Y+6	; 0x06
    202c:	87 81       	ldd	r24, Z+7	; 0x07
    202e:	90 85       	ldd	r25, Z+8	; 0x08
    2030:	9c 83       	std	Y+4, r25	; 0x04
    2032:	8b 83       	std	Y+3, r24	; 0x03
    2034:	18 c0       	rjmp	.+48     	; 0x2066 <vListInsert+0x72>
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips, and ensure
		configASSERT() is defined!  http://www.freertos.org/a00110.html#configASSERT
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    2036:	8d 81       	ldd	r24, Y+5	; 0x05
    2038:	9e 81       	ldd	r25, Y+6	; 0x06
    203a:	03 96       	adiw	r24, 0x03	; 3
    203c:	9c 83       	std	Y+4, r25	; 0x04
    203e:	8b 83       	std	Y+3, r24	; 0x03
    2040:	06 c0       	rjmp	.+12     	; 0x204e <vListInsert+0x5a>
    2042:	eb 81       	ldd	r30, Y+3	; 0x03
    2044:	fc 81       	ldd	r31, Y+4	; 0x04
    2046:	82 81       	ldd	r24, Z+2	; 0x02
    2048:	93 81       	ldd	r25, Z+3	; 0x03
    204a:	9c 83       	std	Y+4, r25	; 0x04
    204c:	8b 83       	std	Y+3, r24	; 0x03
    204e:	eb 81       	ldd	r30, Y+3	; 0x03
    2050:	fc 81       	ldd	r31, Y+4	; 0x04
    2052:	02 80       	ldd	r0, Z+2	; 0x02
    2054:	f3 81       	ldd	r31, Z+3	; 0x03
    2056:	e0 2d       	mov	r30, r0
    2058:	20 81       	ld	r18, Z
    205a:	31 81       	ldd	r19, Z+1	; 0x01
    205c:	89 81       	ldd	r24, Y+1	; 0x01
    205e:	9a 81       	ldd	r25, Y+2	; 0x02
    2060:	82 17       	cp	r24, r18
    2062:	93 07       	cpc	r25, r19
    2064:	70 f7       	brcc	.-36     	; 0x2042 <vListInsert+0x4e>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    2066:	eb 81       	ldd	r30, Y+3	; 0x03
    2068:	fc 81       	ldd	r31, Y+4	; 0x04
    206a:	82 81       	ldd	r24, Z+2	; 0x02
    206c:	93 81       	ldd	r25, Z+3	; 0x03
    206e:	ef 81       	ldd	r30, Y+7	; 0x07
    2070:	f8 85       	ldd	r31, Y+8	; 0x08
    2072:	93 83       	std	Z+3, r25	; 0x03
    2074:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    2076:	ef 81       	ldd	r30, Y+7	; 0x07
    2078:	f8 85       	ldd	r31, Y+8	; 0x08
    207a:	02 80       	ldd	r0, Z+2	; 0x02
    207c:	f3 81       	ldd	r31, Z+3	; 0x03
    207e:	e0 2d       	mov	r30, r0
    2080:	8f 81       	ldd	r24, Y+7	; 0x07
    2082:	98 85       	ldd	r25, Y+8	; 0x08
    2084:	95 83       	std	Z+5, r25	; 0x05
    2086:	84 83       	std	Z+4, r24	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    2088:	ef 81       	ldd	r30, Y+7	; 0x07
    208a:	f8 85       	ldd	r31, Y+8	; 0x08
    208c:	8b 81       	ldd	r24, Y+3	; 0x03
    208e:	9c 81       	ldd	r25, Y+4	; 0x04
    2090:	95 83       	std	Z+5, r25	; 0x05
    2092:	84 83       	std	Z+4, r24	; 0x04
	pxIterator->pxNext = pxNewListItem;
    2094:	eb 81       	ldd	r30, Y+3	; 0x03
    2096:	fc 81       	ldd	r31, Y+4	; 0x04
    2098:	8f 81       	ldd	r24, Y+7	; 0x07
    209a:	98 85       	ldd	r25, Y+8	; 0x08
    209c:	93 83       	std	Z+3, r25	; 0x03
    209e:	82 83       	std	Z+2, r24	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    20a0:	ef 81       	ldd	r30, Y+7	; 0x07
    20a2:	f8 85       	ldd	r31, Y+8	; 0x08
    20a4:	8d 81       	ldd	r24, Y+5	; 0x05
    20a6:	9e 81       	ldd	r25, Y+6	; 0x06
    20a8:	91 87       	std	Z+9, r25	; 0x09
    20aa:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    20ac:	ed 81       	ldd	r30, Y+5	; 0x05
    20ae:	fe 81       	ldd	r31, Y+6	; 0x06
    20b0:	80 81       	ld	r24, Z
    20b2:	8f 5f       	subi	r24, 0xFF	; 255
    20b4:	ed 81       	ldd	r30, Y+5	; 0x05
    20b6:	fe 81       	ldd	r31, Y+6	; 0x06
    20b8:	80 83       	st	Z, r24
}
    20ba:	28 96       	adiw	r28, 0x08	; 8
    20bc:	0f b6       	in	r0, 0x3f	; 63
    20be:	f8 94       	cli
    20c0:	de bf       	out	0x3e, r29	; 62
    20c2:	0f be       	out	0x3f, r0	; 63
    20c4:	cd bf       	out	0x3d, r28	; 61
    20c6:	cf 91       	pop	r28
    20c8:	df 91       	pop	r29
    20ca:	08 95       	ret

000020cc <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    20cc:	df 93       	push	r29
    20ce:	cf 93       	push	r28
    20d0:	00 d0       	rcall	.+0      	; 0x20d2 <uxListRemove+0x6>
    20d2:	00 d0       	rcall	.+0      	; 0x20d4 <uxListRemove+0x8>
    20d4:	cd b7       	in	r28, 0x3d	; 61
    20d6:	de b7       	in	r29, 0x3e	; 62
    20d8:	9c 83       	std	Y+4, r25	; 0x04
    20da:	8b 83       	std	Y+3, r24	; 0x03
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
    20dc:	eb 81       	ldd	r30, Y+3	; 0x03
    20de:	fc 81       	ldd	r31, Y+4	; 0x04
    20e0:	80 85       	ldd	r24, Z+8	; 0x08
    20e2:	91 85       	ldd	r25, Z+9	; 0x09
    20e4:	9a 83       	std	Y+2, r25	; 0x02
    20e6:	89 83       	std	Y+1, r24	; 0x01

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    20e8:	eb 81       	ldd	r30, Y+3	; 0x03
    20ea:	fc 81       	ldd	r31, Y+4	; 0x04
    20ec:	a2 81       	ldd	r26, Z+2	; 0x02
    20ee:	b3 81       	ldd	r27, Z+3	; 0x03
    20f0:	eb 81       	ldd	r30, Y+3	; 0x03
    20f2:	fc 81       	ldd	r31, Y+4	; 0x04
    20f4:	84 81       	ldd	r24, Z+4	; 0x04
    20f6:	95 81       	ldd	r25, Z+5	; 0x05
    20f8:	15 96       	adiw	r26, 0x05	; 5
    20fa:	9c 93       	st	X, r25
    20fc:	8e 93       	st	-X, r24
    20fe:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    2100:	eb 81       	ldd	r30, Y+3	; 0x03
    2102:	fc 81       	ldd	r31, Y+4	; 0x04
    2104:	a4 81       	ldd	r26, Z+4	; 0x04
    2106:	b5 81       	ldd	r27, Z+5	; 0x05
    2108:	eb 81       	ldd	r30, Y+3	; 0x03
    210a:	fc 81       	ldd	r31, Y+4	; 0x04
    210c:	82 81       	ldd	r24, Z+2	; 0x02
    210e:	93 81       	ldd	r25, Z+3	; 0x03
    2110:	13 96       	adiw	r26, 0x03	; 3
    2112:	9c 93       	st	X, r25
    2114:	8e 93       	st	-X, r24
    2116:	12 97       	sbiw	r26, 0x02	; 2

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    2118:	e9 81       	ldd	r30, Y+1	; 0x01
    211a:	fa 81       	ldd	r31, Y+2	; 0x02
    211c:	21 81       	ldd	r18, Z+1	; 0x01
    211e:	32 81       	ldd	r19, Z+2	; 0x02
    2120:	8b 81       	ldd	r24, Y+3	; 0x03
    2122:	9c 81       	ldd	r25, Y+4	; 0x04
    2124:	28 17       	cp	r18, r24
    2126:	39 07       	cpc	r19, r25
    2128:	41 f4       	brne	.+16     	; 0x213a <uxListRemove+0x6e>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    212a:	eb 81       	ldd	r30, Y+3	; 0x03
    212c:	fc 81       	ldd	r31, Y+4	; 0x04
    212e:	84 81       	ldd	r24, Z+4	; 0x04
    2130:	95 81       	ldd	r25, Z+5	; 0x05
    2132:	e9 81       	ldd	r30, Y+1	; 0x01
    2134:	fa 81       	ldd	r31, Y+2	; 0x02
    2136:	92 83       	std	Z+2, r25	; 0x02
    2138:	81 83       	std	Z+1, r24	; 0x01
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
    213a:	eb 81       	ldd	r30, Y+3	; 0x03
    213c:	fc 81       	ldd	r31, Y+4	; 0x04
    213e:	11 86       	std	Z+9, r1	; 0x09
    2140:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    2142:	e9 81       	ldd	r30, Y+1	; 0x01
    2144:	fa 81       	ldd	r31, Y+2	; 0x02
    2146:	80 81       	ld	r24, Z
    2148:	81 50       	subi	r24, 0x01	; 1
    214a:	e9 81       	ldd	r30, Y+1	; 0x01
    214c:	fa 81       	ldd	r31, Y+2	; 0x02
    214e:	80 83       	st	Z, r24

	return pxList->uxNumberOfItems;
    2150:	e9 81       	ldd	r30, Y+1	; 0x01
    2152:	fa 81       	ldd	r31, Y+2	; 0x02
    2154:	80 81       	ld	r24, Z
}
    2156:	0f 90       	pop	r0
    2158:	0f 90       	pop	r0
    215a:	0f 90       	pop	r0
    215c:	0f 90       	pop	r0
    215e:	cf 91       	pop	r28
    2160:	df 91       	pop	r29
    2162:	08 95       	ret

00002164 <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
    2164:	df 93       	push	r29
    2166:	cf 93       	push	r28
    2168:	cd b7       	in	r28, 0x3d	; 61
    216a:	de b7       	in	r29, 0x3e	; 62
    216c:	28 97       	sbiw	r28, 0x08	; 8
    216e:	0f b6       	in	r0, 0x3f	; 63
    2170:	f8 94       	cli
    2172:	de bf       	out	0x3e, r29	; 62
    2174:	0f be       	out	0x3f, r0	; 63
    2176:	cd bf       	out	0x3d, r28	; 61
    2178:	9c 83       	std	Y+4, r25	; 0x04
    217a:	8b 83       	std	Y+3, r24	; 0x03
    217c:	7e 83       	std	Y+6, r23	; 0x06
    217e:	6d 83       	std	Y+5, r22	; 0x05
    2180:	58 87       	std	Y+8, r21	; 0x08
    2182:	4f 83       	std	Y+7, r20	; 0x07
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    2184:	eb 81       	ldd	r30, Y+3	; 0x03
    2186:	fc 81       	ldd	r31, Y+4	; 0x04
    2188:	81 e1       	ldi	r24, 0x11	; 17
    218a:	80 83       	st	Z, r24
	pxTopOfStack--;
    218c:	8b 81       	ldd	r24, Y+3	; 0x03
    218e:	9c 81       	ldd	r25, Y+4	; 0x04
    2190:	01 97       	sbiw	r24, 0x01	; 1
    2192:	9c 83       	std	Y+4, r25	; 0x04
    2194:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
    2196:	eb 81       	ldd	r30, Y+3	; 0x03
    2198:	fc 81       	ldd	r31, Y+4	; 0x04
    219a:	82 e2       	ldi	r24, 0x22	; 34
    219c:	80 83       	st	Z, r24
	pxTopOfStack--;
    219e:	8b 81       	ldd	r24, Y+3	; 0x03
    21a0:	9c 81       	ldd	r25, Y+4	; 0x04
    21a2:	01 97       	sbiw	r24, 0x01	; 1
    21a4:	9c 83       	std	Y+4, r25	; 0x04
    21a6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
    21a8:	eb 81       	ldd	r30, Y+3	; 0x03
    21aa:	fc 81       	ldd	r31, Y+4	; 0x04
    21ac:	83 e3       	ldi	r24, 0x33	; 51
    21ae:	80 83       	st	Z, r24
	pxTopOfStack--;
    21b0:	8b 81       	ldd	r24, Y+3	; 0x03
    21b2:	9c 81       	ldd	r25, Y+4	; 0x04
    21b4:	01 97       	sbiw	r24, 0x01	; 1
    21b6:	9c 83       	std	Y+4, r25	; 0x04
    21b8:	8b 83       	std	Y+3, r24	; 0x03

	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
    21ba:	8d 81       	ldd	r24, Y+5	; 0x05
    21bc:	9e 81       	ldd	r25, Y+6	; 0x06
    21be:	9a 83       	std	Y+2, r25	; 0x02
    21c0:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    21c2:	89 81       	ldd	r24, Y+1	; 0x01
    21c4:	eb 81       	ldd	r30, Y+3	; 0x03
    21c6:	fc 81       	ldd	r31, Y+4	; 0x04
    21c8:	80 83       	st	Z, r24
	pxTopOfStack--;
    21ca:	8b 81       	ldd	r24, Y+3	; 0x03
    21cc:	9c 81       	ldd	r25, Y+4	; 0x04
    21ce:	01 97       	sbiw	r24, 0x01	; 1
    21d0:	9c 83       	std	Y+4, r25	; 0x04
    21d2:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    21d4:	89 81       	ldd	r24, Y+1	; 0x01
    21d6:	9a 81       	ldd	r25, Y+2	; 0x02
    21d8:	89 2f       	mov	r24, r25
    21da:	99 27       	eor	r25, r25
    21dc:	9a 83       	std	Y+2, r25	; 0x02
    21de:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    21e0:	89 81       	ldd	r24, Y+1	; 0x01
    21e2:	eb 81       	ldd	r30, Y+3	; 0x03
    21e4:	fc 81       	ldd	r31, Y+4	; 0x04
    21e6:	80 83       	st	Z, r24
	pxTopOfStack--;
    21e8:	8b 81       	ldd	r24, Y+3	; 0x03
    21ea:	9c 81       	ldd	r25, Y+4	; 0x04
    21ec:	01 97       	sbiw	r24, 0x01	; 1
    21ee:	9c 83       	std	Y+4, r25	; 0x04
    21f0:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
    21f2:	eb 81       	ldd	r30, Y+3	; 0x03
    21f4:	fc 81       	ldd	r31, Y+4	; 0x04
    21f6:	10 82       	st	Z, r1
	pxTopOfStack--;
    21f8:	8b 81       	ldd	r24, Y+3	; 0x03
    21fa:	9c 81       	ldd	r25, Y+4	; 0x04
    21fc:	01 97       	sbiw	r24, 0x01	; 1
    21fe:	9c 83       	std	Y+4, r25	; 0x04
    2200:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    2202:	eb 81       	ldd	r30, Y+3	; 0x03
    2204:	fc 81       	ldd	r31, Y+4	; 0x04
    2206:	80 e8       	ldi	r24, 0x80	; 128
    2208:	80 83       	st	Z, r24
	pxTopOfStack--;
    220a:	8b 81       	ldd	r24, Y+3	; 0x03
    220c:	9c 81       	ldd	r25, Y+4	; 0x04
    220e:	01 97       	sbiw	r24, 0x01	; 1
    2210:	9c 83       	std	Y+4, r25	; 0x04
    2212:	8b 83       	std	Y+3, r24	; 0x03


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
    2214:	eb 81       	ldd	r30, Y+3	; 0x03
    2216:	fc 81       	ldd	r31, Y+4	; 0x04
    2218:	10 82       	st	Z, r1
	pxTopOfStack--;
    221a:	8b 81       	ldd	r24, Y+3	; 0x03
    221c:	9c 81       	ldd	r25, Y+4	; 0x04
    221e:	01 97       	sbiw	r24, 0x01	; 1
    2220:	9c 83       	std	Y+4, r25	; 0x04
    2222:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
    2224:	eb 81       	ldd	r30, Y+3	; 0x03
    2226:	fc 81       	ldd	r31, Y+4	; 0x04
    2228:	82 e0       	ldi	r24, 0x02	; 2
    222a:	80 83       	st	Z, r24
	pxTopOfStack--;
    222c:	8b 81       	ldd	r24, Y+3	; 0x03
    222e:	9c 81       	ldd	r25, Y+4	; 0x04
    2230:	01 97       	sbiw	r24, 0x01	; 1
    2232:	9c 83       	std	Y+4, r25	; 0x04
    2234:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
    2236:	eb 81       	ldd	r30, Y+3	; 0x03
    2238:	fc 81       	ldd	r31, Y+4	; 0x04
    223a:	83 e0       	ldi	r24, 0x03	; 3
    223c:	80 83       	st	Z, r24
	pxTopOfStack--;
    223e:	8b 81       	ldd	r24, Y+3	; 0x03
    2240:	9c 81       	ldd	r25, Y+4	; 0x04
    2242:	01 97       	sbiw	r24, 0x01	; 1
    2244:	9c 83       	std	Y+4, r25	; 0x04
    2246:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
    2248:	eb 81       	ldd	r30, Y+3	; 0x03
    224a:	fc 81       	ldd	r31, Y+4	; 0x04
    224c:	84 e0       	ldi	r24, 0x04	; 4
    224e:	80 83       	st	Z, r24
	pxTopOfStack--;
    2250:	8b 81       	ldd	r24, Y+3	; 0x03
    2252:	9c 81       	ldd	r25, Y+4	; 0x04
    2254:	01 97       	sbiw	r24, 0x01	; 1
    2256:	9c 83       	std	Y+4, r25	; 0x04
    2258:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
    225a:	eb 81       	ldd	r30, Y+3	; 0x03
    225c:	fc 81       	ldd	r31, Y+4	; 0x04
    225e:	85 e0       	ldi	r24, 0x05	; 5
    2260:	80 83       	st	Z, r24
	pxTopOfStack--;
    2262:	8b 81       	ldd	r24, Y+3	; 0x03
    2264:	9c 81       	ldd	r25, Y+4	; 0x04
    2266:	01 97       	sbiw	r24, 0x01	; 1
    2268:	9c 83       	std	Y+4, r25	; 0x04
    226a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
    226c:	eb 81       	ldd	r30, Y+3	; 0x03
    226e:	fc 81       	ldd	r31, Y+4	; 0x04
    2270:	86 e0       	ldi	r24, 0x06	; 6
    2272:	80 83       	st	Z, r24
	pxTopOfStack--;
    2274:	8b 81       	ldd	r24, Y+3	; 0x03
    2276:	9c 81       	ldd	r25, Y+4	; 0x04
    2278:	01 97       	sbiw	r24, 0x01	; 1
    227a:	9c 83       	std	Y+4, r25	; 0x04
    227c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
    227e:	eb 81       	ldd	r30, Y+3	; 0x03
    2280:	fc 81       	ldd	r31, Y+4	; 0x04
    2282:	87 e0       	ldi	r24, 0x07	; 7
    2284:	80 83       	st	Z, r24
	pxTopOfStack--;
    2286:	8b 81       	ldd	r24, Y+3	; 0x03
    2288:	9c 81       	ldd	r25, Y+4	; 0x04
    228a:	01 97       	sbiw	r24, 0x01	; 1
    228c:	9c 83       	std	Y+4, r25	; 0x04
    228e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
    2290:	eb 81       	ldd	r30, Y+3	; 0x03
    2292:	fc 81       	ldd	r31, Y+4	; 0x04
    2294:	88 e0       	ldi	r24, 0x08	; 8
    2296:	80 83       	st	Z, r24
	pxTopOfStack--;
    2298:	8b 81       	ldd	r24, Y+3	; 0x03
    229a:	9c 81       	ldd	r25, Y+4	; 0x04
    229c:	01 97       	sbiw	r24, 0x01	; 1
    229e:	9c 83       	std	Y+4, r25	; 0x04
    22a0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
    22a2:	eb 81       	ldd	r30, Y+3	; 0x03
    22a4:	fc 81       	ldd	r31, Y+4	; 0x04
    22a6:	89 e0       	ldi	r24, 0x09	; 9
    22a8:	80 83       	st	Z, r24
	pxTopOfStack--;
    22aa:	8b 81       	ldd	r24, Y+3	; 0x03
    22ac:	9c 81       	ldd	r25, Y+4	; 0x04
    22ae:	01 97       	sbiw	r24, 0x01	; 1
    22b0:	9c 83       	std	Y+4, r25	; 0x04
    22b2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
    22b4:	eb 81       	ldd	r30, Y+3	; 0x03
    22b6:	fc 81       	ldd	r31, Y+4	; 0x04
    22b8:	80 e1       	ldi	r24, 0x10	; 16
    22ba:	80 83       	st	Z, r24
	pxTopOfStack--;
    22bc:	8b 81       	ldd	r24, Y+3	; 0x03
    22be:	9c 81       	ldd	r25, Y+4	; 0x04
    22c0:	01 97       	sbiw	r24, 0x01	; 1
    22c2:	9c 83       	std	Y+4, r25	; 0x04
    22c4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
    22c6:	eb 81       	ldd	r30, Y+3	; 0x03
    22c8:	fc 81       	ldd	r31, Y+4	; 0x04
    22ca:	81 e1       	ldi	r24, 0x11	; 17
    22cc:	80 83       	st	Z, r24
	pxTopOfStack--;
    22ce:	8b 81       	ldd	r24, Y+3	; 0x03
    22d0:	9c 81       	ldd	r25, Y+4	; 0x04
    22d2:	01 97       	sbiw	r24, 0x01	; 1
    22d4:	9c 83       	std	Y+4, r25	; 0x04
    22d6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
    22d8:	eb 81       	ldd	r30, Y+3	; 0x03
    22da:	fc 81       	ldd	r31, Y+4	; 0x04
    22dc:	82 e1       	ldi	r24, 0x12	; 18
    22de:	80 83       	st	Z, r24
	pxTopOfStack--;
    22e0:	8b 81       	ldd	r24, Y+3	; 0x03
    22e2:	9c 81       	ldd	r25, Y+4	; 0x04
    22e4:	01 97       	sbiw	r24, 0x01	; 1
    22e6:	9c 83       	std	Y+4, r25	; 0x04
    22e8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
    22ea:	eb 81       	ldd	r30, Y+3	; 0x03
    22ec:	fc 81       	ldd	r31, Y+4	; 0x04
    22ee:	83 e1       	ldi	r24, 0x13	; 19
    22f0:	80 83       	st	Z, r24
	pxTopOfStack--;
    22f2:	8b 81       	ldd	r24, Y+3	; 0x03
    22f4:	9c 81       	ldd	r25, Y+4	; 0x04
    22f6:	01 97       	sbiw	r24, 0x01	; 1
    22f8:	9c 83       	std	Y+4, r25	; 0x04
    22fa:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
    22fc:	eb 81       	ldd	r30, Y+3	; 0x03
    22fe:	fc 81       	ldd	r31, Y+4	; 0x04
    2300:	84 e1       	ldi	r24, 0x14	; 20
    2302:	80 83       	st	Z, r24
	pxTopOfStack--;
    2304:	8b 81       	ldd	r24, Y+3	; 0x03
    2306:	9c 81       	ldd	r25, Y+4	; 0x04
    2308:	01 97       	sbiw	r24, 0x01	; 1
    230a:	9c 83       	std	Y+4, r25	; 0x04
    230c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
    230e:	eb 81       	ldd	r30, Y+3	; 0x03
    2310:	fc 81       	ldd	r31, Y+4	; 0x04
    2312:	85 e1       	ldi	r24, 0x15	; 21
    2314:	80 83       	st	Z, r24
	pxTopOfStack--;
    2316:	8b 81       	ldd	r24, Y+3	; 0x03
    2318:	9c 81       	ldd	r25, Y+4	; 0x04
    231a:	01 97       	sbiw	r24, 0x01	; 1
    231c:	9c 83       	std	Y+4, r25	; 0x04
    231e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
    2320:	eb 81       	ldd	r30, Y+3	; 0x03
    2322:	fc 81       	ldd	r31, Y+4	; 0x04
    2324:	86 e1       	ldi	r24, 0x16	; 22
    2326:	80 83       	st	Z, r24
	pxTopOfStack--;
    2328:	8b 81       	ldd	r24, Y+3	; 0x03
    232a:	9c 81       	ldd	r25, Y+4	; 0x04
    232c:	01 97       	sbiw	r24, 0x01	; 1
    232e:	9c 83       	std	Y+4, r25	; 0x04
    2330:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
    2332:	eb 81       	ldd	r30, Y+3	; 0x03
    2334:	fc 81       	ldd	r31, Y+4	; 0x04
    2336:	87 e1       	ldi	r24, 0x17	; 23
    2338:	80 83       	st	Z, r24
	pxTopOfStack--;
    233a:	8b 81       	ldd	r24, Y+3	; 0x03
    233c:	9c 81       	ldd	r25, Y+4	; 0x04
    233e:	01 97       	sbiw	r24, 0x01	; 1
    2340:	9c 83       	std	Y+4, r25	; 0x04
    2342:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
    2344:	eb 81       	ldd	r30, Y+3	; 0x03
    2346:	fc 81       	ldd	r31, Y+4	; 0x04
    2348:	88 e1       	ldi	r24, 0x18	; 24
    234a:	80 83       	st	Z, r24
	pxTopOfStack--;
    234c:	8b 81       	ldd	r24, Y+3	; 0x03
    234e:	9c 81       	ldd	r25, Y+4	; 0x04
    2350:	01 97       	sbiw	r24, 0x01	; 1
    2352:	9c 83       	std	Y+4, r25	; 0x04
    2354:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
    2356:	eb 81       	ldd	r30, Y+3	; 0x03
    2358:	fc 81       	ldd	r31, Y+4	; 0x04
    235a:	89 e1       	ldi	r24, 0x19	; 25
    235c:	80 83       	st	Z, r24
	pxTopOfStack--;
    235e:	8b 81       	ldd	r24, Y+3	; 0x03
    2360:	9c 81       	ldd	r25, Y+4	; 0x04
    2362:	01 97       	sbiw	r24, 0x01	; 1
    2364:	9c 83       	std	Y+4, r25	; 0x04
    2366:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
    2368:	eb 81       	ldd	r30, Y+3	; 0x03
    236a:	fc 81       	ldd	r31, Y+4	; 0x04
    236c:	80 e2       	ldi	r24, 0x20	; 32
    236e:	80 83       	st	Z, r24
	pxTopOfStack--;
    2370:	8b 81       	ldd	r24, Y+3	; 0x03
    2372:	9c 81       	ldd	r25, Y+4	; 0x04
    2374:	01 97       	sbiw	r24, 0x01	; 1
    2376:	9c 83       	std	Y+4, r25	; 0x04
    2378:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
    237a:	eb 81       	ldd	r30, Y+3	; 0x03
    237c:	fc 81       	ldd	r31, Y+4	; 0x04
    237e:	81 e2       	ldi	r24, 0x21	; 33
    2380:	80 83       	st	Z, r24
	pxTopOfStack--;
    2382:	8b 81       	ldd	r24, Y+3	; 0x03
    2384:	9c 81       	ldd	r25, Y+4	; 0x04
    2386:	01 97       	sbiw	r24, 0x01	; 1
    2388:	9c 83       	std	Y+4, r25	; 0x04
    238a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
    238c:	eb 81       	ldd	r30, Y+3	; 0x03
    238e:	fc 81       	ldd	r31, Y+4	; 0x04
    2390:	82 e2       	ldi	r24, 0x22	; 34
    2392:	80 83       	st	Z, r24
	pxTopOfStack--;
    2394:	8b 81       	ldd	r24, Y+3	; 0x03
    2396:	9c 81       	ldd	r25, Y+4	; 0x04
    2398:	01 97       	sbiw	r24, 0x01	; 1
    239a:	9c 83       	std	Y+4, r25	; 0x04
    239c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
    239e:	eb 81       	ldd	r30, Y+3	; 0x03
    23a0:	fc 81       	ldd	r31, Y+4	; 0x04
    23a2:	83 e2       	ldi	r24, 0x23	; 35
    23a4:	80 83       	st	Z, r24
	pxTopOfStack--;
    23a6:	8b 81       	ldd	r24, Y+3	; 0x03
    23a8:	9c 81       	ldd	r25, Y+4	; 0x04
    23aa:	01 97       	sbiw	r24, 0x01	; 1
    23ac:	9c 83       	std	Y+4, r25	; 0x04
    23ae:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
    23b0:	8f 81       	ldd	r24, Y+7	; 0x07
    23b2:	98 85       	ldd	r25, Y+8	; 0x08
    23b4:	9a 83       	std	Y+2, r25	; 0x02
    23b6:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    23b8:	89 81       	ldd	r24, Y+1	; 0x01
    23ba:	eb 81       	ldd	r30, Y+3	; 0x03
    23bc:	fc 81       	ldd	r31, Y+4	; 0x04
    23be:	80 83       	st	Z, r24
	pxTopOfStack--;
    23c0:	8b 81       	ldd	r24, Y+3	; 0x03
    23c2:	9c 81       	ldd	r25, Y+4	; 0x04
    23c4:	01 97       	sbiw	r24, 0x01	; 1
    23c6:	9c 83       	std	Y+4, r25	; 0x04
    23c8:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    23ca:	89 81       	ldd	r24, Y+1	; 0x01
    23cc:	9a 81       	ldd	r25, Y+2	; 0x02
    23ce:	89 2f       	mov	r24, r25
    23d0:	99 27       	eor	r25, r25
    23d2:	9a 83       	std	Y+2, r25	; 0x02
    23d4:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    23d6:	89 81       	ldd	r24, Y+1	; 0x01
    23d8:	eb 81       	ldd	r30, Y+3	; 0x03
    23da:	fc 81       	ldd	r31, Y+4	; 0x04
    23dc:	80 83       	st	Z, r24
	pxTopOfStack--;
    23de:	8b 81       	ldd	r24, Y+3	; 0x03
    23e0:	9c 81       	ldd	r25, Y+4	; 0x04
    23e2:	01 97       	sbiw	r24, 0x01	; 1
    23e4:	9c 83       	std	Y+4, r25	; 0x04
    23e6:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
    23e8:	eb 81       	ldd	r30, Y+3	; 0x03
    23ea:	fc 81       	ldd	r31, Y+4	; 0x04
    23ec:	86 e2       	ldi	r24, 0x26	; 38
    23ee:	80 83       	st	Z, r24
	pxTopOfStack--;
    23f0:	8b 81       	ldd	r24, Y+3	; 0x03
    23f2:	9c 81       	ldd	r25, Y+4	; 0x04
    23f4:	01 97       	sbiw	r24, 0x01	; 1
    23f6:	9c 83       	std	Y+4, r25	; 0x04
    23f8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
    23fa:	eb 81       	ldd	r30, Y+3	; 0x03
    23fc:	fc 81       	ldd	r31, Y+4	; 0x04
    23fe:	87 e2       	ldi	r24, 0x27	; 39
    2400:	80 83       	st	Z, r24
	pxTopOfStack--;
    2402:	8b 81       	ldd	r24, Y+3	; 0x03
    2404:	9c 81       	ldd	r25, Y+4	; 0x04
    2406:	01 97       	sbiw	r24, 0x01	; 1
    2408:	9c 83       	std	Y+4, r25	; 0x04
    240a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
    240c:	eb 81       	ldd	r30, Y+3	; 0x03
    240e:	fc 81       	ldd	r31, Y+4	; 0x04
    2410:	88 e2       	ldi	r24, 0x28	; 40
    2412:	80 83       	st	Z, r24
	pxTopOfStack--;
    2414:	8b 81       	ldd	r24, Y+3	; 0x03
    2416:	9c 81       	ldd	r25, Y+4	; 0x04
    2418:	01 97       	sbiw	r24, 0x01	; 1
    241a:	9c 83       	std	Y+4, r25	; 0x04
    241c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
    241e:	eb 81       	ldd	r30, Y+3	; 0x03
    2420:	fc 81       	ldd	r31, Y+4	; 0x04
    2422:	89 e2       	ldi	r24, 0x29	; 41
    2424:	80 83       	st	Z, r24
	pxTopOfStack--;
    2426:	8b 81       	ldd	r24, Y+3	; 0x03
    2428:	9c 81       	ldd	r25, Y+4	; 0x04
    242a:	01 97       	sbiw	r24, 0x01	; 1
    242c:	9c 83       	std	Y+4, r25	; 0x04
    242e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
    2430:	eb 81       	ldd	r30, Y+3	; 0x03
    2432:	fc 81       	ldd	r31, Y+4	; 0x04
    2434:	80 e3       	ldi	r24, 0x30	; 48
    2436:	80 83       	st	Z, r24
	pxTopOfStack--;
    2438:	8b 81       	ldd	r24, Y+3	; 0x03
    243a:	9c 81       	ldd	r25, Y+4	; 0x04
    243c:	01 97       	sbiw	r24, 0x01	; 1
    243e:	9c 83       	std	Y+4, r25	; 0x04
    2440:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
    2442:	eb 81       	ldd	r30, Y+3	; 0x03
    2444:	fc 81       	ldd	r31, Y+4	; 0x04
    2446:	81 e3       	ldi	r24, 0x31	; 49
    2448:	80 83       	st	Z, r24
	pxTopOfStack--;
    244a:	8b 81       	ldd	r24, Y+3	; 0x03
    244c:	9c 81       	ldd	r25, Y+4	; 0x04
    244e:	01 97       	sbiw	r24, 0x01	; 1
    2450:	9c 83       	std	Y+4, r25	; 0x04
    2452:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
    2454:	8b 81       	ldd	r24, Y+3	; 0x03
    2456:	9c 81       	ldd	r25, Y+4	; 0x04
}
    2458:	28 96       	adiw	r28, 0x08	; 8
    245a:	0f b6       	in	r0, 0x3f	; 63
    245c:	f8 94       	cli
    245e:	de bf       	out	0x3e, r29	; 62
    2460:	0f be       	out	0x3f, r0	; 63
    2462:	cd bf       	out	0x3d, r28	; 61
    2464:	cf 91       	pop	r28
    2466:	df 91       	pop	r29
    2468:	08 95       	ret

0000246a <xPortStartScheduler>:
/*-----------------------------------------------------------*/

BaseType_t xPortStartScheduler( void )
{
    246a:	df 93       	push	r29
    246c:	cf 93       	push	r28
    246e:	cd b7       	in	r28, 0x3d	; 61
    2470:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
    2472:	0e 94 27 13 	call	0x264e	; 0x264e <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    2476:	a0 91 c9 06 	lds	r26, 0x06C9
    247a:	b0 91 ca 06 	lds	r27, 0x06CA
    247e:	cd 91       	ld	r28, X+
    2480:	cd bf       	out	0x3d, r28	; 61
    2482:	dd 91       	ld	r29, X+
    2484:	de bf       	out	0x3e, r29	; 62
    2486:	ff 91       	pop	r31
    2488:	ef 91       	pop	r30
    248a:	df 91       	pop	r29
    248c:	cf 91       	pop	r28
    248e:	bf 91       	pop	r27
    2490:	af 91       	pop	r26
    2492:	9f 91       	pop	r25
    2494:	8f 91       	pop	r24
    2496:	7f 91       	pop	r23
    2498:	6f 91       	pop	r22
    249a:	5f 91       	pop	r21
    249c:	4f 91       	pop	r20
    249e:	3f 91       	pop	r19
    24a0:	2f 91       	pop	r18
    24a2:	1f 91       	pop	r17
    24a4:	0f 91       	pop	r16
    24a6:	ff 90       	pop	r15
    24a8:	ef 90       	pop	r14
    24aa:	df 90       	pop	r13
    24ac:	cf 90       	pop	r12
    24ae:	bf 90       	pop	r11
    24b0:	af 90       	pop	r10
    24b2:	9f 90       	pop	r9
    24b4:	8f 90       	pop	r8
    24b6:	7f 90       	pop	r7
    24b8:	6f 90       	pop	r6
    24ba:	5f 90       	pop	r5
    24bc:	4f 90       	pop	r4
    24be:	3f 90       	pop	r3
    24c0:	2f 90       	pop	r2
    24c2:	1f 90       	pop	r1
    24c4:	0f 90       	pop	r0
    24c6:	0f be       	out	0x3f, r0	; 63
    24c8:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    24ca:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
    24cc:	81 e0       	ldi	r24, 0x01	; 1
}
    24ce:	cf 91       	pop	r28
    24d0:	df 91       	pop	r29
    24d2:	08 95       	ret

000024d4 <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    24d4:	df 93       	push	r29
    24d6:	cf 93       	push	r28
    24d8:	cd b7       	in	r28, 0x3d	; 61
    24da:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    24dc:	cf 91       	pop	r28
    24de:	df 91       	pop	r29
    24e0:	08 95       	ret

000024e2 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    24e2:	0f 92       	push	r0
    24e4:	0f b6       	in	r0, 0x3f	; 63
    24e6:	f8 94       	cli
    24e8:	0f 92       	push	r0
    24ea:	1f 92       	push	r1
    24ec:	11 24       	eor	r1, r1
    24ee:	2f 92       	push	r2
    24f0:	3f 92       	push	r3
    24f2:	4f 92       	push	r4
    24f4:	5f 92       	push	r5
    24f6:	6f 92       	push	r6
    24f8:	7f 92       	push	r7
    24fa:	8f 92       	push	r8
    24fc:	9f 92       	push	r9
    24fe:	af 92       	push	r10
    2500:	bf 92       	push	r11
    2502:	cf 92       	push	r12
    2504:	df 92       	push	r13
    2506:	ef 92       	push	r14
    2508:	ff 92       	push	r15
    250a:	0f 93       	push	r16
    250c:	1f 93       	push	r17
    250e:	2f 93       	push	r18
    2510:	3f 93       	push	r19
    2512:	4f 93       	push	r20
    2514:	5f 93       	push	r21
    2516:	6f 93       	push	r22
    2518:	7f 93       	push	r23
    251a:	8f 93       	push	r24
    251c:	9f 93       	push	r25
    251e:	af 93       	push	r26
    2520:	bf 93       	push	r27
    2522:	cf 93       	push	r28
    2524:	df 93       	push	r29
    2526:	ef 93       	push	r30
    2528:	ff 93       	push	r31
    252a:	a0 91 c9 06 	lds	r26, 0x06C9
    252e:	b0 91 ca 06 	lds	r27, 0x06CA
    2532:	0d b6       	in	r0, 0x3d	; 61
    2534:	0d 92       	st	X+, r0
    2536:	0e b6       	in	r0, 0x3e	; 62
    2538:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    253a:	0e 94 12 20 	call	0x4024	; 0x4024 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    253e:	a0 91 c9 06 	lds	r26, 0x06C9
    2542:	b0 91 ca 06 	lds	r27, 0x06CA
    2546:	cd 91       	ld	r28, X+
    2548:	cd bf       	out	0x3d, r28	; 61
    254a:	dd 91       	ld	r29, X+
    254c:	de bf       	out	0x3e, r29	; 62
    254e:	ff 91       	pop	r31
    2550:	ef 91       	pop	r30
    2552:	df 91       	pop	r29
    2554:	cf 91       	pop	r28
    2556:	bf 91       	pop	r27
    2558:	af 91       	pop	r26
    255a:	9f 91       	pop	r25
    255c:	8f 91       	pop	r24
    255e:	7f 91       	pop	r23
    2560:	6f 91       	pop	r22
    2562:	5f 91       	pop	r21
    2564:	4f 91       	pop	r20
    2566:	3f 91       	pop	r19
    2568:	2f 91       	pop	r18
    256a:	1f 91       	pop	r17
    256c:	0f 91       	pop	r16
    256e:	ff 90       	pop	r15
    2570:	ef 90       	pop	r14
    2572:	df 90       	pop	r13
    2574:	cf 90       	pop	r12
    2576:	bf 90       	pop	r11
    2578:	af 90       	pop	r10
    257a:	9f 90       	pop	r9
    257c:	8f 90       	pop	r8
    257e:	7f 90       	pop	r7
    2580:	6f 90       	pop	r6
    2582:	5f 90       	pop	r5
    2584:	4f 90       	pop	r4
    2586:	3f 90       	pop	r3
    2588:	2f 90       	pop	r2
    258a:	1f 90       	pop	r1
    258c:	0f 90       	pop	r0
    258e:	0f be       	out	0x3f, r0	; 63
    2590:	0f 90       	pop	r0

	asm volatile ( "ret" );
    2592:	08 95       	ret

00002594 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    2594:	0f 92       	push	r0
    2596:	0f b6       	in	r0, 0x3f	; 63
    2598:	f8 94       	cli
    259a:	0f 92       	push	r0
    259c:	1f 92       	push	r1
    259e:	11 24       	eor	r1, r1
    25a0:	2f 92       	push	r2
    25a2:	3f 92       	push	r3
    25a4:	4f 92       	push	r4
    25a6:	5f 92       	push	r5
    25a8:	6f 92       	push	r6
    25aa:	7f 92       	push	r7
    25ac:	8f 92       	push	r8
    25ae:	9f 92       	push	r9
    25b0:	af 92       	push	r10
    25b2:	bf 92       	push	r11
    25b4:	cf 92       	push	r12
    25b6:	df 92       	push	r13
    25b8:	ef 92       	push	r14
    25ba:	ff 92       	push	r15
    25bc:	0f 93       	push	r16
    25be:	1f 93       	push	r17
    25c0:	2f 93       	push	r18
    25c2:	3f 93       	push	r19
    25c4:	4f 93       	push	r20
    25c6:	5f 93       	push	r21
    25c8:	6f 93       	push	r22
    25ca:	7f 93       	push	r23
    25cc:	8f 93       	push	r24
    25ce:	9f 93       	push	r25
    25d0:	af 93       	push	r26
    25d2:	bf 93       	push	r27
    25d4:	cf 93       	push	r28
    25d6:	df 93       	push	r29
    25d8:	ef 93       	push	r30
    25da:	ff 93       	push	r31
    25dc:	a0 91 c9 06 	lds	r26, 0x06C9
    25e0:	b0 91 ca 06 	lds	r27, 0x06CA
    25e4:	0d b6       	in	r0, 0x3d	; 61
    25e6:	0d 92       	st	X+, r0
    25e8:	0e b6       	in	r0, 0x3e	; 62
    25ea:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    25ec:	0e 94 2b 1f 	call	0x3e56	; 0x3e56 <xTaskIncrementTick>
    25f0:	88 23       	and	r24, r24
    25f2:	11 f0       	breq	.+4      	; 0x25f8 <vPortYieldFromTick+0x64>
	{
		vTaskSwitchContext();
    25f4:	0e 94 12 20 	call	0x4024	; 0x4024 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
    25f8:	a0 91 c9 06 	lds	r26, 0x06C9
    25fc:	b0 91 ca 06 	lds	r27, 0x06CA
    2600:	cd 91       	ld	r28, X+
    2602:	cd bf       	out	0x3d, r28	; 61
    2604:	dd 91       	ld	r29, X+
    2606:	de bf       	out	0x3e, r29	; 62
    2608:	ff 91       	pop	r31
    260a:	ef 91       	pop	r30
    260c:	df 91       	pop	r29
    260e:	cf 91       	pop	r28
    2610:	bf 91       	pop	r27
    2612:	af 91       	pop	r26
    2614:	9f 91       	pop	r25
    2616:	8f 91       	pop	r24
    2618:	7f 91       	pop	r23
    261a:	6f 91       	pop	r22
    261c:	5f 91       	pop	r21
    261e:	4f 91       	pop	r20
    2620:	3f 91       	pop	r19
    2622:	2f 91       	pop	r18
    2624:	1f 91       	pop	r17
    2626:	0f 91       	pop	r16
    2628:	ff 90       	pop	r15
    262a:	ef 90       	pop	r14
    262c:	df 90       	pop	r13
    262e:	cf 90       	pop	r12
    2630:	bf 90       	pop	r11
    2632:	af 90       	pop	r10
    2634:	9f 90       	pop	r9
    2636:	8f 90       	pop	r8
    2638:	7f 90       	pop	r7
    263a:	6f 90       	pop	r6
    263c:	5f 90       	pop	r5
    263e:	4f 90       	pop	r4
    2640:	3f 90       	pop	r3
    2642:	2f 90       	pop	r2
    2644:	1f 90       	pop	r1
    2646:	0f 90       	pop	r0
    2648:	0f be       	out	0x3f, r0	; 63
    264a:	0f 90       	pop	r0

	asm volatile ( "ret" );
    264c:	08 95       	ret

0000264e <prvSetupTimerInterrupt>:

/*
 * Setup timer 1 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
    264e:	df 93       	push	r29
    2650:	cf 93       	push	r28
    2652:	00 d0       	rcall	.+0      	; 0x2654 <prvSetupTimerInterrupt+0x6>
    2654:	00 d0       	rcall	.+0      	; 0x2656 <prvSetupTimerInterrupt+0x8>
    2656:	00 d0       	rcall	.+0      	; 0x2658 <prvSetupTimerInterrupt+0xa>
    2658:	cd b7       	in	r28, 0x3d	; 61
    265a:	de b7       	in	r29, 0x3e	; 62
uint8_t ucHighByte, ucLowByte;

	/* Using 16bit timer 1 to generate the tick.  Correct fuses must be
	selected for the configCPU_CLOCK_HZ clock. */

	ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
    265c:	80 e4       	ldi	r24, 0x40	; 64
    265e:	9f e1       	ldi	r25, 0x1F	; 31
    2660:	a0 e0       	ldi	r26, 0x00	; 0
    2662:	b0 e0       	ldi	r27, 0x00	; 0
    2664:	8b 83       	std	Y+3, r24	; 0x03
    2666:	9c 83       	std	Y+4, r25	; 0x04
    2668:	ad 83       	std	Y+5, r26	; 0x05
    266a:	be 83       	std	Y+6, r27	; 0x06

	/* We only have 16 bits so have to scale to get our required tick rate. */
	ulCompareMatch /= portCLOCK_PRESCALER;
    266c:	8b 81       	ldd	r24, Y+3	; 0x03
    266e:	9c 81       	ldd	r25, Y+4	; 0x04
    2670:	ad 81       	ldd	r26, Y+5	; 0x05
    2672:	be 81       	ldd	r27, Y+6	; 0x06
    2674:	68 94       	set
    2676:	15 f8       	bld	r1, 5
    2678:	b6 95       	lsr	r27
    267a:	a7 95       	ror	r26
    267c:	97 95       	ror	r25
    267e:	87 95       	ror	r24
    2680:	16 94       	lsr	r1
    2682:	d1 f7       	brne	.-12     	; 0x2678 <prvSetupTimerInterrupt+0x2a>
    2684:	8b 83       	std	Y+3, r24	; 0x03
    2686:	9c 83       	std	Y+4, r25	; 0x04
    2688:	ad 83       	std	Y+5, r26	; 0x05
    268a:	be 83       	std	Y+6, r27	; 0x06

	/* Adjust for correct value. */
	ulCompareMatch -= ( uint32_t ) 1;
    268c:	8b 81       	ldd	r24, Y+3	; 0x03
    268e:	9c 81       	ldd	r25, Y+4	; 0x04
    2690:	ad 81       	ldd	r26, Y+5	; 0x05
    2692:	be 81       	ldd	r27, Y+6	; 0x06
    2694:	01 97       	sbiw	r24, 0x01	; 1
    2696:	a1 09       	sbc	r26, r1
    2698:	b1 09       	sbc	r27, r1
    269a:	8b 83       	std	Y+3, r24	; 0x03
    269c:	9c 83       	std	Y+4, r25	; 0x04
    269e:	ad 83       	std	Y+5, r26	; 0x05
    26a0:	be 83       	std	Y+6, r27	; 0x06

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
    26a2:	8b 81       	ldd	r24, Y+3	; 0x03
    26a4:	89 83       	std	Y+1, r24	; 0x01
	ulCompareMatch >>= 8;
    26a6:	8b 81       	ldd	r24, Y+3	; 0x03
    26a8:	9c 81       	ldd	r25, Y+4	; 0x04
    26aa:	ad 81       	ldd	r26, Y+5	; 0x05
    26ac:	be 81       	ldd	r27, Y+6	; 0x06
    26ae:	89 2f       	mov	r24, r25
    26b0:	9a 2f       	mov	r25, r26
    26b2:	ab 2f       	mov	r26, r27
    26b4:	bb 27       	eor	r27, r27
    26b6:	8b 83       	std	Y+3, r24	; 0x03
    26b8:	9c 83       	std	Y+4, r25	; 0x04
    26ba:	ad 83       	std	Y+5, r26	; 0x05
    26bc:	be 83       	std	Y+6, r27	; 0x06
	ucHighByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
    26be:	8b 81       	ldd	r24, Y+3	; 0x03
    26c0:	8a 83       	std	Y+2, r24	; 0x02
	OCR1AH = ucHighByte;
    26c2:	eb e4       	ldi	r30, 0x4B	; 75
    26c4:	f0 e0       	ldi	r31, 0x00	; 0
    26c6:	8a 81       	ldd	r24, Y+2	; 0x02
    26c8:	80 83       	st	Z, r24
	OCR1AL = ucLowByte;
    26ca:	ea e4       	ldi	r30, 0x4A	; 74
    26cc:	f0 e0       	ldi	r31, 0x00	; 0
    26ce:	89 81       	ldd	r24, Y+1	; 0x01
    26d0:	80 83       	st	Z, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
    26d2:	8b e0       	ldi	r24, 0x0B	; 11
    26d4:	89 83       	std	Y+1, r24	; 0x01
	TCCR1B = ucLowByte;
    26d6:	ee e4       	ldi	r30, 0x4E	; 78
    26d8:	f0 e0       	ldi	r31, 0x00	; 0
    26da:	89 81       	ldd	r24, Y+1	; 0x01
    26dc:	80 83       	st	Z, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
    26de:	e9 e5       	ldi	r30, 0x59	; 89
    26e0:	f0 e0       	ldi	r31, 0x00	; 0
    26e2:	80 81       	ld	r24, Z
    26e4:	89 83       	std	Y+1, r24	; 0x01
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    26e6:	89 81       	ldd	r24, Y+1	; 0x01
    26e8:	80 61       	ori	r24, 0x10	; 16
    26ea:	89 83       	std	Y+1, r24	; 0x01
	TIMSK = ucLowByte;
    26ec:	e9 e5       	ldi	r30, 0x59	; 89
    26ee:	f0 e0       	ldi	r31, 0x00	; 0
    26f0:	89 81       	ldd	r24, Y+1	; 0x01
    26f2:	80 83       	st	Z, r24
}
    26f4:	26 96       	adiw	r28, 0x06	; 6
    26f6:	0f b6       	in	r0, 0x3f	; 63
    26f8:	f8 94       	cli
    26fa:	de bf       	out	0x3e, r29	; 62
    26fc:	0f be       	out	0x3f, r0	; 63
    26fe:	cd bf       	out	0x3d, r28	; 61
    2700:	cf 91       	pop	r28
    2702:	df 91       	pop	r29
    2704:	08 95       	ret

00002706 <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
    2706:	0e 94 ca 12 	call	0x2594	; 0x2594 <vPortYieldFromTick>
		asm volatile ( "reti" );
    270a:	18 95       	reti

0000270c <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
    270c:	df 93       	push	r29
    270e:	cf 93       	push	r28
    2710:	00 d0       	rcall	.+0      	; 0x2712 <xQueueGenericReset+0x6>
    2712:	00 d0       	rcall	.+0      	; 0x2714 <xQueueGenericReset+0x8>
    2714:	0f 92       	push	r0
    2716:	cd b7       	in	r28, 0x3d	; 61
    2718:	de b7       	in	r29, 0x3e	; 62
    271a:	9c 83       	std	Y+4, r25	; 0x04
    271c:	8b 83       	std	Y+3, r24	; 0x03
    271e:	6d 83       	std	Y+5, r22	; 0x05
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    2720:	8b 81       	ldd	r24, Y+3	; 0x03
    2722:	9c 81       	ldd	r25, Y+4	; 0x04
    2724:	9a 83       	std	Y+2, r25	; 0x02
    2726:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    2728:	0f b6       	in	r0, 0x3f	; 63
    272a:	f8 94       	cli
    272c:	0f 92       	push	r0
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
    272e:	e9 81       	ldd	r30, Y+1	; 0x01
    2730:	fa 81       	ldd	r31, Y+2	; 0x02
    2732:	40 81       	ld	r20, Z
    2734:	51 81       	ldd	r21, Z+1	; 0x01
    2736:	e9 81       	ldd	r30, Y+1	; 0x01
    2738:	fa 81       	ldd	r31, Y+2	; 0x02
    273a:	83 8d       	ldd	r24, Z+27	; 0x1b
    273c:	28 2f       	mov	r18, r24
    273e:	30 e0       	ldi	r19, 0x00	; 0
    2740:	e9 81       	ldd	r30, Y+1	; 0x01
    2742:	fa 81       	ldd	r31, Y+2	; 0x02
    2744:	84 8d       	ldd	r24, Z+28	; 0x1c
    2746:	88 2f       	mov	r24, r24
    2748:	90 e0       	ldi	r25, 0x00	; 0
    274a:	bc 01       	movw	r22, r24
    274c:	26 9f       	mul	r18, r22
    274e:	c0 01       	movw	r24, r0
    2750:	27 9f       	mul	r18, r23
    2752:	90 0d       	add	r25, r0
    2754:	36 9f       	mul	r19, r22
    2756:	90 0d       	add	r25, r0
    2758:	11 24       	eor	r1, r1
    275a:	84 0f       	add	r24, r20
    275c:	95 1f       	adc	r25, r21
    275e:	e9 81       	ldd	r30, Y+1	; 0x01
    2760:	fa 81       	ldd	r31, Y+2	; 0x02
    2762:	93 83       	std	Z+3, r25	; 0x03
    2764:	82 83       	std	Z+2, r24	; 0x02
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    2766:	e9 81       	ldd	r30, Y+1	; 0x01
    2768:	fa 81       	ldd	r31, Y+2	; 0x02
    276a:	12 8e       	std	Z+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
    276c:	e9 81       	ldd	r30, Y+1	; 0x01
    276e:	fa 81       	ldd	r31, Y+2	; 0x02
    2770:	80 81       	ld	r24, Z
    2772:	91 81       	ldd	r25, Z+1	; 0x01
    2774:	e9 81       	ldd	r30, Y+1	; 0x01
    2776:	fa 81       	ldd	r31, Y+2	; 0x02
    2778:	95 83       	std	Z+5, r25	; 0x05
    277a:	84 83       	std	Z+4, r24	; 0x04
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
    277c:	e9 81       	ldd	r30, Y+1	; 0x01
    277e:	fa 81       	ldd	r31, Y+2	; 0x02
    2780:	40 81       	ld	r20, Z
    2782:	51 81       	ldd	r21, Z+1	; 0x01
    2784:	e9 81       	ldd	r30, Y+1	; 0x01
    2786:	fa 81       	ldd	r31, Y+2	; 0x02
    2788:	83 8d       	ldd	r24, Z+27	; 0x1b
    278a:	88 2f       	mov	r24, r24
    278c:	90 e0       	ldi	r25, 0x00	; 0
    278e:	9c 01       	movw	r18, r24
    2790:	21 50       	subi	r18, 0x01	; 1
    2792:	30 40       	sbci	r19, 0x00	; 0
    2794:	e9 81       	ldd	r30, Y+1	; 0x01
    2796:	fa 81       	ldd	r31, Y+2	; 0x02
    2798:	84 8d       	ldd	r24, Z+28	; 0x1c
    279a:	88 2f       	mov	r24, r24
    279c:	90 e0       	ldi	r25, 0x00	; 0
    279e:	bc 01       	movw	r22, r24
    27a0:	26 9f       	mul	r18, r22
    27a2:	c0 01       	movw	r24, r0
    27a4:	27 9f       	mul	r18, r23
    27a6:	90 0d       	add	r25, r0
    27a8:	36 9f       	mul	r19, r22
    27aa:	90 0d       	add	r25, r0
    27ac:	11 24       	eor	r1, r1
    27ae:	84 0f       	add	r24, r20
    27b0:	95 1f       	adc	r25, r21
    27b2:	e9 81       	ldd	r30, Y+1	; 0x01
    27b4:	fa 81       	ldd	r31, Y+2	; 0x02
    27b6:	97 83       	std	Z+7, r25	; 0x07
    27b8:	86 83       	std	Z+6, r24	; 0x06
		pxQueue->xRxLock = queueUNLOCKED;
    27ba:	e9 81       	ldd	r30, Y+1	; 0x01
    27bc:	fa 81       	ldd	r31, Y+2	; 0x02
    27be:	8f ef       	ldi	r24, 0xFF	; 255
    27c0:	85 8f       	std	Z+29, r24	; 0x1d
		pxQueue->xTxLock = queueUNLOCKED;
    27c2:	e9 81       	ldd	r30, Y+1	; 0x01
    27c4:	fa 81       	ldd	r31, Y+2	; 0x02
    27c6:	8f ef       	ldi	r24, 0xFF	; 255
    27c8:	86 8f       	std	Z+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
    27ca:	8d 81       	ldd	r24, Y+5	; 0x05
    27cc:	88 23       	and	r24, r24
    27ce:	79 f4       	brne	.+30     	; 0x27ee <xQueueGenericReset+0xe2>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    27d0:	e9 81       	ldd	r30, Y+1	; 0x01
    27d2:	fa 81       	ldd	r31, Y+2	; 0x02
    27d4:	80 85       	ldd	r24, Z+8	; 0x08
    27d6:	88 23       	and	r24, r24
    27d8:	a1 f0       	breq	.+40     	; 0x2802 <xQueueGenericReset+0xf6>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    27da:	89 81       	ldd	r24, Y+1	; 0x01
    27dc:	9a 81       	ldd	r25, Y+2	; 0x02
    27de:	08 96       	adiw	r24, 0x08	; 8
    27e0:	0e 94 f3 20 	call	0x41e6	; 0x41e6 <xTaskRemoveFromEventList>
    27e4:	81 30       	cpi	r24, 0x01	; 1
    27e6:	69 f4       	brne	.+26     	; 0x2802 <xQueueGenericReset+0xf6>
				{
					queueYIELD_IF_USING_PREEMPTION();
    27e8:	0e 94 71 12 	call	0x24e2	; 0x24e2 <vPortYield>
    27ec:	0a c0       	rjmp	.+20     	; 0x2802 <xQueueGenericReset+0xf6>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    27ee:	89 81       	ldd	r24, Y+1	; 0x01
    27f0:	9a 81       	ldd	r25, Y+2	; 0x02
    27f2:	08 96       	adiw	r24, 0x08	; 8
    27f4:	0e 94 7c 0f 	call	0x1ef8	; 0x1ef8 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    27f8:	89 81       	ldd	r24, Y+1	; 0x01
    27fa:	9a 81       	ldd	r25, Y+2	; 0x02
    27fc:	41 96       	adiw	r24, 0x11	; 17
    27fe:	0e 94 7c 0f 	call	0x1ef8	; 0x1ef8 <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
    2802:	0f 90       	pop	r0
    2804:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
    2806:	81 e0       	ldi	r24, 0x01	; 1
}
    2808:	0f 90       	pop	r0
    280a:	0f 90       	pop	r0
    280c:	0f 90       	pop	r0
    280e:	0f 90       	pop	r0
    2810:	0f 90       	pop	r0
    2812:	cf 91       	pop	r28
    2814:	df 91       	pop	r29
    2816:	08 95       	ret

00002818 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
{
    2818:	df 93       	push	r29
    281a:	cf 93       	push	r28
    281c:	cd b7       	in	r28, 0x3d	; 61
    281e:	de b7       	in	r29, 0x3e	; 62
    2820:	29 97       	sbiw	r28, 0x09	; 9
    2822:	0f b6       	in	r0, 0x3f	; 63
    2824:	f8 94       	cli
    2826:	de bf       	out	0x3e, r29	; 62
    2828:	0f be       	out	0x3f, r0	; 63
    282a:	cd bf       	out	0x3d, r28	; 61
    282c:	8f 83       	std	Y+7, r24	; 0x07
    282e:	68 87       	std	Y+8, r22	; 0x08
    2830:	49 87       	std	Y+9, r20	; 0x09
Queue_t *pxNewQueue;
size_t xQueueSizeInBytes;
QueueHandle_t xReturn = NULL;
    2832:	1a 82       	std	Y+2, r1	; 0x02
    2834:	19 82       	std	Y+1, r1	; 0x01
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( UBaseType_t ) 0 )
    2836:	8f 81       	ldd	r24, Y+7	; 0x07
    2838:	88 23       	and	r24, r24
    283a:	09 f4       	brne	.+2      	; 0x283e <xQueueGenericCreate+0x26>
    283c:	3f c0       	rjmp	.+126    	; 0x28bc <xQueueGenericCreate+0xa4>
	{
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) );
    283e:	8f e1       	ldi	r24, 0x1F	; 31
    2840:	90 e0       	ldi	r25, 0x00	; 0
    2842:	0e 94 2e 0e 	call	0x1c5c	; 0x1c5c <pvPortMalloc>
    2846:	9e 83       	std	Y+6, r25	; 0x06
    2848:	8d 83       	std	Y+5, r24	; 0x05
		if( pxNewQueue != NULL )
    284a:	8d 81       	ldd	r24, Y+5	; 0x05
    284c:	9e 81       	ldd	r25, Y+6	; 0x06
    284e:	00 97       	sbiw	r24, 0x00	; 0
    2850:	a9 f1       	breq	.+106    	; 0x28bc <xQueueGenericCreate+0xa4>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    2852:	8f 81       	ldd	r24, Y+7	; 0x07
    2854:	28 2f       	mov	r18, r24
    2856:	30 e0       	ldi	r19, 0x00	; 0
    2858:	88 85       	ldd	r24, Y+8	; 0x08
    285a:	88 2f       	mov	r24, r24
    285c:	90 e0       	ldi	r25, 0x00	; 0
    285e:	ac 01       	movw	r20, r24
    2860:	24 9f       	mul	r18, r20
    2862:	c0 01       	movw	r24, r0
    2864:	25 9f       	mul	r18, r21
    2866:	90 0d       	add	r25, r0
    2868:	34 9f       	mul	r19, r20
    286a:	90 0d       	add	r25, r0
    286c:	11 24       	eor	r1, r1
    286e:	01 96       	adiw	r24, 0x01	; 1
    2870:	9c 83       	std	Y+4, r25	; 0x04
    2872:	8b 83       	std	Y+3, r24	; 0x03

			pxNewQueue->pcHead = ( int8_t * ) pvPortMalloc( xQueueSizeInBytes );
    2874:	8b 81       	ldd	r24, Y+3	; 0x03
    2876:	9c 81       	ldd	r25, Y+4	; 0x04
    2878:	0e 94 2e 0e 	call	0x1c5c	; 0x1c5c <pvPortMalloc>
    287c:	ed 81       	ldd	r30, Y+5	; 0x05
    287e:	fe 81       	ldd	r31, Y+6	; 0x06
    2880:	91 83       	std	Z+1, r25	; 0x01
    2882:	80 83       	st	Z, r24
			if( pxNewQueue->pcHead != NULL )
    2884:	ed 81       	ldd	r30, Y+5	; 0x05
    2886:	fe 81       	ldd	r31, Y+6	; 0x06
    2888:	80 81       	ld	r24, Z
    288a:	91 81       	ldd	r25, Z+1	; 0x01
    288c:	00 97       	sbiw	r24, 0x00	; 0
    288e:	91 f0       	breq	.+36     	; 0x28b4 <xQueueGenericCreate+0x9c>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->uxLength = uxQueueLength;
    2890:	ed 81       	ldd	r30, Y+5	; 0x05
    2892:	fe 81       	ldd	r31, Y+6	; 0x06
    2894:	8f 81       	ldd	r24, Y+7	; 0x07
    2896:	83 8f       	std	Z+27, r24	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
    2898:	ed 81       	ldd	r30, Y+5	; 0x05
    289a:	fe 81       	ldd	r31, Y+6	; 0x06
    289c:	88 85       	ldd	r24, Y+8	; 0x08
    289e:	84 8f       	std	Z+28, r24	; 0x1c
				( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    28a0:	8d 81       	ldd	r24, Y+5	; 0x05
    28a2:	9e 81       	ldd	r25, Y+6	; 0x06
    28a4:	61 e0       	ldi	r22, 0x01	; 1
    28a6:	0e 94 86 13 	call	0x270c	; 0x270c <xQueueGenericReset>
					pxNewQueue->pxQueueSetContainer = NULL;
				}
				#endif /* configUSE_QUEUE_SETS */

				traceQUEUE_CREATE( pxNewQueue );
				xReturn = pxNewQueue;
    28aa:	8d 81       	ldd	r24, Y+5	; 0x05
    28ac:	9e 81       	ldd	r25, Y+6	; 0x06
    28ae:	9a 83       	std	Y+2, r25	; 0x02
    28b0:	89 83       	std	Y+1, r24	; 0x01
    28b2:	04 c0       	rjmp	.+8      	; 0x28bc <xQueueGenericCreate+0xa4>
			}
			else
			{
				traceQUEUE_CREATE_FAILED( ucQueueType );
				vPortFree( pxNewQueue );
    28b4:	8d 81       	ldd	r24, Y+5	; 0x05
    28b6:	9e 81       	ldd	r25, Y+6	; 0x06
    28b8:	0e 94 84 0e 	call	0x1d08	; 0x1d08 <vPortFree>
		mtCOVERAGE_TEST_MARKER();
	}

	configASSERT( xReturn );

	return xReturn;
    28bc:	89 81       	ldd	r24, Y+1	; 0x01
    28be:	9a 81       	ldd	r25, Y+2	; 0x02
}
    28c0:	29 96       	adiw	r28, 0x09	; 9
    28c2:	0f b6       	in	r0, 0x3f	; 63
    28c4:	f8 94       	cli
    28c6:	de bf       	out	0x3e, r29	; 62
    28c8:	0f be       	out	0x3f, r0	; 63
    28ca:	cd bf       	out	0x3d, r28	; 61
    28cc:	cf 91       	pop	r28
    28ce:	df 91       	pop	r29
    28d0:	08 95       	ret

000028d2 <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
	{
    28d2:	df 93       	push	r29
    28d4:	cf 93       	push	r28
    28d6:	00 d0       	rcall	.+0      	; 0x28d8 <xQueueCreateMutex+0x6>
    28d8:	0f 92       	push	r0
    28da:	cd b7       	in	r28, 0x3d	; 61
    28dc:	de b7       	in	r29, 0x3e	; 62
    28de:	8b 83       	std	Y+3, r24	; 0x03
		/* Prevent compiler warnings about unused parameters if
		configUSE_TRACE_FACILITY does not equal 1. */
		( void ) ucQueueType;

		/* Allocate the new queue structure. */
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) );
    28e0:	8f e1       	ldi	r24, 0x1F	; 31
    28e2:	90 e0       	ldi	r25, 0x00	; 0
    28e4:	0e 94 2e 0e 	call	0x1c5c	; 0x1c5c <pvPortMalloc>
    28e8:	9a 83       	std	Y+2, r25	; 0x02
    28ea:	89 83       	std	Y+1, r24	; 0x01
		if( pxNewQueue != NULL )
    28ec:	89 81       	ldd	r24, Y+1	; 0x01
    28ee:	9a 81       	ldd	r25, Y+2	; 0x02
    28f0:	00 97       	sbiw	r24, 0x00	; 0
    28f2:	a9 f1       	breq	.+106    	; 0x295e <xQueueCreateMutex+0x8c>
		{
			/* Information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
    28f4:	e9 81       	ldd	r30, Y+1	; 0x01
    28f6:	fa 81       	ldd	r31, Y+2	; 0x02
    28f8:	13 82       	std	Z+3, r1	; 0x03
    28fa:	12 82       	std	Z+2, r1	; 0x02
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
    28fc:	e9 81       	ldd	r30, Y+1	; 0x01
    28fe:	fa 81       	ldd	r31, Y+2	; 0x02
    2900:	11 82       	std	Z+1, r1	; 0x01
    2902:	10 82       	st	Z, r1

			/* Queues used as a mutex no data is actually copied into or out
			of the queue. */
			pxNewQueue->pcWriteTo = NULL;
    2904:	e9 81       	ldd	r30, Y+1	; 0x01
    2906:	fa 81       	ldd	r31, Y+2	; 0x02
    2908:	15 82       	std	Z+5, r1	; 0x05
    290a:	14 82       	std	Z+4, r1	; 0x04
			pxNewQueue->u.pcReadFrom = NULL;
    290c:	e9 81       	ldd	r30, Y+1	; 0x01
    290e:	fa 81       	ldd	r31, Y+2	; 0x02
    2910:	17 82       	std	Z+7, r1	; 0x07
    2912:	16 82       	std	Z+6, r1	; 0x06

			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    2914:	e9 81       	ldd	r30, Y+1	; 0x01
    2916:	fa 81       	ldd	r31, Y+2	; 0x02
    2918:	12 8e       	std	Z+26, r1	; 0x1a
			pxNewQueue->uxLength = ( UBaseType_t ) 1U;
    291a:	e9 81       	ldd	r30, Y+1	; 0x01
    291c:	fa 81       	ldd	r31, Y+2	; 0x02
    291e:	81 e0       	ldi	r24, 0x01	; 1
    2920:	83 8f       	std	Z+27, r24	; 0x1b
			pxNewQueue->uxItemSize = ( UBaseType_t ) 0U;
    2922:	e9 81       	ldd	r30, Y+1	; 0x01
    2924:	fa 81       	ldd	r31, Y+2	; 0x02
    2926:	14 8e       	std	Z+28, r1	; 0x1c
			pxNewQueue->xRxLock = queueUNLOCKED;
    2928:	e9 81       	ldd	r30, Y+1	; 0x01
    292a:	fa 81       	ldd	r31, Y+2	; 0x02
    292c:	8f ef       	ldi	r24, 0xFF	; 255
    292e:	85 8f       	std	Z+29, r24	; 0x1d
			pxNewQueue->xTxLock = queueUNLOCKED;
    2930:	e9 81       	ldd	r30, Y+1	; 0x01
    2932:	fa 81       	ldd	r31, Y+2	; 0x02
    2934:	8f ef       	ldi	r24, 0xFF	; 255
    2936:	86 8f       	std	Z+30, r24	; 0x1e
				pxNewQueue->pxQueueSetContainer = NULL;
			}
			#endif

			/* Ensure the event queues start with the correct state. */
			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    2938:	89 81       	ldd	r24, Y+1	; 0x01
    293a:	9a 81       	ldd	r25, Y+2	; 0x02
    293c:	08 96       	adiw	r24, 0x08	; 8
    293e:	0e 94 7c 0f 	call	0x1ef8	; 0x1ef8 <vListInitialise>
			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    2942:	89 81       	ldd	r24, Y+1	; 0x01
    2944:	9a 81       	ldd	r25, Y+2	; 0x02
    2946:	41 96       	adiw	r24, 0x11	; 17
    2948:	0e 94 7c 0f 	call	0x1ef8	; 0x1ef8 <vListInitialise>

			traceCREATE_MUTEX( pxNewQueue );

			/* Start with the semaphore in the expected state. */
			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
    294c:	89 81       	ldd	r24, Y+1	; 0x01
    294e:	9a 81       	ldd	r25, Y+2	; 0x02
    2950:	60 e0       	ldi	r22, 0x00	; 0
    2952:	70 e0       	ldi	r23, 0x00	; 0
    2954:	40 e0       	ldi	r20, 0x00	; 0
    2956:	50 e0       	ldi	r21, 0x00	; 0
    2958:	20 e0       	ldi	r18, 0x00	; 0
    295a:	0e 94 d7 14 	call	0x29ae	; 0x29ae <xQueueGenericSend>
		{
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
		return pxNewQueue;
    295e:	89 81       	ldd	r24, Y+1	; 0x01
    2960:	9a 81       	ldd	r25, Y+2	; 0x02
	}
    2962:	0f 90       	pop	r0
    2964:	0f 90       	pop	r0
    2966:	0f 90       	pop	r0
    2968:	cf 91       	pop	r28
    296a:	df 91       	pop	r29
    296c:	08 95       	ret

0000296e <xQueueCreateCountingSemaphore>:
/*-----------------------------------------------------------*/

#if ( configUSE_COUNTING_SEMAPHORES == 1 )

	QueueHandle_t xQueueCreateCountingSemaphore( const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount )
	{
    296e:	df 93       	push	r29
    2970:	cf 93       	push	r28
    2972:	00 d0       	rcall	.+0      	; 0x2974 <xQueueCreateCountingSemaphore+0x6>
    2974:	00 d0       	rcall	.+0      	; 0x2976 <xQueueCreateCountingSemaphore+0x8>
    2976:	cd b7       	in	r28, 0x3d	; 61
    2978:	de b7       	in	r29, 0x3e	; 62
    297a:	8b 83       	std	Y+3, r24	; 0x03
    297c:	6c 83       	std	Y+4, r22	; 0x04
	QueueHandle_t xHandle;

		configASSERT( uxMaxCount != 0 );
		configASSERT( uxInitialCount <= uxMaxCount );

		xHandle = xQueueGenericCreate( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_COUNTING_SEMAPHORE );
    297e:	8b 81       	ldd	r24, Y+3	; 0x03
    2980:	60 e0       	ldi	r22, 0x00	; 0
    2982:	42 e0       	ldi	r20, 0x02	; 2
    2984:	0e 94 0c 14 	call	0x2818	; 0x2818 <xQueueGenericCreate>
    2988:	9a 83       	std	Y+2, r25	; 0x02
    298a:	89 83       	std	Y+1, r24	; 0x01

		if( xHandle != NULL )
    298c:	89 81       	ldd	r24, Y+1	; 0x01
    298e:	9a 81       	ldd	r25, Y+2	; 0x02
    2990:	00 97       	sbiw	r24, 0x00	; 0
    2992:	21 f0       	breq	.+8      	; 0x299c <xQueueCreateCountingSemaphore+0x2e>
		{
			( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
    2994:	e9 81       	ldd	r30, Y+1	; 0x01
    2996:	fa 81       	ldd	r31, Y+2	; 0x02
    2998:	8c 81       	ldd	r24, Y+4	; 0x04
    299a:	82 8f       	std	Z+26, r24	; 0x1a
		{
			traceCREATE_COUNTING_SEMAPHORE_FAILED();
		}

		configASSERT( xHandle );
		return xHandle;
    299c:	89 81       	ldd	r24, Y+1	; 0x01
    299e:	9a 81       	ldd	r25, Y+2	; 0x02
	}
    29a0:	0f 90       	pop	r0
    29a2:	0f 90       	pop	r0
    29a4:	0f 90       	pop	r0
    29a6:	0f 90       	pop	r0
    29a8:	cf 91       	pop	r28
    29aa:	df 91       	pop	r29
    29ac:	08 95       	ret

000029ae <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
    29ae:	df 93       	push	r29
    29b0:	cf 93       	push	r28
    29b2:	cd b7       	in	r28, 0x3d	; 61
    29b4:	de b7       	in	r29, 0x3e	; 62
    29b6:	2f 97       	sbiw	r28, 0x0f	; 15
    29b8:	0f b6       	in	r0, 0x3f	; 63
    29ba:	f8 94       	cli
    29bc:	de bf       	out	0x3e, r29	; 62
    29be:	0f be       	out	0x3f, r0	; 63
    29c0:	cd bf       	out	0x3d, r28	; 61
    29c2:	99 87       	std	Y+9, r25	; 0x09
    29c4:	88 87       	std	Y+8, r24	; 0x08
    29c6:	7b 87       	std	Y+11, r23	; 0x0b
    29c8:	6a 87       	std	Y+10, r22	; 0x0a
    29ca:	5d 87       	std	Y+13, r21	; 0x0d
    29cc:	4c 87       	std	Y+12, r20	; 0x0c
    29ce:	2e 87       	std	Y+14, r18	; 0x0e
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    29d0:	1c 82       	std	Y+4, r1	; 0x04
TimeOut_t xTimeOut;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    29d2:	88 85       	ldd	r24, Y+8	; 0x08
    29d4:	99 85       	ldd	r25, Y+9	; 0x09
    29d6:	9a 83       	std	Y+2, r25	; 0x02
    29d8:	89 83       	std	Y+1, r24	; 0x01
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    29da:	0f b6       	in	r0, 0x3f	; 63
    29dc:	f8 94       	cli
    29de:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be
			the highest priority task wanting to access the queue.  If
			the head item in the queue is to be overwritten then it does
			not matter if the queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    29e0:	e9 81       	ldd	r30, Y+1	; 0x01
    29e2:	fa 81       	ldd	r31, Y+2	; 0x02
    29e4:	92 8d       	ldd	r25, Z+26	; 0x1a
    29e6:	e9 81       	ldd	r30, Y+1	; 0x01
    29e8:	fa 81       	ldd	r31, Y+2	; 0x02
    29ea:	83 8d       	ldd	r24, Z+27	; 0x1b
    29ec:	98 17       	cp	r25, r24
    29ee:	18 f0       	brcs	.+6      	; 0x29f6 <xQueueGenericSend+0x48>
    29f0:	8e 85       	ldd	r24, Y+14	; 0x0e
    29f2:	82 30       	cpi	r24, 0x02	; 2
    29f4:	11 f5       	brne	.+68     	; 0x2a3a <xQueueGenericSend+0x8c>
			{
				traceQUEUE_SEND( pxQueue );
				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    29f6:	89 81       	ldd	r24, Y+1	; 0x01
    29f8:	9a 81       	ldd	r25, Y+2	; 0x02
    29fa:	2a 85       	ldd	r18, Y+10	; 0x0a
    29fc:	3b 85       	ldd	r19, Y+11	; 0x0b
    29fe:	b9 01       	movw	r22, r18
    2a00:	4e 85       	ldd	r20, Y+14	; 0x0e
    2a02:	0e 94 c9 17 	call	0x2f92	; 0x2f92 <prvCopyDataToQueue>
    2a06:	8b 83       	std	Y+3, r24	; 0x03
				}
				#else /* configUSE_QUEUE_SETS */
				{
					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2a08:	e9 81       	ldd	r30, Y+1	; 0x01
    2a0a:	fa 81       	ldd	r31, Y+2	; 0x02
    2a0c:	81 89       	ldd	r24, Z+17	; 0x11
    2a0e:	88 23       	and	r24, r24
    2a10:	51 f0       	breq	.+20     	; 0x2a26 <xQueueGenericSend+0x78>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    2a12:	89 81       	ldd	r24, Y+1	; 0x01
    2a14:	9a 81       	ldd	r25, Y+2	; 0x02
    2a16:	41 96       	adiw	r24, 0x11	; 17
    2a18:	0e 94 f3 20 	call	0x41e6	; 0x41e6 <xTaskRemoveFromEventList>
    2a1c:	81 30       	cpi	r24, 0x01	; 1
    2a1e:	41 f4       	brne	.+16     	; 0x2a30 <xQueueGenericSend+0x82>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
    2a20:	0e 94 71 12 	call	0x24e2	; 0x24e2 <vPortYield>
    2a24:	05 c0       	rjmp	.+10     	; 0x2a30 <xQueueGenericSend+0x82>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
    2a26:	8b 81       	ldd	r24, Y+3	; 0x03
    2a28:	88 23       	and	r24, r24
    2a2a:	11 f0       	breq	.+4      	; 0x2a30 <xQueueGenericSend+0x82>
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
    2a2c:	0e 94 71 12 	call	0x24e2	; 0x24e2 <vPortYield>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    2a30:	0f 90       	pop	r0
    2a32:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    2a34:	81 e0       	ldi	r24, 0x01	; 1
    2a36:	8f 87       	std	Y+15, r24	; 0x0f
    2a38:	5c c0       	rjmp	.+184    	; 0x2af2 <xQueueGenericSend+0x144>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    2a3a:	8c 85       	ldd	r24, Y+12	; 0x0c
    2a3c:	9d 85       	ldd	r25, Y+13	; 0x0d
    2a3e:	00 97       	sbiw	r24, 0x00	; 0
    2a40:	21 f4       	brne	.+8      	; 0x2a4a <xQueueGenericSend+0x9c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    2a42:	0f 90       	pop	r0
    2a44:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    2a46:	1f 86       	std	Y+15, r1	; 0x0f
    2a48:	54 c0       	rjmp	.+168    	; 0x2af2 <xQueueGenericSend+0x144>
				}
				else if( xEntryTimeSet == pdFALSE )
    2a4a:	8c 81       	ldd	r24, Y+4	; 0x04
    2a4c:	88 23       	and	r24, r24
    2a4e:	31 f4       	brne	.+12     	; 0x2a5c <xQueueGenericSend+0xae>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    2a50:	ce 01       	movw	r24, r28
    2a52:	05 96       	adiw	r24, 0x05	; 5
    2a54:	0e 94 c3 21 	call	0x4386	; 0x4386 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    2a58:	81 e0       	ldi	r24, 0x01	; 1
    2a5a:	8c 83       	std	Y+4, r24	; 0x04
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    2a5c:	0f 90       	pop	r0
    2a5e:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    2a60:	0e 94 60 1e 	call	0x3cc0	; 0x3cc0 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    2a64:	0f b6       	in	r0, 0x3f	; 63
    2a66:	f8 94       	cli
    2a68:	0f 92       	push	r0
    2a6a:	e9 81       	ldd	r30, Y+1	; 0x01
    2a6c:	fa 81       	ldd	r31, Y+2	; 0x02
    2a6e:	85 8d       	ldd	r24, Z+29	; 0x1d
    2a70:	8f 3f       	cpi	r24, 0xFF	; 255
    2a72:	19 f4       	brne	.+6      	; 0x2a7a <xQueueGenericSend+0xcc>
    2a74:	e9 81       	ldd	r30, Y+1	; 0x01
    2a76:	fa 81       	ldd	r31, Y+2	; 0x02
    2a78:	15 8e       	std	Z+29, r1	; 0x1d
    2a7a:	e9 81       	ldd	r30, Y+1	; 0x01
    2a7c:	fa 81       	ldd	r31, Y+2	; 0x02
    2a7e:	86 8d       	ldd	r24, Z+30	; 0x1e
    2a80:	8f 3f       	cpi	r24, 0xFF	; 255
    2a82:	19 f4       	brne	.+6      	; 0x2a8a <xQueueGenericSend+0xdc>
    2a84:	e9 81       	ldd	r30, Y+1	; 0x01
    2a86:	fa 81       	ldd	r31, Y+2	; 0x02
    2a88:	16 8e       	std	Z+30, r1	; 0x1e
    2a8a:	0f 90       	pop	r0
    2a8c:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    2a8e:	ce 01       	movw	r24, r28
    2a90:	05 96       	adiw	r24, 0x05	; 5
    2a92:	9e 01       	movw	r18, r28
    2a94:	24 5f       	subi	r18, 0xF4	; 244
    2a96:	3f 4f       	sbci	r19, 0xFF	; 255
    2a98:	b9 01       	movw	r22, r18
    2a9a:	0e 94 dc 21 	call	0x43b8	; 0x43b8 <xTaskCheckForTimeOut>
    2a9e:	88 23       	and	r24, r24
    2aa0:	09 f5       	brne	.+66     	; 0x2ae4 <xQueueGenericSend+0x136>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    2aa2:	89 81       	ldd	r24, Y+1	; 0x01
    2aa4:	9a 81       	ldd	r25, Y+2	; 0x02
    2aa6:	0e 94 52 19 	call	0x32a4	; 0x32a4 <prvIsQueueFull>
    2aaa:	88 23       	and	r24, r24
    2aac:	a1 f0       	breq	.+40     	; 0x2ad6 <xQueueGenericSend+0x128>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    2aae:	89 81       	ldd	r24, Y+1	; 0x01
    2ab0:	9a 81       	ldd	r25, Y+2	; 0x02
    2ab2:	08 96       	adiw	r24, 0x08	; 8
    2ab4:	2c 85       	ldd	r18, Y+12	; 0x0c
    2ab6:	3d 85       	ldd	r19, Y+13	; 0x0d
    2ab8:	b9 01       	movw	r22, r18
    2aba:	0e 94 7b 20 	call	0x40f6	; 0x40f6 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    2abe:	89 81       	ldd	r24, Y+1	; 0x01
    2ac0:	9a 81       	ldd	r25, Y+2	; 0x02
    2ac2:	0e 94 c9 18 	call	0x3192	; 0x3192 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    2ac6:	0e 94 6c 1e 	call	0x3cd8	; 0x3cd8 <xTaskResumeAll>
    2aca:	88 23       	and	r24, r24
    2acc:	09 f0       	breq	.+2      	; 0x2ad0 <xQueueGenericSend+0x122>
    2ace:	85 cf       	rjmp	.-246    	; 0x29da <xQueueGenericSend+0x2c>
				{
					portYIELD_WITHIN_API();
    2ad0:	0e 94 71 12 	call	0x24e2	; 0x24e2 <vPortYield>
    2ad4:	82 cf       	rjmp	.-252    	; 0x29da <xQueueGenericSend+0x2c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    2ad6:	89 81       	ldd	r24, Y+1	; 0x01
    2ad8:	9a 81       	ldd	r25, Y+2	; 0x02
    2ada:	0e 94 c9 18 	call	0x3192	; 0x3192 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    2ade:	0e 94 6c 1e 	call	0x3cd8	; 0x3cd8 <xTaskResumeAll>
    2ae2:	7b cf       	rjmp	.-266    	; 0x29da <xQueueGenericSend+0x2c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    2ae4:	89 81       	ldd	r24, Y+1	; 0x01
    2ae6:	9a 81       	ldd	r25, Y+2	; 0x02
    2ae8:	0e 94 c9 18 	call	0x3192	; 0x3192 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    2aec:	0e 94 6c 1e 	call	0x3cd8	; 0x3cd8 <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    2af0:	1f 86       	std	Y+15, r1	; 0x0f
    2af2:	8f 85       	ldd	r24, Y+15	; 0x0f
		}
	}
}
    2af4:	2f 96       	adiw	r28, 0x0f	; 15
    2af6:	0f b6       	in	r0, 0x3f	; 63
    2af8:	f8 94       	cli
    2afa:	de bf       	out	0x3e, r29	; 62
    2afc:	0f be       	out	0x3f, r0	; 63
    2afe:	cd bf       	out	0x3d, r28	; 61
    2b00:	cf 91       	pop	r28
    2b02:	df 91       	pop	r29
    2b04:	08 95       	ret

00002b06 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
    2b06:	df 93       	push	r29
    2b08:	cf 93       	push	r28
    2b0a:	cd b7       	in	r28, 0x3d	; 61
    2b0c:	de b7       	in	r29, 0x3e	; 62
    2b0e:	2b 97       	sbiw	r28, 0x0b	; 11
    2b10:	0f b6       	in	r0, 0x3f	; 63
    2b12:	f8 94       	cli
    2b14:	de bf       	out	0x3e, r29	; 62
    2b16:	0f be       	out	0x3f, r0	; 63
    2b18:	cd bf       	out	0x3d, r28	; 61
    2b1a:	9e 83       	std	Y+6, r25	; 0x06
    2b1c:	8d 83       	std	Y+5, r24	; 0x05
    2b1e:	78 87       	std	Y+8, r23	; 0x08
    2b20:	6f 83       	std	Y+7, r22	; 0x07
    2b22:	5a 87       	std	Y+10, r21	; 0x0a
    2b24:	49 87       	std	Y+9, r20	; 0x09
    2b26:	2b 87       	std	Y+11, r18	; 0x0b
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    2b28:	8d 81       	ldd	r24, Y+5	; 0x05
    2b2a:	9e 81       	ldd	r25, Y+6	; 0x06
    2b2c:	9a 83       	std	Y+2, r25	; 0x02
    2b2e:	89 83       	std	Y+1, r24	; 0x01
	/* Similar to xQueueGenericSend, except without blocking if there is no room
	in the queue.  Also don't directly wake a task that was blocked on a queue
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    2b30:	1b 82       	std	Y+3, r1	; 0x03
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    2b32:	e9 81       	ldd	r30, Y+1	; 0x01
    2b34:	fa 81       	ldd	r31, Y+2	; 0x02
    2b36:	92 8d       	ldd	r25, Z+26	; 0x1a
    2b38:	e9 81       	ldd	r30, Y+1	; 0x01
    2b3a:	fa 81       	ldd	r31, Y+2	; 0x02
    2b3c:	83 8d       	ldd	r24, Z+27	; 0x1b
    2b3e:	98 17       	cp	r25, r24
    2b40:	18 f0       	brcs	.+6      	; 0x2b48 <xQueueGenericSendFromISR+0x42>
    2b42:	8b 85       	ldd	r24, Y+11	; 0x0b
    2b44:	82 30       	cpi	r24, 0x02	; 2
    2b46:	b1 f5       	brne	.+108    	; 0x2bb4 <xQueueGenericSendFromISR+0xae>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			if( prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition ) != pdFALSE )
    2b48:	89 81       	ldd	r24, Y+1	; 0x01
    2b4a:	9a 81       	ldd	r25, Y+2	; 0x02
    2b4c:	2f 81       	ldd	r18, Y+7	; 0x07
    2b4e:	38 85       	ldd	r19, Y+8	; 0x08
    2b50:	b9 01       	movw	r22, r18
    2b52:	4b 85       	ldd	r20, Y+11	; 0x0b
    2b54:	0e 94 c9 17 	call	0x2f92	; 0x2f92 <prvCopyDataToQueue>
    2b58:	88 23       	and	r24, r24
    2b5a:	41 f0       	breq	.+16     	; 0x2b6c <xQueueGenericSendFromISR+0x66>
			{
				/* This is a special case that can only be executed if a task
				holds multiple mutexes and then gives the mutexes back in an
				order that is different to that in which they were taken. */
				if( pxHigherPriorityTaskWoken != NULL )
    2b5c:	89 85       	ldd	r24, Y+9	; 0x09
    2b5e:	9a 85       	ldd	r25, Y+10	; 0x0a
    2b60:	00 97       	sbiw	r24, 0x00	; 0
    2b62:	21 f0       	breq	.+8      	; 0x2b6c <xQueueGenericSendFromISR+0x66>
				{
					*pxHigherPriorityTaskWoken = pdTRUE;
    2b64:	e9 85       	ldd	r30, Y+9	; 0x09
    2b66:	fa 85       	ldd	r31, Y+10	; 0x0a
    2b68:	81 e0       	ldi	r24, 0x01	; 1
    2b6a:	80 83       	st	Z, r24
				}
			}

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    2b6c:	e9 81       	ldd	r30, Y+1	; 0x01
    2b6e:	fa 81       	ldd	r31, Y+2	; 0x02
    2b70:	86 8d       	ldd	r24, Z+30	; 0x1e
    2b72:	8f 3f       	cpi	r24, 0xFF	; 255
    2b74:	a9 f4       	brne	.+42     	; 0x2ba0 <xQueueGenericSendFromISR+0x9a>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2b76:	e9 81       	ldd	r30, Y+1	; 0x01
    2b78:	fa 81       	ldd	r31, Y+2	; 0x02
    2b7a:	81 89       	ldd	r24, Z+17	; 0x11
    2b7c:	88 23       	and	r24, r24
    2b7e:	b9 f0       	breq	.+46     	; 0x2bae <xQueueGenericSendFromISR+0xa8>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2b80:	89 81       	ldd	r24, Y+1	; 0x01
    2b82:	9a 81       	ldd	r25, Y+2	; 0x02
    2b84:	41 96       	adiw	r24, 0x11	; 17
    2b86:	0e 94 f3 20 	call	0x41e6	; 0x41e6 <xTaskRemoveFromEventList>
    2b8a:	88 23       	and	r24, r24
    2b8c:	81 f0       	breq	.+32     	; 0x2bae <xQueueGenericSendFromISR+0xa8>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    2b8e:	89 85       	ldd	r24, Y+9	; 0x09
    2b90:	9a 85       	ldd	r25, Y+10	; 0x0a
    2b92:	00 97       	sbiw	r24, 0x00	; 0
    2b94:	61 f0       	breq	.+24     	; 0x2bae <xQueueGenericSendFromISR+0xa8>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    2b96:	e9 85       	ldd	r30, Y+9	; 0x09
    2b98:	fa 85       	ldd	r31, Y+10	; 0x0a
    2b9a:	81 e0       	ldi	r24, 0x01	; 1
    2b9c:	80 83       	st	Z, r24
    2b9e:	07 c0       	rjmp	.+14     	; 0x2bae <xQueueGenericSendFromISR+0xa8>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    2ba0:	e9 81       	ldd	r30, Y+1	; 0x01
    2ba2:	fa 81       	ldd	r31, Y+2	; 0x02
    2ba4:	86 8d       	ldd	r24, Z+30	; 0x1e
    2ba6:	8f 5f       	subi	r24, 0xFF	; 255
    2ba8:	e9 81       	ldd	r30, Y+1	; 0x01
    2baa:	fa 81       	ldd	r31, Y+2	; 0x02
    2bac:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    2bae:	81 e0       	ldi	r24, 0x01	; 1
    2bb0:	8c 83       	std	Y+4, r24	; 0x04
    2bb2:	01 c0       	rjmp	.+2      	; 0x2bb6 <xQueueGenericSendFromISR+0xb0>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    2bb4:	1c 82       	std	Y+4, r1	; 0x04
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    2bb6:	8c 81       	ldd	r24, Y+4	; 0x04
}
    2bb8:	2b 96       	adiw	r28, 0x0b	; 11
    2bba:	0f b6       	in	r0, 0x3f	; 63
    2bbc:	f8 94       	cli
    2bbe:	de bf       	out	0x3e, r29	; 62
    2bc0:	0f be       	out	0x3f, r0	; 63
    2bc2:	cd bf       	out	0x3d, r28	; 61
    2bc4:	cf 91       	pop	r28
    2bc6:	df 91       	pop	r29
    2bc8:	08 95       	ret

00002bca <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
    2bca:	df 93       	push	r29
    2bcc:	cf 93       	push	r28
    2bce:	cd b7       	in	r28, 0x3d	; 61
    2bd0:	de b7       	in	r29, 0x3e	; 62
    2bd2:	60 97       	sbiw	r28, 0x10	; 16
    2bd4:	0f b6       	in	r0, 0x3f	; 63
    2bd6:	f8 94       	cli
    2bd8:	de bf       	out	0x3e, r29	; 62
    2bda:	0f be       	out	0x3f, r0	; 63
    2bdc:	cd bf       	out	0x3d, r28	; 61
    2bde:	9a 87       	std	Y+10, r25	; 0x0a
    2be0:	89 87       	std	Y+9, r24	; 0x09
    2be2:	7c 87       	std	Y+12, r23	; 0x0c
    2be4:	6b 87       	std	Y+11, r22	; 0x0b
    2be6:	5e 87       	std	Y+14, r21	; 0x0e
    2be8:	4d 87       	std	Y+13, r20	; 0x0d
    2bea:	2f 87       	std	Y+15, r18	; 0x0f
BaseType_t xEntryTimeSet = pdFALSE;
    2bec:	1d 82       	std	Y+5, r1	; 0x05
TimeOut_t xTimeOut;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    2bee:	89 85       	ldd	r24, Y+9	; 0x09
    2bf0:	9a 85       	ldd	r25, Y+10	; 0x0a
    2bf2:	9a 83       	std	Y+2, r25	; 0x02
    2bf4:	89 83       	std	Y+1, r24	; 0x01
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    2bf6:	0f b6       	in	r0, 0x3f	; 63
    2bf8:	f8 94       	cli
    2bfa:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    2bfc:	e9 81       	ldd	r30, Y+1	; 0x01
    2bfe:	fa 81       	ldd	r31, Y+2	; 0x02
    2c00:	82 8d       	ldd	r24, Z+26	; 0x1a
    2c02:	88 23       	and	r24, r24
    2c04:	09 f4       	brne	.+2      	; 0x2c08 <xQueueGenericReceive+0x3e>
    2c06:	4b c0       	rjmp	.+150    	; 0x2c9e <xQueueGenericReceive+0xd4>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    2c08:	e9 81       	ldd	r30, Y+1	; 0x01
    2c0a:	fa 81       	ldd	r31, Y+2	; 0x02
    2c0c:	86 81       	ldd	r24, Z+6	; 0x06
    2c0e:	97 81       	ldd	r25, Z+7	; 0x07
    2c10:	9c 83       	std	Y+4, r25	; 0x04
    2c12:	8b 83       	std	Y+3, r24	; 0x03

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    2c14:	89 81       	ldd	r24, Y+1	; 0x01
    2c16:	9a 81       	ldd	r25, Y+2	; 0x02
    2c18:	2b 85       	ldd	r18, Y+11	; 0x0b
    2c1a:	3c 85       	ldd	r19, Y+12	; 0x0c
    2c1c:	b9 01       	movw	r22, r18
    2c1e:	0e 94 82 18 	call	0x3104	; 0x3104 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    2c22:	8f 85       	ldd	r24, Y+15	; 0x0f
    2c24:	88 23       	and	r24, r24
    2c26:	11 f5       	brne	.+68     	; 0x2c6c <xQueueGenericReceive+0xa2>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					--( pxQueue->uxMessagesWaiting );
    2c28:	e9 81       	ldd	r30, Y+1	; 0x01
    2c2a:	fa 81       	ldd	r31, Y+2	; 0x02
    2c2c:	82 8d       	ldd	r24, Z+26	; 0x1a
    2c2e:	81 50       	subi	r24, 0x01	; 1
    2c30:	e9 81       	ldd	r30, Y+1	; 0x01
    2c32:	fa 81       	ldd	r31, Y+2	; 0x02
    2c34:	82 8f       	std	Z+26, r24	; 0x1a

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    2c36:	e9 81       	ldd	r30, Y+1	; 0x01
    2c38:	fa 81       	ldd	r31, Y+2	; 0x02
    2c3a:	80 81       	ld	r24, Z
    2c3c:	91 81       	ldd	r25, Z+1	; 0x01
    2c3e:	00 97       	sbiw	r24, 0x00	; 0
    2c40:	31 f4       	brne	.+12     	; 0x2c4e <xQueueGenericReceive+0x84>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
    2c42:	0e 94 53 25 	call	0x4aa6	; 0x4aa6 <pvTaskIncrementMutexHeldCount>
    2c46:	e9 81       	ldd	r30, Y+1	; 0x01
    2c48:	fa 81       	ldd	r31, Y+2	; 0x02
    2c4a:	93 83       	std	Z+3, r25	; 0x03
    2c4c:	82 83       	std	Z+2, r24	; 0x02
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2c4e:	e9 81       	ldd	r30, Y+1	; 0x01
    2c50:	fa 81       	ldd	r31, Y+2	; 0x02
    2c52:	80 85       	ldd	r24, Z+8	; 0x08
    2c54:	88 23       	and	r24, r24
    2c56:	f1 f0       	breq	.+60     	; 0x2c94 <xQueueGenericReceive+0xca>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    2c58:	89 81       	ldd	r24, Y+1	; 0x01
    2c5a:	9a 81       	ldd	r25, Y+2	; 0x02
    2c5c:	08 96       	adiw	r24, 0x08	; 8
    2c5e:	0e 94 f3 20 	call	0x41e6	; 0x41e6 <xTaskRemoveFromEventList>
    2c62:	81 30       	cpi	r24, 0x01	; 1
    2c64:	b9 f4       	brne	.+46     	; 0x2c94 <xQueueGenericReceive+0xca>
						{
							queueYIELD_IF_USING_PREEMPTION();
    2c66:	0e 94 71 12 	call	0x24e2	; 0x24e2 <vPortYield>
    2c6a:	14 c0       	rjmp	.+40     	; 0x2c94 <xQueueGenericReceive+0xca>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    2c6c:	e9 81       	ldd	r30, Y+1	; 0x01
    2c6e:	fa 81       	ldd	r31, Y+2	; 0x02
    2c70:	8b 81       	ldd	r24, Y+3	; 0x03
    2c72:	9c 81       	ldd	r25, Y+4	; 0x04
    2c74:	97 83       	std	Z+7, r25	; 0x07
    2c76:	86 83       	std	Z+6, r24	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2c78:	e9 81       	ldd	r30, Y+1	; 0x01
    2c7a:	fa 81       	ldd	r31, Y+2	; 0x02
    2c7c:	81 89       	ldd	r24, Z+17	; 0x11
    2c7e:	88 23       	and	r24, r24
    2c80:	49 f0       	breq	.+18     	; 0x2c94 <xQueueGenericReceive+0xca>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2c82:	89 81       	ldd	r24, Y+1	; 0x01
    2c84:	9a 81       	ldd	r25, Y+2	; 0x02
    2c86:	41 96       	adiw	r24, 0x11	; 17
    2c88:	0e 94 f3 20 	call	0x41e6	; 0x41e6 <xTaskRemoveFromEventList>
    2c8c:	88 23       	and	r24, r24
    2c8e:	11 f0       	breq	.+4      	; 0x2c94 <xQueueGenericReceive+0xca>
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
    2c90:	0e 94 71 12 	call	0x24e2	; 0x24e2 <vPortYield>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
    2c94:	0f 90       	pop	r0
    2c96:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    2c98:	81 e0       	ldi	r24, 0x01	; 1
    2c9a:	88 8b       	std	Y+16, r24	; 0x10
    2c9c:	6d c0       	rjmp	.+218    	; 0x2d78 <xQueueGenericReceive+0x1ae>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    2c9e:	8d 85       	ldd	r24, Y+13	; 0x0d
    2ca0:	9e 85       	ldd	r25, Y+14	; 0x0e
    2ca2:	00 97       	sbiw	r24, 0x00	; 0
    2ca4:	21 f4       	brne	.+8      	; 0x2cae <xQueueGenericReceive+0xe4>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    2ca6:	0f 90       	pop	r0
    2ca8:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    2caa:	18 8a       	std	Y+16, r1	; 0x10
    2cac:	65 c0       	rjmp	.+202    	; 0x2d78 <xQueueGenericReceive+0x1ae>
				}
				else if( xEntryTimeSet == pdFALSE )
    2cae:	8d 81       	ldd	r24, Y+5	; 0x05
    2cb0:	88 23       	and	r24, r24
    2cb2:	31 f4       	brne	.+12     	; 0x2cc0 <xQueueGenericReceive+0xf6>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    2cb4:	ce 01       	movw	r24, r28
    2cb6:	06 96       	adiw	r24, 0x06	; 6
    2cb8:	0e 94 c3 21 	call	0x4386	; 0x4386 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    2cbc:	81 e0       	ldi	r24, 0x01	; 1
    2cbe:	8d 83       	std	Y+5, r24	; 0x05
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    2cc0:	0f 90       	pop	r0
    2cc2:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    2cc4:	0e 94 60 1e 	call	0x3cc0	; 0x3cc0 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    2cc8:	0f b6       	in	r0, 0x3f	; 63
    2cca:	f8 94       	cli
    2ccc:	0f 92       	push	r0
    2cce:	e9 81       	ldd	r30, Y+1	; 0x01
    2cd0:	fa 81       	ldd	r31, Y+2	; 0x02
    2cd2:	85 8d       	ldd	r24, Z+29	; 0x1d
    2cd4:	8f 3f       	cpi	r24, 0xFF	; 255
    2cd6:	19 f4       	brne	.+6      	; 0x2cde <xQueueGenericReceive+0x114>
    2cd8:	e9 81       	ldd	r30, Y+1	; 0x01
    2cda:	fa 81       	ldd	r31, Y+2	; 0x02
    2cdc:	15 8e       	std	Z+29, r1	; 0x1d
    2cde:	e9 81       	ldd	r30, Y+1	; 0x01
    2ce0:	fa 81       	ldd	r31, Y+2	; 0x02
    2ce2:	86 8d       	ldd	r24, Z+30	; 0x1e
    2ce4:	8f 3f       	cpi	r24, 0xFF	; 255
    2ce6:	19 f4       	brne	.+6      	; 0x2cee <xQueueGenericReceive+0x124>
    2ce8:	e9 81       	ldd	r30, Y+1	; 0x01
    2cea:	fa 81       	ldd	r31, Y+2	; 0x02
    2cec:	16 8e       	std	Z+30, r1	; 0x1e
    2cee:	0f 90       	pop	r0
    2cf0:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    2cf2:	ce 01       	movw	r24, r28
    2cf4:	06 96       	adiw	r24, 0x06	; 6
    2cf6:	9e 01       	movw	r18, r28
    2cf8:	23 5f       	subi	r18, 0xF3	; 243
    2cfa:	3f 4f       	sbci	r19, 0xFF	; 255
    2cfc:	b9 01       	movw	r22, r18
    2cfe:	0e 94 dc 21 	call	0x43b8	; 0x43b8 <xTaskCheckForTimeOut>
    2d02:	88 23       	and	r24, r24
    2d04:	91 f5       	brne	.+100    	; 0x2d6a <xQueueGenericReceive+0x1a0>
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    2d06:	89 81       	ldd	r24, Y+1	; 0x01
    2d08:	9a 81       	ldd	r25, Y+2	; 0x02
    2d0a:	0e 94 1d 19 	call	0x323a	; 0x323a <prvIsQueueEmpty>
    2d0e:	88 23       	and	r24, r24
    2d10:	29 f1       	breq	.+74     	; 0x2d5c <xQueueGenericReceive+0x192>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    2d12:	e9 81       	ldd	r30, Y+1	; 0x01
    2d14:	fa 81       	ldd	r31, Y+2	; 0x02
    2d16:	80 81       	ld	r24, Z
    2d18:	91 81       	ldd	r25, Z+1	; 0x01
    2d1a:	00 97       	sbiw	r24, 0x00	; 0
    2d1c:	59 f4       	brne	.+22     	; 0x2d34 <xQueueGenericReceive+0x16a>
					{
						taskENTER_CRITICAL();
    2d1e:	0f b6       	in	r0, 0x3f	; 63
    2d20:	f8 94       	cli
    2d22:	0f 92       	push	r0
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
    2d24:	e9 81       	ldd	r30, Y+1	; 0x01
    2d26:	fa 81       	ldd	r31, Y+2	; 0x02
    2d28:	82 81       	ldd	r24, Z+2	; 0x02
    2d2a:	93 81       	ldd	r25, Z+3	; 0x03
    2d2c:	0e 94 2f 24 	call	0x485e	; 0x485e <vTaskPriorityInherit>
						}
						taskEXIT_CRITICAL();
    2d30:	0f 90       	pop	r0
    2d32:	0f be       	out	0x3f, r0	; 63
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    2d34:	89 81       	ldd	r24, Y+1	; 0x01
    2d36:	9a 81       	ldd	r25, Y+2	; 0x02
    2d38:	41 96       	adiw	r24, 0x11	; 17
    2d3a:	2d 85       	ldd	r18, Y+13	; 0x0d
    2d3c:	3e 85       	ldd	r19, Y+14	; 0x0e
    2d3e:	b9 01       	movw	r22, r18
    2d40:	0e 94 7b 20 	call	0x40f6	; 0x40f6 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    2d44:	89 81       	ldd	r24, Y+1	; 0x01
    2d46:	9a 81       	ldd	r25, Y+2	; 0x02
    2d48:	0e 94 c9 18 	call	0x3192	; 0x3192 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    2d4c:	0e 94 6c 1e 	call	0x3cd8	; 0x3cd8 <xTaskResumeAll>
    2d50:	88 23       	and	r24, r24
    2d52:	09 f0       	breq	.+2      	; 0x2d56 <xQueueGenericReceive+0x18c>
    2d54:	50 cf       	rjmp	.-352    	; 0x2bf6 <xQueueGenericReceive+0x2c>
				{
					portYIELD_WITHIN_API();
    2d56:	0e 94 71 12 	call	0x24e2	; 0x24e2 <vPortYield>
    2d5a:	4d cf       	rjmp	.-358    	; 0x2bf6 <xQueueGenericReceive+0x2c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    2d5c:	89 81       	ldd	r24, Y+1	; 0x01
    2d5e:	9a 81       	ldd	r25, Y+2	; 0x02
    2d60:	0e 94 c9 18 	call	0x3192	; 0x3192 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    2d64:	0e 94 6c 1e 	call	0x3cd8	; 0x3cd8 <xTaskResumeAll>
    2d68:	46 cf       	rjmp	.-372    	; 0x2bf6 <xQueueGenericReceive+0x2c>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    2d6a:	89 81       	ldd	r24, Y+1	; 0x01
    2d6c:	9a 81       	ldd	r25, Y+2	; 0x02
    2d6e:	0e 94 c9 18 	call	0x3192	; 0x3192 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    2d72:	0e 94 6c 1e 	call	0x3cd8	; 0x3cd8 <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    2d76:	18 8a       	std	Y+16, r1	; 0x10
    2d78:	88 89       	ldd	r24, Y+16	; 0x10
		}
	}
}
    2d7a:	60 96       	adiw	r28, 0x10	; 16
    2d7c:	0f b6       	in	r0, 0x3f	; 63
    2d7e:	f8 94       	cli
    2d80:	de bf       	out	0x3e, r29	; 62
    2d82:	0f be       	out	0x3f, r0	; 63
    2d84:	cd bf       	out	0x3d, r28	; 61
    2d86:	cf 91       	pop	r28
    2d88:	df 91       	pop	r29
    2d8a:	08 95       	ret

00002d8c <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
{
    2d8c:	df 93       	push	r29
    2d8e:	cf 93       	push	r28
    2d90:	cd b7       	in	r28, 0x3d	; 61
    2d92:	de b7       	in	r29, 0x3e	; 62
    2d94:	2a 97       	sbiw	r28, 0x0a	; 10
    2d96:	0f b6       	in	r0, 0x3f	; 63
    2d98:	f8 94       	cli
    2d9a:	de bf       	out	0x3e, r29	; 62
    2d9c:	0f be       	out	0x3f, r0	; 63
    2d9e:	cd bf       	out	0x3d, r28	; 61
    2da0:	9e 83       	std	Y+6, r25	; 0x06
    2da2:	8d 83       	std	Y+5, r24	; 0x05
    2da4:	78 87       	std	Y+8, r23	; 0x08
    2da6:	6f 83       	std	Y+7, r22	; 0x07
    2da8:	5a 87       	std	Y+10, r21	; 0x0a
    2daa:	49 87       	std	Y+9, r20	; 0x09
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    2dac:	8d 81       	ldd	r24, Y+5	; 0x05
    2dae:	9e 81       	ldd	r25, Y+6	; 0x06
    2db0:	9a 83       	std	Y+2, r25	; 0x02
    2db2:	89 83       	std	Y+1, r24	; 0x01
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    2db4:	1b 82       	std	Y+3, r1	; 0x03
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    2db6:	e9 81       	ldd	r30, Y+1	; 0x01
    2db8:	fa 81       	ldd	r31, Y+2	; 0x02
    2dba:	82 8d       	ldd	r24, Z+26	; 0x1a
    2dbc:	88 23       	and	r24, r24
    2dbe:	91 f1       	breq	.+100    	; 0x2e24 <xQueueReceiveFromISR+0x98>
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    2dc0:	89 81       	ldd	r24, Y+1	; 0x01
    2dc2:	9a 81       	ldd	r25, Y+2	; 0x02
    2dc4:	2f 81       	ldd	r18, Y+7	; 0x07
    2dc6:	38 85       	ldd	r19, Y+8	; 0x08
    2dc8:	b9 01       	movw	r22, r18
    2dca:	0e 94 82 18 	call	0x3104	; 0x3104 <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
    2dce:	e9 81       	ldd	r30, Y+1	; 0x01
    2dd0:	fa 81       	ldd	r31, Y+2	; 0x02
    2dd2:	82 8d       	ldd	r24, Z+26	; 0x1a
    2dd4:	81 50       	subi	r24, 0x01	; 1
    2dd6:	e9 81       	ldd	r30, Y+1	; 0x01
    2dd8:	fa 81       	ldd	r31, Y+2	; 0x02
    2dda:	82 8f       	std	Z+26, r24	; 0x1a

			/* If the queue is locked the event list will not be modified.
			Instead update the lock count so the task that unlocks the queue
			will know that an ISR has removed data while the queue was
			locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    2ddc:	e9 81       	ldd	r30, Y+1	; 0x01
    2dde:	fa 81       	ldd	r31, Y+2	; 0x02
    2de0:	85 8d       	ldd	r24, Z+29	; 0x1d
    2de2:	8f 3f       	cpi	r24, 0xFF	; 255
    2de4:	a9 f4       	brne	.+42     	; 0x2e10 <xQueueReceiveFromISR+0x84>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2de6:	e9 81       	ldd	r30, Y+1	; 0x01
    2de8:	fa 81       	ldd	r31, Y+2	; 0x02
    2dea:	80 85       	ldd	r24, Z+8	; 0x08
    2dec:	88 23       	and	r24, r24
    2dee:	b9 f0       	breq	.+46     	; 0x2e1e <xQueueReceiveFromISR+0x92>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2df0:	89 81       	ldd	r24, Y+1	; 0x01
    2df2:	9a 81       	ldd	r25, Y+2	; 0x02
    2df4:	08 96       	adiw	r24, 0x08	; 8
    2df6:	0e 94 f3 20 	call	0x41e6	; 0x41e6 <xTaskRemoveFromEventList>
    2dfa:	88 23       	and	r24, r24
    2dfc:	81 f0       	breq	.+32     	; 0x2e1e <xQueueReceiveFromISR+0x92>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
    2dfe:	89 85       	ldd	r24, Y+9	; 0x09
    2e00:	9a 85       	ldd	r25, Y+10	; 0x0a
    2e02:	00 97       	sbiw	r24, 0x00	; 0
    2e04:	61 f0       	breq	.+24     	; 0x2e1e <xQueueReceiveFromISR+0x92>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    2e06:	e9 85       	ldd	r30, Y+9	; 0x09
    2e08:	fa 85       	ldd	r31, Y+10	; 0x0a
    2e0a:	81 e0       	ldi	r24, 0x01	; 1
    2e0c:	80 83       	st	Z, r24
    2e0e:	07 c0       	rjmp	.+14     	; 0x2e1e <xQueueReceiveFromISR+0x92>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    2e10:	e9 81       	ldd	r30, Y+1	; 0x01
    2e12:	fa 81       	ldd	r31, Y+2	; 0x02
    2e14:	85 8d       	ldd	r24, Z+29	; 0x1d
    2e16:	8f 5f       	subi	r24, 0xFF	; 255
    2e18:	e9 81       	ldd	r30, Y+1	; 0x01
    2e1a:	fa 81       	ldd	r31, Y+2	; 0x02
    2e1c:	85 8f       	std	Z+29, r24	; 0x1d
			}

			xReturn = pdPASS;
    2e1e:	81 e0       	ldi	r24, 0x01	; 1
    2e20:	8c 83       	std	Y+4, r24	; 0x04
    2e22:	01 c0       	rjmp	.+2      	; 0x2e26 <xQueueReceiveFromISR+0x9a>
		}
		else
		{
			xReturn = pdFAIL;
    2e24:	1c 82       	std	Y+4, r1	; 0x04
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    2e26:	8c 81       	ldd	r24, Y+4	; 0x04
}
    2e28:	2a 96       	adiw	r28, 0x0a	; 10
    2e2a:	0f b6       	in	r0, 0x3f	; 63
    2e2c:	f8 94       	cli
    2e2e:	de bf       	out	0x3e, r29	; 62
    2e30:	0f be       	out	0x3f, r0	; 63
    2e32:	cd bf       	out	0x3d, r28	; 61
    2e34:	cf 91       	pop	r28
    2e36:	df 91       	pop	r29
    2e38:	08 95       	ret

00002e3a <xQueuePeekFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
{
    2e3a:	df 93       	push	r29
    2e3c:	cf 93       	push	r28
    2e3e:	cd b7       	in	r28, 0x3d	; 61
    2e40:	de b7       	in	r29, 0x3e	; 62
    2e42:	2a 97       	sbiw	r28, 0x0a	; 10
    2e44:	0f b6       	in	r0, 0x3f	; 63
    2e46:	f8 94       	cli
    2e48:	de bf       	out	0x3e, r29	; 62
    2e4a:	0f be       	out	0x3f, r0	; 63
    2e4c:	cd bf       	out	0x3d, r28	; 61
    2e4e:	98 87       	std	Y+8, r25	; 0x08
    2e50:	8f 83       	std	Y+7, r24	; 0x07
    2e52:	7a 87       	std	Y+10, r23	; 0x0a
    2e54:	69 87       	std	Y+9, r22	; 0x09
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    2e56:	8f 81       	ldd	r24, Y+7	; 0x07
    2e58:	98 85       	ldd	r25, Y+8	; 0x08
    2e5a:	9a 83       	std	Y+2, r25	; 0x02
    2e5c:	89 83       	std	Y+1, r24	; 0x01
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    2e5e:	1d 82       	std	Y+5, r1	; 0x05
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    2e60:	e9 81       	ldd	r30, Y+1	; 0x01
    2e62:	fa 81       	ldd	r31, Y+2	; 0x02
    2e64:	82 8d       	ldd	r24, Z+26	; 0x1a
    2e66:	88 23       	and	r24, r24
    2e68:	b1 f0       	breq	.+44     	; 0x2e96 <xQueuePeekFromISR+0x5c>
		{
			traceQUEUE_PEEK_FROM_ISR( pxQueue );

			/* Remember the read position so it can be reset as nothing is
			actually being removed from the queue. */
			pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    2e6a:	e9 81       	ldd	r30, Y+1	; 0x01
    2e6c:	fa 81       	ldd	r31, Y+2	; 0x02
    2e6e:	86 81       	ldd	r24, Z+6	; 0x06
    2e70:	97 81       	ldd	r25, Z+7	; 0x07
    2e72:	9c 83       	std	Y+4, r25	; 0x04
    2e74:	8b 83       	std	Y+3, r24	; 0x03
			prvCopyDataFromQueue( pxQueue, pvBuffer );
    2e76:	89 81       	ldd	r24, Y+1	; 0x01
    2e78:	9a 81       	ldd	r25, Y+2	; 0x02
    2e7a:	29 85       	ldd	r18, Y+9	; 0x09
    2e7c:	3a 85       	ldd	r19, Y+10	; 0x0a
    2e7e:	b9 01       	movw	r22, r18
    2e80:	0e 94 82 18 	call	0x3104	; 0x3104 <prvCopyDataFromQueue>
			pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    2e84:	e9 81       	ldd	r30, Y+1	; 0x01
    2e86:	fa 81       	ldd	r31, Y+2	; 0x02
    2e88:	8b 81       	ldd	r24, Y+3	; 0x03
    2e8a:	9c 81       	ldd	r25, Y+4	; 0x04
    2e8c:	97 83       	std	Z+7, r25	; 0x07
    2e8e:	86 83       	std	Z+6, r24	; 0x06

			xReturn = pdPASS;
    2e90:	81 e0       	ldi	r24, 0x01	; 1
    2e92:	8e 83       	std	Y+6, r24	; 0x06
    2e94:	01 c0       	rjmp	.+2      	; 0x2e98 <xQueuePeekFromISR+0x5e>
		}
		else
		{
			xReturn = pdFAIL;
    2e96:	1e 82       	std	Y+6, r1	; 0x06
			traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    2e98:	8e 81       	ldd	r24, Y+6	; 0x06
}
    2e9a:	2a 96       	adiw	r28, 0x0a	; 10
    2e9c:	0f b6       	in	r0, 0x3f	; 63
    2e9e:	f8 94       	cli
    2ea0:	de bf       	out	0x3e, r29	; 62
    2ea2:	0f be       	out	0x3f, r0	; 63
    2ea4:	cd bf       	out	0x3d, r28	; 61
    2ea6:	cf 91       	pop	r28
    2ea8:	df 91       	pop	r29
    2eaa:	08 95       	ret

00002eac <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
{
    2eac:	df 93       	push	r29
    2eae:	cf 93       	push	r28
    2eb0:	00 d0       	rcall	.+0      	; 0x2eb2 <uxQueueMessagesWaiting+0x6>
    2eb2:	0f 92       	push	r0
    2eb4:	cd b7       	in	r28, 0x3d	; 61
    2eb6:	de b7       	in	r29, 0x3e	; 62
    2eb8:	9b 83       	std	Y+3, r25	; 0x03
    2eba:	8a 83       	std	Y+2, r24	; 0x02
UBaseType_t uxReturn;

	configASSERT( xQueue );

	taskENTER_CRITICAL();
    2ebc:	0f b6       	in	r0, 0x3f	; 63
    2ebe:	f8 94       	cli
    2ec0:	0f 92       	push	r0
	{
		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    2ec2:	ea 81       	ldd	r30, Y+2	; 0x02
    2ec4:	fb 81       	ldd	r31, Y+3	; 0x03
    2ec6:	82 8d       	ldd	r24, Z+26	; 0x1a
    2ec8:	89 83       	std	Y+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    2eca:	0f 90       	pop	r0
    2ecc:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    2ece:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    2ed0:	0f 90       	pop	r0
    2ed2:	0f 90       	pop	r0
    2ed4:	0f 90       	pop	r0
    2ed6:	cf 91       	pop	r28
    2ed8:	df 91       	pop	r29
    2eda:	08 95       	ret

00002edc <uxQueueSpacesAvailable>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
{
    2edc:	df 93       	push	r29
    2ede:	cf 93       	push	r28
    2ee0:	00 d0       	rcall	.+0      	; 0x2ee2 <uxQueueSpacesAvailable+0x6>
    2ee2:	00 d0       	rcall	.+0      	; 0x2ee4 <uxQueueSpacesAvailable+0x8>
    2ee4:	0f 92       	push	r0
    2ee6:	cd b7       	in	r28, 0x3d	; 61
    2ee8:	de b7       	in	r29, 0x3e	; 62
    2eea:	9d 83       	std	Y+5, r25	; 0x05
    2eec:	8c 83       	std	Y+4, r24	; 0x04
UBaseType_t uxReturn;
Queue_t *pxQueue;

	pxQueue = ( Queue_t * ) xQueue;
    2eee:	8c 81       	ldd	r24, Y+4	; 0x04
    2ef0:	9d 81       	ldd	r25, Y+5	; 0x05
    2ef2:	9a 83       	std	Y+2, r25	; 0x02
    2ef4:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    2ef6:	0f b6       	in	r0, 0x3f	; 63
    2ef8:	f8 94       	cli
    2efa:	0f 92       	push	r0
	{
		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    2efc:	e9 81       	ldd	r30, Y+1	; 0x01
    2efe:	fa 81       	ldd	r31, Y+2	; 0x02
    2f00:	93 8d       	ldd	r25, Z+27	; 0x1b
    2f02:	e9 81       	ldd	r30, Y+1	; 0x01
    2f04:	fa 81       	ldd	r31, Y+2	; 0x02
    2f06:	82 8d       	ldd	r24, Z+26	; 0x1a
    2f08:	29 2f       	mov	r18, r25
    2f0a:	28 1b       	sub	r18, r24
    2f0c:	82 2f       	mov	r24, r18
    2f0e:	8b 83       	std	Y+3, r24	; 0x03
	}
	taskEXIT_CRITICAL();
    2f10:	0f 90       	pop	r0
    2f12:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    2f14:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    2f16:	0f 90       	pop	r0
    2f18:	0f 90       	pop	r0
    2f1a:	0f 90       	pop	r0
    2f1c:	0f 90       	pop	r0
    2f1e:	0f 90       	pop	r0
    2f20:	cf 91       	pop	r28
    2f22:	df 91       	pop	r29
    2f24:	08 95       	ret

00002f26 <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
{
    2f26:	df 93       	push	r29
    2f28:	cf 93       	push	r28
    2f2a:	00 d0       	rcall	.+0      	; 0x2f2c <uxQueueMessagesWaitingFromISR+0x6>
    2f2c:	0f 92       	push	r0
    2f2e:	cd b7       	in	r28, 0x3d	; 61
    2f30:	de b7       	in	r29, 0x3e	; 62
    2f32:	9b 83       	std	Y+3, r25	; 0x03
    2f34:	8a 83       	std	Y+2, r24	; 0x02
UBaseType_t uxReturn;

	configASSERT( xQueue );

	uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    2f36:	ea 81       	ldd	r30, Y+2	; 0x02
    2f38:	fb 81       	ldd	r31, Y+3	; 0x03
    2f3a:	82 8d       	ldd	r24, Z+26	; 0x1a
    2f3c:	89 83       	std	Y+1, r24	; 0x01

	return uxReturn;
    2f3e:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    2f40:	0f 90       	pop	r0
    2f42:	0f 90       	pop	r0
    2f44:	0f 90       	pop	r0
    2f46:	cf 91       	pop	r28
    2f48:	df 91       	pop	r29
    2f4a:	08 95       	ret

00002f4c <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( QueueHandle_t xQueue )
{
    2f4c:	df 93       	push	r29
    2f4e:	cf 93       	push	r28
    2f50:	00 d0       	rcall	.+0      	; 0x2f52 <vQueueDelete+0x6>
    2f52:	00 d0       	rcall	.+0      	; 0x2f54 <vQueueDelete+0x8>
    2f54:	cd b7       	in	r28, 0x3d	; 61
    2f56:	de b7       	in	r29, 0x3e	; 62
    2f58:	9c 83       	std	Y+4, r25	; 0x04
    2f5a:	8b 83       	std	Y+3, r24	; 0x03
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    2f5c:	8b 81       	ldd	r24, Y+3	; 0x03
    2f5e:	9c 81       	ldd	r25, Y+4	; 0x04
    2f60:	9a 83       	std	Y+2, r25	; 0x02
    2f62:	89 83       	std	Y+1, r24	; 0x01
	#if ( configQUEUE_REGISTRY_SIZE > 0 )
	{
		vQueueUnregisterQueue( pxQueue );
	}
	#endif
	if( pxQueue->pcHead != NULL )
    2f64:	e9 81       	ldd	r30, Y+1	; 0x01
    2f66:	fa 81       	ldd	r31, Y+2	; 0x02
    2f68:	80 81       	ld	r24, Z
    2f6a:	91 81       	ldd	r25, Z+1	; 0x01
    2f6c:	00 97       	sbiw	r24, 0x00	; 0
    2f6e:	31 f0       	breq	.+12     	; 0x2f7c <vQueueDelete+0x30>
	{
		vPortFree( pxQueue->pcHead );
    2f70:	e9 81       	ldd	r30, Y+1	; 0x01
    2f72:	fa 81       	ldd	r31, Y+2	; 0x02
    2f74:	80 81       	ld	r24, Z
    2f76:	91 81       	ldd	r25, Z+1	; 0x01
    2f78:	0e 94 84 0e 	call	0x1d08	; 0x1d08 <vPortFree>
	}
	vPortFree( pxQueue );
    2f7c:	89 81       	ldd	r24, Y+1	; 0x01
    2f7e:	9a 81       	ldd	r25, Y+2	; 0x02
    2f80:	0e 94 84 0e 	call	0x1d08	; 0x1d08 <vPortFree>
}
    2f84:	0f 90       	pop	r0
    2f86:	0f 90       	pop	r0
    2f88:	0f 90       	pop	r0
    2f8a:	0f 90       	pop	r0
    2f8c:	cf 91       	pop	r28
    2f8e:	df 91       	pop	r29
    2f90:	08 95       	ret

00002f92 <prvCopyDataToQueue>:

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
    2f92:	df 93       	push	r29
    2f94:	cf 93       	push	r28
    2f96:	00 d0       	rcall	.+0      	; 0x2f98 <prvCopyDataToQueue+0x6>
    2f98:	00 d0       	rcall	.+0      	; 0x2f9a <prvCopyDataToQueue+0x8>
    2f9a:	00 d0       	rcall	.+0      	; 0x2f9c <prvCopyDataToQueue+0xa>
    2f9c:	cd b7       	in	r28, 0x3d	; 61
    2f9e:	de b7       	in	r29, 0x3e	; 62
    2fa0:	9b 83       	std	Y+3, r25	; 0x03
    2fa2:	8a 83       	std	Y+2, r24	; 0x02
    2fa4:	7d 83       	std	Y+5, r23	; 0x05
    2fa6:	6c 83       	std	Y+4, r22	; 0x04
    2fa8:	4e 83       	std	Y+6, r20	; 0x06
BaseType_t xReturn = pdFALSE;
    2faa:	19 82       	std	Y+1, r1	; 0x01

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    2fac:	ea 81       	ldd	r30, Y+2	; 0x02
    2fae:	fb 81       	ldd	r31, Y+3	; 0x03
    2fb0:	84 8d       	ldd	r24, Z+28	; 0x1c
    2fb2:	88 23       	and	r24, r24
    2fb4:	99 f4       	brne	.+38     	; 0x2fdc <prvCopyDataToQueue+0x4a>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    2fb6:	ea 81       	ldd	r30, Y+2	; 0x02
    2fb8:	fb 81       	ldd	r31, Y+3	; 0x03
    2fba:	80 81       	ld	r24, Z
    2fbc:	91 81       	ldd	r25, Z+1	; 0x01
    2fbe:	00 97       	sbiw	r24, 0x00	; 0
    2fc0:	09 f0       	breq	.+2      	; 0x2fc4 <prvCopyDataToQueue+0x32>
    2fc2:	8f c0       	rjmp	.+286    	; 0x30e2 <prvCopyDataToQueue+0x150>
			{
				/* The mutex is no longer being held. */
				xReturn = xTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
    2fc4:	ea 81       	ldd	r30, Y+2	; 0x02
    2fc6:	fb 81       	ldd	r31, Y+3	; 0x03
    2fc8:	82 81       	ldd	r24, Z+2	; 0x02
    2fca:	93 81       	ldd	r25, Z+3	; 0x03
    2fcc:	0e 94 ba 24 	call	0x4974	; 0x4974 <xTaskPriorityDisinherit>
    2fd0:	89 83       	std	Y+1, r24	; 0x01
				pxQueue->pxMutexHolder = NULL;
    2fd2:	ea 81       	ldd	r30, Y+2	; 0x02
    2fd4:	fb 81       	ldd	r31, Y+3	; 0x03
    2fd6:	13 82       	std	Z+3, r1	; 0x03
    2fd8:	12 82       	std	Z+2, r1	; 0x02
    2fda:	83 c0       	rjmp	.+262    	; 0x30e2 <prvCopyDataToQueue+0x150>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
    2fdc:	8e 81       	ldd	r24, Y+6	; 0x06
    2fde:	88 23       	and	r24, r24
    2fe0:	99 f5       	brne	.+102    	; 0x3048 <prvCopyDataToQueue+0xb6>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
    2fe2:	ea 81       	ldd	r30, Y+2	; 0x02
    2fe4:	fb 81       	ldd	r31, Y+3	; 0x03
    2fe6:	64 81       	ldd	r22, Z+4	; 0x04
    2fe8:	75 81       	ldd	r23, Z+5	; 0x05
    2fea:	ea 81       	ldd	r30, Y+2	; 0x02
    2fec:	fb 81       	ldd	r31, Y+3	; 0x03
    2fee:	84 8d       	ldd	r24, Z+28	; 0x1c
    2ff0:	48 2f       	mov	r20, r24
    2ff2:	50 e0       	ldi	r21, 0x00	; 0
    2ff4:	2c 81       	ldd	r18, Y+4	; 0x04
    2ff6:	3d 81       	ldd	r19, Y+5	; 0x05
    2ff8:	cb 01       	movw	r24, r22
    2ffa:	b9 01       	movw	r22, r18
    2ffc:	0e 94 e3 36 	call	0x6dc6	; 0x6dc6 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    3000:	ea 81       	ldd	r30, Y+2	; 0x02
    3002:	fb 81       	ldd	r31, Y+3	; 0x03
    3004:	24 81       	ldd	r18, Z+4	; 0x04
    3006:	35 81       	ldd	r19, Z+5	; 0x05
    3008:	ea 81       	ldd	r30, Y+2	; 0x02
    300a:	fb 81       	ldd	r31, Y+3	; 0x03
    300c:	84 8d       	ldd	r24, Z+28	; 0x1c
    300e:	88 2f       	mov	r24, r24
    3010:	90 e0       	ldi	r25, 0x00	; 0
    3012:	82 0f       	add	r24, r18
    3014:	93 1f       	adc	r25, r19
    3016:	ea 81       	ldd	r30, Y+2	; 0x02
    3018:	fb 81       	ldd	r31, Y+3	; 0x03
    301a:	95 83       	std	Z+5, r25	; 0x05
    301c:	84 83       	std	Z+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    301e:	ea 81       	ldd	r30, Y+2	; 0x02
    3020:	fb 81       	ldd	r31, Y+3	; 0x03
    3022:	24 81       	ldd	r18, Z+4	; 0x04
    3024:	35 81       	ldd	r19, Z+5	; 0x05
    3026:	ea 81       	ldd	r30, Y+2	; 0x02
    3028:	fb 81       	ldd	r31, Y+3	; 0x03
    302a:	82 81       	ldd	r24, Z+2	; 0x02
    302c:	93 81       	ldd	r25, Z+3	; 0x03
    302e:	28 17       	cp	r18, r24
    3030:	39 07       	cpc	r19, r25
    3032:	08 f4       	brcc	.+2      	; 0x3036 <prvCopyDataToQueue+0xa4>
    3034:	56 c0       	rjmp	.+172    	; 0x30e2 <prvCopyDataToQueue+0x150>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    3036:	ea 81       	ldd	r30, Y+2	; 0x02
    3038:	fb 81       	ldd	r31, Y+3	; 0x03
    303a:	80 81       	ld	r24, Z
    303c:	91 81       	ldd	r25, Z+1	; 0x01
    303e:	ea 81       	ldd	r30, Y+2	; 0x02
    3040:	fb 81       	ldd	r31, Y+3	; 0x03
    3042:	95 83       	std	Z+5, r25	; 0x05
    3044:	84 83       	std	Z+4, r24	; 0x04
    3046:	4d c0       	rjmp	.+154    	; 0x30e2 <prvCopyDataToQueue+0x150>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    3048:	ea 81       	ldd	r30, Y+2	; 0x02
    304a:	fb 81       	ldd	r31, Y+3	; 0x03
    304c:	66 81       	ldd	r22, Z+6	; 0x06
    304e:	77 81       	ldd	r23, Z+7	; 0x07
    3050:	ea 81       	ldd	r30, Y+2	; 0x02
    3052:	fb 81       	ldd	r31, Y+3	; 0x03
    3054:	84 8d       	ldd	r24, Z+28	; 0x1c
    3056:	48 2f       	mov	r20, r24
    3058:	50 e0       	ldi	r21, 0x00	; 0
    305a:	2c 81       	ldd	r18, Y+4	; 0x04
    305c:	3d 81       	ldd	r19, Y+5	; 0x05
    305e:	cb 01       	movw	r24, r22
    3060:	b9 01       	movw	r22, r18
    3062:	0e 94 e3 36 	call	0x6dc6	; 0x6dc6 <memcpy>
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
    3066:	ea 81       	ldd	r30, Y+2	; 0x02
    3068:	fb 81       	ldd	r31, Y+3	; 0x03
    306a:	26 81       	ldd	r18, Z+6	; 0x06
    306c:	37 81       	ldd	r19, Z+7	; 0x07
    306e:	ea 81       	ldd	r30, Y+2	; 0x02
    3070:	fb 81       	ldd	r31, Y+3	; 0x03
    3072:	84 8d       	ldd	r24, Z+28	; 0x1c
    3074:	88 2f       	mov	r24, r24
    3076:	90 e0       	ldi	r25, 0x00	; 0
    3078:	90 95       	com	r25
    307a:	81 95       	neg	r24
    307c:	9f 4f       	sbci	r25, 0xFF	; 255
    307e:	82 0f       	add	r24, r18
    3080:	93 1f       	adc	r25, r19
    3082:	ea 81       	ldd	r30, Y+2	; 0x02
    3084:	fb 81       	ldd	r31, Y+3	; 0x03
    3086:	97 83       	std	Z+7, r25	; 0x07
    3088:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    308a:	ea 81       	ldd	r30, Y+2	; 0x02
    308c:	fb 81       	ldd	r31, Y+3	; 0x03
    308e:	26 81       	ldd	r18, Z+6	; 0x06
    3090:	37 81       	ldd	r19, Z+7	; 0x07
    3092:	ea 81       	ldd	r30, Y+2	; 0x02
    3094:	fb 81       	ldd	r31, Y+3	; 0x03
    3096:	80 81       	ld	r24, Z
    3098:	91 81       	ldd	r25, Z+1	; 0x01
    309a:	28 17       	cp	r18, r24
    309c:	39 07       	cpc	r19, r25
    309e:	90 f4       	brcc	.+36     	; 0x30c4 <prvCopyDataToQueue+0x132>
		{
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    30a0:	ea 81       	ldd	r30, Y+2	; 0x02
    30a2:	fb 81       	ldd	r31, Y+3	; 0x03
    30a4:	22 81       	ldd	r18, Z+2	; 0x02
    30a6:	33 81       	ldd	r19, Z+3	; 0x03
    30a8:	ea 81       	ldd	r30, Y+2	; 0x02
    30aa:	fb 81       	ldd	r31, Y+3	; 0x03
    30ac:	84 8d       	ldd	r24, Z+28	; 0x1c
    30ae:	88 2f       	mov	r24, r24
    30b0:	90 e0       	ldi	r25, 0x00	; 0
    30b2:	90 95       	com	r25
    30b4:	81 95       	neg	r24
    30b6:	9f 4f       	sbci	r25, 0xFF	; 255
    30b8:	82 0f       	add	r24, r18
    30ba:	93 1f       	adc	r25, r19
    30bc:	ea 81       	ldd	r30, Y+2	; 0x02
    30be:	fb 81       	ldd	r31, Y+3	; 0x03
    30c0:	97 83       	std	Z+7, r25	; 0x07
    30c2:	86 83       	std	Z+6, r24	; 0x06
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
    30c4:	8e 81       	ldd	r24, Y+6	; 0x06
    30c6:	82 30       	cpi	r24, 0x02	; 2
    30c8:	61 f4       	brne	.+24     	; 0x30e2 <prvCopyDataToQueue+0x150>
		{
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    30ca:	ea 81       	ldd	r30, Y+2	; 0x02
    30cc:	fb 81       	ldd	r31, Y+3	; 0x03
    30ce:	82 8d       	ldd	r24, Z+26	; 0x1a
    30d0:	88 23       	and	r24, r24
    30d2:	39 f0       	breq	.+14     	; 0x30e2 <prvCopyDataToQueue+0x150>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--( pxQueue->uxMessagesWaiting );
    30d4:	ea 81       	ldd	r30, Y+2	; 0x02
    30d6:	fb 81       	ldd	r31, Y+3	; 0x03
    30d8:	82 8d       	ldd	r24, Z+26	; 0x1a
    30da:	81 50       	subi	r24, 0x01	; 1
    30dc:	ea 81       	ldd	r30, Y+2	; 0x02
    30de:	fb 81       	ldd	r31, Y+3	; 0x03
    30e0:	82 8f       	std	Z+26, r24	; 0x1a
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	++( pxQueue->uxMessagesWaiting );
    30e2:	ea 81       	ldd	r30, Y+2	; 0x02
    30e4:	fb 81       	ldd	r31, Y+3	; 0x03
    30e6:	82 8d       	ldd	r24, Z+26	; 0x1a
    30e8:	8f 5f       	subi	r24, 0xFF	; 255
    30ea:	ea 81       	ldd	r30, Y+2	; 0x02
    30ec:	fb 81       	ldd	r31, Y+3	; 0x03
    30ee:	82 8f       	std	Z+26, r24	; 0x1a

	return xReturn;
    30f0:	89 81       	ldd	r24, Y+1	; 0x01
}
    30f2:	26 96       	adiw	r28, 0x06	; 6
    30f4:	0f b6       	in	r0, 0x3f	; 63
    30f6:	f8 94       	cli
    30f8:	de bf       	out	0x3e, r29	; 62
    30fa:	0f be       	out	0x3f, r0	; 63
    30fc:	cd bf       	out	0x3d, r28	; 61
    30fe:	cf 91       	pop	r28
    3100:	df 91       	pop	r29
    3102:	08 95       	ret

00003104 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
    3104:	df 93       	push	r29
    3106:	cf 93       	push	r28
    3108:	00 d0       	rcall	.+0      	; 0x310a <prvCopyDataFromQueue+0x6>
    310a:	00 d0       	rcall	.+0      	; 0x310c <prvCopyDataFromQueue+0x8>
    310c:	cd b7       	in	r28, 0x3d	; 61
    310e:	de b7       	in	r29, 0x3e	; 62
    3110:	9a 83       	std	Y+2, r25	; 0x02
    3112:	89 83       	std	Y+1, r24	; 0x01
    3114:	7c 83       	std	Y+4, r23	; 0x04
    3116:	6b 83       	std	Y+3, r22	; 0x03
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    3118:	e9 81       	ldd	r30, Y+1	; 0x01
    311a:	fa 81       	ldd	r31, Y+2	; 0x02
    311c:	84 8d       	ldd	r24, Z+28	; 0x1c
    311e:	88 23       	and	r24, r24
    3120:	89 f1       	breq	.+98     	; 0x3184 <prvCopyDataFromQueue+0x80>
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    3122:	e9 81       	ldd	r30, Y+1	; 0x01
    3124:	fa 81       	ldd	r31, Y+2	; 0x02
    3126:	26 81       	ldd	r18, Z+6	; 0x06
    3128:	37 81       	ldd	r19, Z+7	; 0x07
    312a:	e9 81       	ldd	r30, Y+1	; 0x01
    312c:	fa 81       	ldd	r31, Y+2	; 0x02
    312e:	84 8d       	ldd	r24, Z+28	; 0x1c
    3130:	88 2f       	mov	r24, r24
    3132:	90 e0       	ldi	r25, 0x00	; 0
    3134:	82 0f       	add	r24, r18
    3136:	93 1f       	adc	r25, r19
    3138:	e9 81       	ldd	r30, Y+1	; 0x01
    313a:	fa 81       	ldd	r31, Y+2	; 0x02
    313c:	97 83       	std	Z+7, r25	; 0x07
    313e:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    3140:	e9 81       	ldd	r30, Y+1	; 0x01
    3142:	fa 81       	ldd	r31, Y+2	; 0x02
    3144:	26 81       	ldd	r18, Z+6	; 0x06
    3146:	37 81       	ldd	r19, Z+7	; 0x07
    3148:	e9 81       	ldd	r30, Y+1	; 0x01
    314a:	fa 81       	ldd	r31, Y+2	; 0x02
    314c:	82 81       	ldd	r24, Z+2	; 0x02
    314e:	93 81       	ldd	r25, Z+3	; 0x03
    3150:	28 17       	cp	r18, r24
    3152:	39 07       	cpc	r19, r25
    3154:	40 f0       	brcs	.+16     	; 0x3166 <prvCopyDataFromQueue+0x62>
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
    3156:	e9 81       	ldd	r30, Y+1	; 0x01
    3158:	fa 81       	ldd	r31, Y+2	; 0x02
    315a:	80 81       	ld	r24, Z
    315c:	91 81       	ldd	r25, Z+1	; 0x01
    315e:	e9 81       	ldd	r30, Y+1	; 0x01
    3160:	fa 81       	ldd	r31, Y+2	; 0x02
    3162:	97 83       	std	Z+7, r25	; 0x07
    3164:	86 83       	std	Z+6, r24	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
    3166:	e9 81       	ldd	r30, Y+1	; 0x01
    3168:	fa 81       	ldd	r31, Y+2	; 0x02
    316a:	46 81       	ldd	r20, Z+6	; 0x06
    316c:	57 81       	ldd	r21, Z+7	; 0x07
    316e:	e9 81       	ldd	r30, Y+1	; 0x01
    3170:	fa 81       	ldd	r31, Y+2	; 0x02
    3172:	84 8d       	ldd	r24, Z+28	; 0x1c
    3174:	28 2f       	mov	r18, r24
    3176:	30 e0       	ldi	r19, 0x00	; 0
    3178:	8b 81       	ldd	r24, Y+3	; 0x03
    317a:	9c 81       	ldd	r25, Y+4	; 0x04
    317c:	ba 01       	movw	r22, r20
    317e:	a9 01       	movw	r20, r18
    3180:	0e 94 e3 36 	call	0x6dc6	; 0x6dc6 <memcpy>
	}
}
    3184:	0f 90       	pop	r0
    3186:	0f 90       	pop	r0
    3188:	0f 90       	pop	r0
    318a:	0f 90       	pop	r0
    318c:	cf 91       	pop	r28
    318e:	df 91       	pop	r29
    3190:	08 95       	ret

00003192 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    3192:	df 93       	push	r29
    3194:	cf 93       	push	r28
    3196:	00 d0       	rcall	.+0      	; 0x3198 <prvUnlockQueue+0x6>
    3198:	cd b7       	in	r28, 0x3d	; 61
    319a:	de b7       	in	r29, 0x3e	; 62
    319c:	9a 83       	std	Y+2, r25	; 0x02
    319e:	89 83       	std	Y+1, r24	; 0x01

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    31a0:	0f b6       	in	r0, 0x3f	; 63
    31a2:	f8 94       	cli
    31a4:	0f 92       	push	r0
    31a6:	15 c0       	rjmp	.+42     	; 0x31d2 <prvUnlockQueue+0x40>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    31a8:	e9 81       	ldd	r30, Y+1	; 0x01
    31aa:	fa 81       	ldd	r31, Y+2	; 0x02
    31ac:	81 89       	ldd	r24, Z+17	; 0x11
    31ae:	88 23       	and	r24, r24
    31b0:	a9 f0       	breq	.+42     	; 0x31dc <prvUnlockQueue+0x4a>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    31b2:	89 81       	ldd	r24, Y+1	; 0x01
    31b4:	9a 81       	ldd	r25, Y+2	; 0x02
    31b6:	41 96       	adiw	r24, 0x11	; 17
    31b8:	0e 94 f3 20 	call	0x41e6	; 0x41e6 <xTaskRemoveFromEventList>
    31bc:	88 23       	and	r24, r24
    31be:	11 f0       	breq	.+4      	; 0x31c4 <prvUnlockQueue+0x32>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						vTaskMissedYield();
    31c0:	0e 94 3f 22 	call	0x447e	; 0x447e <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
    31c4:	e9 81       	ldd	r30, Y+1	; 0x01
    31c6:	fa 81       	ldd	r31, Y+2	; 0x02
    31c8:	86 8d       	ldd	r24, Z+30	; 0x1e
    31ca:	81 50       	subi	r24, 0x01	; 1
    31cc:	e9 81       	ldd	r30, Y+1	; 0x01
    31ce:	fa 81       	ldd	r31, Y+2	; 0x02
    31d0:	86 8f       	std	Z+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    31d2:	e9 81       	ldd	r30, Y+1	; 0x01
    31d4:	fa 81       	ldd	r31, Y+2	; 0x02
    31d6:	86 8d       	ldd	r24, Z+30	; 0x1e
    31d8:	18 16       	cp	r1, r24
    31da:	34 f3       	brlt	.-52     	; 0x31a8 <prvUnlockQueue+0x16>
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
		}

		pxQueue->xTxLock = queueUNLOCKED;
    31dc:	e9 81       	ldd	r30, Y+1	; 0x01
    31de:	fa 81       	ldd	r31, Y+2	; 0x02
    31e0:	8f ef       	ldi	r24, 0xFF	; 255
    31e2:	86 8f       	std	Z+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    31e4:	0f 90       	pop	r0
    31e6:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    31e8:	0f b6       	in	r0, 0x3f	; 63
    31ea:	f8 94       	cli
    31ec:	0f 92       	push	r0
    31ee:	15 c0       	rjmp	.+42     	; 0x321a <prvUnlockQueue+0x88>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    31f0:	e9 81       	ldd	r30, Y+1	; 0x01
    31f2:	fa 81       	ldd	r31, Y+2	; 0x02
    31f4:	80 85       	ldd	r24, Z+8	; 0x08
    31f6:	88 23       	and	r24, r24
    31f8:	a9 f0       	breq	.+42     	; 0x3224 <prvUnlockQueue+0x92>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    31fa:	89 81       	ldd	r24, Y+1	; 0x01
    31fc:	9a 81       	ldd	r25, Y+2	; 0x02
    31fe:	08 96       	adiw	r24, 0x08	; 8
    3200:	0e 94 f3 20 	call	0x41e6	; 0x41e6 <xTaskRemoveFromEventList>
    3204:	88 23       	and	r24, r24
    3206:	11 f0       	breq	.+4      	; 0x320c <prvUnlockQueue+0x7a>
				{
					vTaskMissedYield();
    3208:	0e 94 3f 22 	call	0x447e	; 0x447e <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--( pxQueue->xRxLock );
    320c:	e9 81       	ldd	r30, Y+1	; 0x01
    320e:	fa 81       	ldd	r31, Y+2	; 0x02
    3210:	85 8d       	ldd	r24, Z+29	; 0x1d
    3212:	81 50       	subi	r24, 0x01	; 1
    3214:	e9 81       	ldd	r30, Y+1	; 0x01
    3216:	fa 81       	ldd	r31, Y+2	; 0x02
    3218:	85 8f       	std	Z+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    321a:	e9 81       	ldd	r30, Y+1	; 0x01
    321c:	fa 81       	ldd	r31, Y+2	; 0x02
    321e:	85 8d       	ldd	r24, Z+29	; 0x1d
    3220:	18 16       	cp	r1, r24
    3222:	34 f3       	brlt	.-52     	; 0x31f0 <prvUnlockQueue+0x5e>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    3224:	e9 81       	ldd	r30, Y+1	; 0x01
    3226:	fa 81       	ldd	r31, Y+2	; 0x02
    3228:	8f ef       	ldi	r24, 0xFF	; 255
    322a:	85 8f       	std	Z+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    322c:	0f 90       	pop	r0
    322e:	0f be       	out	0x3f, r0	; 63
}
    3230:	0f 90       	pop	r0
    3232:	0f 90       	pop	r0
    3234:	cf 91       	pop	r28
    3236:	df 91       	pop	r29
    3238:	08 95       	ret

0000323a <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
    323a:	df 93       	push	r29
    323c:	cf 93       	push	r28
    323e:	00 d0       	rcall	.+0      	; 0x3240 <prvIsQueueEmpty+0x6>
    3240:	0f 92       	push	r0
    3242:	cd b7       	in	r28, 0x3d	; 61
    3244:	de b7       	in	r29, 0x3e	; 62
    3246:	9b 83       	std	Y+3, r25	; 0x03
    3248:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	taskENTER_CRITICAL();
    324a:	0f b6       	in	r0, 0x3f	; 63
    324c:	f8 94       	cli
    324e:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    3250:	ea 81       	ldd	r30, Y+2	; 0x02
    3252:	fb 81       	ldd	r31, Y+3	; 0x03
    3254:	82 8d       	ldd	r24, Z+26	; 0x1a
    3256:	88 23       	and	r24, r24
    3258:	19 f4       	brne	.+6      	; 0x3260 <prvIsQueueEmpty+0x26>
		{
			xReturn = pdTRUE;
    325a:	81 e0       	ldi	r24, 0x01	; 1
    325c:	89 83       	std	Y+1, r24	; 0x01
    325e:	01 c0       	rjmp	.+2      	; 0x3262 <prvIsQueueEmpty+0x28>
		}
		else
		{
			xReturn = pdFALSE;
    3260:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    3262:	0f 90       	pop	r0
    3264:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    3266:	89 81       	ldd	r24, Y+1	; 0x01
}
    3268:	0f 90       	pop	r0
    326a:	0f 90       	pop	r0
    326c:	0f 90       	pop	r0
    326e:	cf 91       	pop	r28
    3270:	df 91       	pop	r29
    3272:	08 95       	ret

00003274 <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
{
    3274:	df 93       	push	r29
    3276:	cf 93       	push	r28
    3278:	00 d0       	rcall	.+0      	; 0x327a <xQueueIsQueueEmptyFromISR+0x6>
    327a:	0f 92       	push	r0
    327c:	cd b7       	in	r28, 0x3d	; 61
    327e:	de b7       	in	r29, 0x3e	; 62
    3280:	9b 83       	std	Y+3, r25	; 0x03
    3282:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	configASSERT( xQueue );
	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( UBaseType_t ) 0 )
    3284:	ea 81       	ldd	r30, Y+2	; 0x02
    3286:	fb 81       	ldd	r31, Y+3	; 0x03
    3288:	82 8d       	ldd	r24, Z+26	; 0x1a
    328a:	88 23       	and	r24, r24
    328c:	19 f4       	brne	.+6      	; 0x3294 <xQueueIsQueueEmptyFromISR+0x20>
	{
		xReturn = pdTRUE;
    328e:	81 e0       	ldi	r24, 0x01	; 1
    3290:	89 83       	std	Y+1, r24	; 0x01
    3292:	01 c0       	rjmp	.+2      	; 0x3296 <xQueueIsQueueEmptyFromISR+0x22>
	}
	else
	{
		xReturn = pdFALSE;
    3294:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    3296:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    3298:	0f 90       	pop	r0
    329a:	0f 90       	pop	r0
    329c:	0f 90       	pop	r0
    329e:	cf 91       	pop	r28
    32a0:	df 91       	pop	r29
    32a2:	08 95       	ret

000032a4 <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
    32a4:	df 93       	push	r29
    32a6:	cf 93       	push	r28
    32a8:	00 d0       	rcall	.+0      	; 0x32aa <prvIsQueueFull+0x6>
    32aa:	0f 92       	push	r0
    32ac:	cd b7       	in	r28, 0x3d	; 61
    32ae:	de b7       	in	r29, 0x3e	; 62
    32b0:	9b 83       	std	Y+3, r25	; 0x03
    32b2:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	taskENTER_CRITICAL();
    32b4:	0f b6       	in	r0, 0x3f	; 63
    32b6:	f8 94       	cli
    32b8:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    32ba:	ea 81       	ldd	r30, Y+2	; 0x02
    32bc:	fb 81       	ldd	r31, Y+3	; 0x03
    32be:	92 8d       	ldd	r25, Z+26	; 0x1a
    32c0:	ea 81       	ldd	r30, Y+2	; 0x02
    32c2:	fb 81       	ldd	r31, Y+3	; 0x03
    32c4:	83 8d       	ldd	r24, Z+27	; 0x1b
    32c6:	98 17       	cp	r25, r24
    32c8:	19 f4       	brne	.+6      	; 0x32d0 <prvIsQueueFull+0x2c>
		{
			xReturn = pdTRUE;
    32ca:	81 e0       	ldi	r24, 0x01	; 1
    32cc:	89 83       	std	Y+1, r24	; 0x01
    32ce:	01 c0       	rjmp	.+2      	; 0x32d2 <prvIsQueueFull+0x2e>
		}
		else
		{
			xReturn = pdFALSE;
    32d0:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    32d2:	0f 90       	pop	r0
    32d4:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    32d6:	89 81       	ldd	r24, Y+1	; 0x01
}
    32d8:	0f 90       	pop	r0
    32da:	0f 90       	pop	r0
    32dc:	0f 90       	pop	r0
    32de:	cf 91       	pop	r28
    32e0:	df 91       	pop	r29
    32e2:	08 95       	ret

000032e4 <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
    32e4:	df 93       	push	r29
    32e6:	cf 93       	push	r28
    32e8:	00 d0       	rcall	.+0      	; 0x32ea <xQueueIsQueueFullFromISR+0x6>
    32ea:	0f 92       	push	r0
    32ec:	cd b7       	in	r28, 0x3d	; 61
    32ee:	de b7       	in	r29, 0x3e	; 62
    32f0:	9b 83       	std	Y+3, r25	; 0x03
    32f2:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	configASSERT( xQueue );
	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( ( Queue_t * ) xQueue )->uxLength )
    32f4:	ea 81       	ldd	r30, Y+2	; 0x02
    32f6:	fb 81       	ldd	r31, Y+3	; 0x03
    32f8:	92 8d       	ldd	r25, Z+26	; 0x1a
    32fa:	ea 81       	ldd	r30, Y+2	; 0x02
    32fc:	fb 81       	ldd	r31, Y+3	; 0x03
    32fe:	83 8d       	ldd	r24, Z+27	; 0x1b
    3300:	98 17       	cp	r25, r24
    3302:	19 f4       	brne	.+6      	; 0x330a <xQueueIsQueueFullFromISR+0x26>
	{
		xReturn = pdTRUE;
    3304:	81 e0       	ldi	r24, 0x01	; 1
    3306:	89 83       	std	Y+1, r24	; 0x01
    3308:	01 c0       	rjmp	.+2      	; 0x330c <xQueueIsQueueFullFromISR+0x28>
	}
	else
	{
		xReturn = pdFALSE;
    330a:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    330c:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    330e:	0f 90       	pop	r0
    3310:	0f 90       	pop	r0
    3312:	0f 90       	pop	r0
    3314:	cf 91       	pop	r28
    3316:	df 91       	pop	r29
    3318:	08 95       	ret

0000331a <xQueueCRSend>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRSend( QueueHandle_t xQueue, const void *pvItemToQueue, TickType_t xTicksToWait )
	{
    331a:	df 93       	push	r29
    331c:	cf 93       	push	r28
    331e:	cd b7       	in	r28, 0x3d	; 61
    3320:	de b7       	in	r29, 0x3e	; 62
    3322:	2a 97       	sbiw	r28, 0x0a	; 10
    3324:	0f b6       	in	r0, 0x3f	; 63
    3326:	f8 94       	cli
    3328:	de bf       	out	0x3e, r29	; 62
    332a:	0f be       	out	0x3f, r0	; 63
    332c:	cd bf       	out	0x3d, r28	; 61
    332e:	9d 83       	std	Y+5, r25	; 0x05
    3330:	8c 83       	std	Y+4, r24	; 0x04
    3332:	7f 83       	std	Y+7, r23	; 0x07
    3334:	6e 83       	std	Y+6, r22	; 0x06
    3336:	59 87       	std	Y+9, r21	; 0x09
    3338:	48 87       	std	Y+8, r20	; 0x08
	BaseType_t xReturn;
	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    333a:	8c 81       	ldd	r24, Y+4	; 0x04
    333c:	9d 81       	ldd	r25, Y+5	; 0x05
    333e:	9a 83       	std	Y+2, r25	; 0x02
    3340:	89 83       	std	Y+1, r24	; 0x01

		/* If the queue is already full we may have to block.  A critical section
		is required to prevent an interrupt removing something from the queue
		between the check to see if the queue is full and blocking on the queue. */
		portDISABLE_INTERRUPTS();
    3342:	f8 94       	cli
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    3344:	89 81       	ldd	r24, Y+1	; 0x01
    3346:	9a 81       	ldd	r25, Y+2	; 0x02
    3348:	0e 94 52 19 	call	0x32a4	; 0x32a4 <prvIsQueueFull>
    334c:	88 23       	and	r24, r24
    334e:	a9 f0       	breq	.+42     	; 0x337a <xQueueCRSend+0x60>
			{
				/* The queue is full - do we want to block or just leave without
				posting? */
				if( xTicksToWait > ( TickType_t ) 0 )
    3350:	88 85       	ldd	r24, Y+8	; 0x08
    3352:	99 85       	ldd	r25, Y+9	; 0x09
    3354:	00 97       	sbiw	r24, 0x00	; 0
    3356:	71 f0       	breq	.+28     	; 0x3374 <xQueueCRSend+0x5a>
				{
					/* As this is called from a coroutine we cannot block directly, but
					return indicating that we need to block. */
					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToSend ) );
    3358:	89 81       	ldd	r24, Y+1	; 0x01
    335a:	9a 81       	ldd	r25, Y+2	; 0x02
    335c:	9c 01       	movw	r18, r24
    335e:	28 5f       	subi	r18, 0xF8	; 248
    3360:	3f 4f       	sbci	r19, 0xFF	; 255
    3362:	88 85       	ldd	r24, Y+8	; 0x08
    3364:	99 85       	ldd	r25, Y+9	; 0x09
    3366:	b9 01       	movw	r22, r18
    3368:	0e 94 aa 08 	call	0x1154	; 0x1154 <vCoRoutineAddToDelayedList>
					portENABLE_INTERRUPTS();
    336c:	78 94       	sei
					return errQUEUE_BLOCKED;
    336e:	8c ef       	ldi	r24, 0xFC	; 252
    3370:	8a 87       	std	Y+10, r24	; 0x0a
    3372:	2a c0       	rjmp	.+84     	; 0x33c8 <xQueueCRSend+0xae>
				}
				else
				{
					portENABLE_INTERRUPTS();
    3374:	78 94       	sei
					return errQUEUE_FULL;
    3376:	1a 86       	std	Y+10, r1	; 0x0a
    3378:	27 c0       	rjmp	.+78     	; 0x33c8 <xQueueCRSend+0xae>
				}
			}
		}
		portENABLE_INTERRUPTS();
    337a:	78 94       	sei

		portDISABLE_INTERRUPTS();
    337c:	f8 94       	cli
		{
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    337e:	e9 81       	ldd	r30, Y+1	; 0x01
    3380:	fa 81       	ldd	r31, Y+2	; 0x02
    3382:	92 8d       	ldd	r25, Z+26	; 0x1a
    3384:	e9 81       	ldd	r30, Y+1	; 0x01
    3386:	fa 81       	ldd	r31, Y+2	; 0x02
    3388:	83 8d       	ldd	r24, Z+27	; 0x1b
    338a:	98 17       	cp	r25, r24
    338c:	c8 f4       	brcc	.+50     	; 0x33c0 <xQueueCRSend+0xa6>
			{
				/* There is room in the queue, copy the data into the queue. */
				prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
    338e:	89 81       	ldd	r24, Y+1	; 0x01
    3390:	9a 81       	ldd	r25, Y+2	; 0x02
    3392:	2e 81       	ldd	r18, Y+6	; 0x06
    3394:	3f 81       	ldd	r19, Y+7	; 0x07
    3396:	b9 01       	movw	r22, r18
    3398:	40 e0       	ldi	r20, 0x00	; 0
    339a:	0e 94 c9 17 	call	0x2f92	; 0x2f92 <prvCopyDataToQueue>
				xReturn = pdPASS;
    339e:	81 e0       	ldi	r24, 0x01	; 1
    33a0:	8b 83       	std	Y+3, r24	; 0x03

				/* Were any co-routines waiting for data to become available? */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    33a2:	e9 81       	ldd	r30, Y+1	; 0x01
    33a4:	fa 81       	ldd	r31, Y+2	; 0x02
    33a6:	81 89       	ldd	r24, Z+17	; 0x11
    33a8:	88 23       	and	r24, r24
    33aa:	59 f0       	breq	.+22     	; 0x33c2 <xQueueCRSend+0xa8>
				{
					/* In this instance the co-routine could be placed directly
					into the ready list as we are within a critical section.
					Instead the same pending ready list mechanism is used as if
					the event were caused from within an interrupt. */
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    33ac:	89 81       	ldd	r24, Y+1	; 0x01
    33ae:	9a 81       	ldd	r25, Y+2	; 0x02
    33b0:	41 96       	adiw	r24, 0x11	; 17
    33b2:	0e 94 b6 0a 	call	0x156c	; 0x156c <xCoRoutineRemoveFromEventList>
    33b6:	88 23       	and	r24, r24
    33b8:	21 f0       	breq	.+8      	; 0x33c2 <xQueueCRSend+0xa8>
					{
						/* The co-routine waiting has a higher priority so record
						that a yield might be appropriate. */
						xReturn = errQUEUE_YIELD;
    33ba:	8b ef       	ldi	r24, 0xFB	; 251
    33bc:	8b 83       	std	Y+3, r24	; 0x03
    33be:	01 c0       	rjmp	.+2      	; 0x33c2 <xQueueCRSend+0xa8>
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else
			{
				xReturn = errQUEUE_FULL;
    33c0:	1b 82       	std	Y+3, r1	; 0x03
			}
		}
		portENABLE_INTERRUPTS();
    33c2:	78 94       	sei

		return xReturn;
    33c4:	8b 81       	ldd	r24, Y+3	; 0x03
    33c6:	8a 87       	std	Y+10, r24	; 0x0a
    33c8:	8a 85       	ldd	r24, Y+10	; 0x0a
	}
    33ca:	2a 96       	adiw	r28, 0x0a	; 10
    33cc:	0f b6       	in	r0, 0x3f	; 63
    33ce:	f8 94       	cli
    33d0:	de bf       	out	0x3e, r29	; 62
    33d2:	0f be       	out	0x3f, r0	; 63
    33d4:	cd bf       	out	0x3d, r28	; 61
    33d6:	cf 91       	pop	r28
    33d8:	df 91       	pop	r29
    33da:	08 95       	ret

000033dc <xQueueCRReceive>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRReceive( QueueHandle_t xQueue, void *pvBuffer, TickType_t xTicksToWait )
	{
    33dc:	df 93       	push	r29
    33de:	cf 93       	push	r28
    33e0:	cd b7       	in	r28, 0x3d	; 61
    33e2:	de b7       	in	r29, 0x3e	; 62
    33e4:	2a 97       	sbiw	r28, 0x0a	; 10
    33e6:	0f b6       	in	r0, 0x3f	; 63
    33e8:	f8 94       	cli
    33ea:	de bf       	out	0x3e, r29	; 62
    33ec:	0f be       	out	0x3f, r0	; 63
    33ee:	cd bf       	out	0x3d, r28	; 61
    33f0:	9d 83       	std	Y+5, r25	; 0x05
    33f2:	8c 83       	std	Y+4, r24	; 0x04
    33f4:	7f 83       	std	Y+7, r23	; 0x07
    33f6:	6e 83       	std	Y+6, r22	; 0x06
    33f8:	59 87       	std	Y+9, r21	; 0x09
    33fa:	48 87       	std	Y+8, r20	; 0x08
	BaseType_t xReturn;
	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    33fc:	8c 81       	ldd	r24, Y+4	; 0x04
    33fe:	9d 81       	ldd	r25, Y+5	; 0x05
    3400:	9a 83       	std	Y+2, r25	; 0x02
    3402:	89 83       	std	Y+1, r24	; 0x01

		/* If the queue is already empty we may have to block.  A critical section
		is required to prevent an interrupt adding something to the queue
		between the check to see if the queue is empty and blocking on the queue. */
		portDISABLE_INTERRUPTS();
    3404:	f8 94       	cli
		{
			if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    3406:	e9 81       	ldd	r30, Y+1	; 0x01
    3408:	fa 81       	ldd	r31, Y+2	; 0x02
    340a:	82 8d       	ldd	r24, Z+26	; 0x1a
    340c:	88 23       	and	r24, r24
    340e:	a9 f4       	brne	.+42     	; 0x343a <xQueueCRReceive+0x5e>
			{
				/* There are no messages in the queue, do we want to block or just
				leave with nothing? */
				if( xTicksToWait > ( TickType_t ) 0 )
    3410:	88 85       	ldd	r24, Y+8	; 0x08
    3412:	99 85       	ldd	r25, Y+9	; 0x09
    3414:	00 97       	sbiw	r24, 0x00	; 0
    3416:	71 f0       	breq	.+28     	; 0x3434 <xQueueCRReceive+0x58>
				{
					/* As this is a co-routine we cannot block directly, but return
					indicating that we need to block. */
					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToReceive ) );
    3418:	89 81       	ldd	r24, Y+1	; 0x01
    341a:	9a 81       	ldd	r25, Y+2	; 0x02
    341c:	9c 01       	movw	r18, r24
    341e:	2f 5e       	subi	r18, 0xEF	; 239
    3420:	3f 4f       	sbci	r19, 0xFF	; 255
    3422:	88 85       	ldd	r24, Y+8	; 0x08
    3424:	99 85       	ldd	r25, Y+9	; 0x09
    3426:	b9 01       	movw	r22, r18
    3428:	0e 94 aa 08 	call	0x1154	; 0x1154 <vCoRoutineAddToDelayedList>
					portENABLE_INTERRUPTS();
    342c:	78 94       	sei
					return errQUEUE_BLOCKED;
    342e:	8c ef       	ldi	r24, 0xFC	; 252
    3430:	8a 87       	std	Y+10, r24	; 0x0a
    3432:	58 c0       	rjmp	.+176    	; 0x34e4 <xQueueCRReceive+0x108>
				}
				else
				{
					portENABLE_INTERRUPTS();
    3434:	78 94       	sei
					return errQUEUE_FULL;
    3436:	1a 86       	std	Y+10, r1	; 0x0a
    3438:	55 c0       	rjmp	.+170    	; 0x34e4 <xQueueCRReceive+0x108>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		portENABLE_INTERRUPTS();
    343a:	78 94       	sei

		portDISABLE_INTERRUPTS();
    343c:	f8 94       	cli
		{
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    343e:	e9 81       	ldd	r30, Y+1	; 0x01
    3440:	fa 81       	ldd	r31, Y+2	; 0x02
    3442:	82 8d       	ldd	r24, Z+26	; 0x1a
    3444:	88 23       	and	r24, r24
    3446:	09 f4       	brne	.+2      	; 0x344a <xQueueCRReceive+0x6e>
    3448:	49 c0       	rjmp	.+146    	; 0x34dc <xQueueCRReceive+0x100>
			{
				/* Data is available from the queue. */
				pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    344a:	e9 81       	ldd	r30, Y+1	; 0x01
    344c:	fa 81       	ldd	r31, Y+2	; 0x02
    344e:	26 81       	ldd	r18, Z+6	; 0x06
    3450:	37 81       	ldd	r19, Z+7	; 0x07
    3452:	e9 81       	ldd	r30, Y+1	; 0x01
    3454:	fa 81       	ldd	r31, Y+2	; 0x02
    3456:	84 8d       	ldd	r24, Z+28	; 0x1c
    3458:	88 2f       	mov	r24, r24
    345a:	90 e0       	ldi	r25, 0x00	; 0
    345c:	82 0f       	add	r24, r18
    345e:	93 1f       	adc	r25, r19
    3460:	e9 81       	ldd	r30, Y+1	; 0x01
    3462:	fa 81       	ldd	r31, Y+2	; 0x02
    3464:	97 83       	std	Z+7, r25	; 0x07
    3466:	86 83       	std	Z+6, r24	; 0x06
				if( pxQueue->u.pcReadFrom >= pxQueue->pcTail )
    3468:	e9 81       	ldd	r30, Y+1	; 0x01
    346a:	fa 81       	ldd	r31, Y+2	; 0x02
    346c:	26 81       	ldd	r18, Z+6	; 0x06
    346e:	37 81       	ldd	r19, Z+7	; 0x07
    3470:	e9 81       	ldd	r30, Y+1	; 0x01
    3472:	fa 81       	ldd	r31, Y+2	; 0x02
    3474:	82 81       	ldd	r24, Z+2	; 0x02
    3476:	93 81       	ldd	r25, Z+3	; 0x03
    3478:	28 17       	cp	r18, r24
    347a:	39 07       	cpc	r19, r25
    347c:	40 f0       	brcs	.+16     	; 0x348e <xQueueCRReceive+0xb2>
				{
					pxQueue->u.pcReadFrom = pxQueue->pcHead;
    347e:	e9 81       	ldd	r30, Y+1	; 0x01
    3480:	fa 81       	ldd	r31, Y+2	; 0x02
    3482:	80 81       	ld	r24, Z
    3484:	91 81       	ldd	r25, Z+1	; 0x01
    3486:	e9 81       	ldd	r30, Y+1	; 0x01
    3488:	fa 81       	ldd	r31, Y+2	; 0x02
    348a:	97 83       	std	Z+7, r25	; 0x07
    348c:	86 83       	std	Z+6, r24	; 0x06
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				--( pxQueue->uxMessagesWaiting );
    348e:	e9 81       	ldd	r30, Y+1	; 0x01
    3490:	fa 81       	ldd	r31, Y+2	; 0x02
    3492:	82 8d       	ldd	r24, Z+26	; 0x1a
    3494:	81 50       	subi	r24, 0x01	; 1
    3496:	e9 81       	ldd	r30, Y+1	; 0x01
    3498:	fa 81       	ldd	r31, Y+2	; 0x02
    349a:	82 8f       	std	Z+26, r24	; 0x1a
				( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    349c:	e9 81       	ldd	r30, Y+1	; 0x01
    349e:	fa 81       	ldd	r31, Y+2	; 0x02
    34a0:	46 81       	ldd	r20, Z+6	; 0x06
    34a2:	57 81       	ldd	r21, Z+7	; 0x07
    34a4:	e9 81       	ldd	r30, Y+1	; 0x01
    34a6:	fa 81       	ldd	r31, Y+2	; 0x02
    34a8:	84 8d       	ldd	r24, Z+28	; 0x1c
    34aa:	28 2f       	mov	r18, r24
    34ac:	30 e0       	ldi	r19, 0x00	; 0
    34ae:	8e 81       	ldd	r24, Y+6	; 0x06
    34b0:	9f 81       	ldd	r25, Y+7	; 0x07
    34b2:	ba 01       	movw	r22, r20
    34b4:	a9 01       	movw	r20, r18
    34b6:	0e 94 e3 36 	call	0x6dc6	; 0x6dc6 <memcpy>

				xReturn = pdPASS;
    34ba:	81 e0       	ldi	r24, 0x01	; 1
    34bc:	8b 83       	std	Y+3, r24	; 0x03

				/* Were any co-routines waiting for space to become available? */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    34be:	e9 81       	ldd	r30, Y+1	; 0x01
    34c0:	fa 81       	ldd	r31, Y+2	; 0x02
    34c2:	80 85       	ldd	r24, Z+8	; 0x08
    34c4:	88 23       	and	r24, r24
    34c6:	59 f0       	breq	.+22     	; 0x34de <xQueueCRReceive+0x102>
				{
					/* In this instance the co-routine could be placed directly
					into the ready list as we are within a critical section.
					Instead the same pending ready list mechanism is used as if
					the event were caused from within an interrupt. */
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    34c8:	89 81       	ldd	r24, Y+1	; 0x01
    34ca:	9a 81       	ldd	r25, Y+2	; 0x02
    34cc:	08 96       	adiw	r24, 0x08	; 8
    34ce:	0e 94 b6 0a 	call	0x156c	; 0x156c <xCoRoutineRemoveFromEventList>
    34d2:	88 23       	and	r24, r24
    34d4:	21 f0       	breq	.+8      	; 0x34de <xQueueCRReceive+0x102>
					{
						xReturn = errQUEUE_YIELD;
    34d6:	8b ef       	ldi	r24, 0xFB	; 251
    34d8:	8b 83       	std	Y+3, r24	; 0x03
    34da:	01 c0       	rjmp	.+2      	; 0x34de <xQueueCRReceive+0x102>
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else
			{
				xReturn = pdFAIL;
    34dc:	1b 82       	std	Y+3, r1	; 0x03
			}
		}
		portENABLE_INTERRUPTS();
    34de:	78 94       	sei

		return xReturn;
    34e0:	8b 81       	ldd	r24, Y+3	; 0x03
    34e2:	8a 87       	std	Y+10, r24	; 0x0a
    34e4:	8a 85       	ldd	r24, Y+10	; 0x0a
	}
    34e6:	2a 96       	adiw	r28, 0x0a	; 10
    34e8:	0f b6       	in	r0, 0x3f	; 63
    34ea:	f8 94       	cli
    34ec:	de bf       	out	0x3e, r29	; 62
    34ee:	0f be       	out	0x3f, r0	; 63
    34f0:	cd bf       	out	0x3d, r28	; 61
    34f2:	cf 91       	pop	r28
    34f4:	df 91       	pop	r29
    34f6:	08 95       	ret

000034f8 <xQueueCRSendFromISR>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRSendFromISR( QueueHandle_t xQueue, const void *pvItemToQueue, BaseType_t xCoRoutinePreviouslyWoken )
	{
    34f8:	df 93       	push	r29
    34fa:	cf 93       	push	r28
    34fc:	cd b7       	in	r28, 0x3d	; 61
    34fe:	de b7       	in	r29, 0x3e	; 62
    3500:	28 97       	sbiw	r28, 0x08	; 8
    3502:	0f b6       	in	r0, 0x3f	; 63
    3504:	f8 94       	cli
    3506:	de bf       	out	0x3e, r29	; 62
    3508:	0f be       	out	0x3f, r0	; 63
    350a:	cd bf       	out	0x3d, r28	; 61
    350c:	9c 83       	std	Y+4, r25	; 0x04
    350e:	8b 83       	std	Y+3, r24	; 0x03
    3510:	7e 83       	std	Y+6, r23	; 0x06
    3512:	6d 83       	std	Y+5, r22	; 0x05
    3514:	4f 83       	std	Y+7, r20	; 0x07
	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    3516:	8b 81       	ldd	r24, Y+3	; 0x03
    3518:	9c 81       	ldd	r25, Y+4	; 0x04
    351a:	9a 83       	std	Y+2, r25	; 0x02
    351c:	89 83       	std	Y+1, r24	; 0x01

		/* Cannot block within an ISR so if there is no space on the queue then
		exit without doing anything. */
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    351e:	e9 81       	ldd	r30, Y+1	; 0x01
    3520:	fa 81       	ldd	r31, Y+2	; 0x02
    3522:	92 8d       	ldd	r25, Z+26	; 0x1a
    3524:	e9 81       	ldd	r30, Y+1	; 0x01
    3526:	fa 81       	ldd	r31, Y+2	; 0x02
    3528:	83 8d       	ldd	r24, Z+27	; 0x1b
    352a:	98 17       	cp	r25, r24
    352c:	d0 f4       	brcc	.+52     	; 0x3562 <xQueueCRSendFromISR+0x6a>
		{
			prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
    352e:	89 81       	ldd	r24, Y+1	; 0x01
    3530:	9a 81       	ldd	r25, Y+2	; 0x02
    3532:	2d 81       	ldd	r18, Y+5	; 0x05
    3534:	3e 81       	ldd	r19, Y+6	; 0x06
    3536:	b9 01       	movw	r22, r18
    3538:	40 e0       	ldi	r20, 0x00	; 0
    353a:	0e 94 c9 17 	call	0x2f92	; 0x2f92 <prvCopyDataToQueue>

			/* We only want to wake one co-routine per ISR, so check that a
			co-routine has not already been woken. */
			if( xCoRoutinePreviouslyWoken == pdFALSE )
    353e:	8f 81       	ldd	r24, Y+7	; 0x07
    3540:	88 23       	and	r24, r24
    3542:	79 f4       	brne	.+30     	; 0x3562 <xQueueCRSendFromISR+0x6a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    3544:	e9 81       	ldd	r30, Y+1	; 0x01
    3546:	fa 81       	ldd	r31, Y+2	; 0x02
    3548:	81 89       	ldd	r24, Z+17	; 0x11
    354a:	88 23       	and	r24, r24
    354c:	51 f0       	breq	.+20     	; 0x3562 <xQueueCRSendFromISR+0x6a>
				{
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    354e:	89 81       	ldd	r24, Y+1	; 0x01
    3550:	9a 81       	ldd	r25, Y+2	; 0x02
    3552:	41 96       	adiw	r24, 0x11	; 17
    3554:	0e 94 b6 0a 	call	0x156c	; 0x156c <xCoRoutineRemoveFromEventList>
    3558:	88 23       	and	r24, r24
    355a:	19 f0       	breq	.+6      	; 0x3562 <xQueueCRSendFromISR+0x6a>
					{
						return pdTRUE;
    355c:	81 e0       	ldi	r24, 0x01	; 1
    355e:	88 87       	std	Y+8, r24	; 0x08
    3560:	02 c0       	rjmp	.+4      	; 0x3566 <xQueueCRSendFromISR+0x6e>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xCoRoutinePreviouslyWoken;
    3562:	8f 81       	ldd	r24, Y+7	; 0x07
    3564:	88 87       	std	Y+8, r24	; 0x08
    3566:	88 85       	ldd	r24, Y+8	; 0x08
	}
    3568:	28 96       	adiw	r28, 0x08	; 8
    356a:	0f b6       	in	r0, 0x3f	; 63
    356c:	f8 94       	cli
    356e:	de bf       	out	0x3e, r29	; 62
    3570:	0f be       	out	0x3f, r0	; 63
    3572:	cd bf       	out	0x3d, r28	; 61
    3574:	cf 91       	pop	r28
    3576:	df 91       	pop	r29
    3578:	08 95       	ret

0000357a <xQueueCRReceiveFromISR>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRReceiveFromISR( QueueHandle_t xQueue, void *pvBuffer, BaseType_t *pxCoRoutineWoken )
	{
    357a:	df 93       	push	r29
    357c:	cf 93       	push	r28
    357e:	cd b7       	in	r28, 0x3d	; 61
    3580:	de b7       	in	r29, 0x3e	; 62
    3582:	29 97       	sbiw	r28, 0x09	; 9
    3584:	0f b6       	in	r0, 0x3f	; 63
    3586:	f8 94       	cli
    3588:	de bf       	out	0x3e, r29	; 62
    358a:	0f be       	out	0x3f, r0	; 63
    358c:	cd bf       	out	0x3d, r28	; 61
    358e:	9d 83       	std	Y+5, r25	; 0x05
    3590:	8c 83       	std	Y+4, r24	; 0x04
    3592:	7f 83       	std	Y+7, r23	; 0x07
    3594:	6e 83       	std	Y+6, r22	; 0x06
    3596:	59 87       	std	Y+9, r21	; 0x09
    3598:	48 87       	std	Y+8, r20	; 0x08
	BaseType_t xReturn;
	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    359a:	8c 81       	ldd	r24, Y+4	; 0x04
    359c:	9d 81       	ldd	r25, Y+5	; 0x05
    359e:	9a 83       	std	Y+2, r25	; 0x02
    35a0:	89 83       	std	Y+1, r24	; 0x01

		/* We cannot block from an ISR, so check there is data available. If
		not then just leave without doing anything. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    35a2:	e9 81       	ldd	r30, Y+1	; 0x01
    35a4:	fa 81       	ldd	r31, Y+2	; 0x02
    35a6:	82 8d       	ldd	r24, Z+26	; 0x1a
    35a8:	88 23       	and	r24, r24
    35aa:	09 f4       	brne	.+2      	; 0x35ae <xQueueCRReceiveFromISR+0x34>
    35ac:	50 c0       	rjmp	.+160    	; 0x364e <xQueueCRReceiveFromISR+0xd4>
		{
			/* Copy the data from the queue. */
			pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    35ae:	e9 81       	ldd	r30, Y+1	; 0x01
    35b0:	fa 81       	ldd	r31, Y+2	; 0x02
    35b2:	26 81       	ldd	r18, Z+6	; 0x06
    35b4:	37 81       	ldd	r19, Z+7	; 0x07
    35b6:	e9 81       	ldd	r30, Y+1	; 0x01
    35b8:	fa 81       	ldd	r31, Y+2	; 0x02
    35ba:	84 8d       	ldd	r24, Z+28	; 0x1c
    35bc:	88 2f       	mov	r24, r24
    35be:	90 e0       	ldi	r25, 0x00	; 0
    35c0:	82 0f       	add	r24, r18
    35c2:	93 1f       	adc	r25, r19
    35c4:	e9 81       	ldd	r30, Y+1	; 0x01
    35c6:	fa 81       	ldd	r31, Y+2	; 0x02
    35c8:	97 83       	std	Z+7, r25	; 0x07
    35ca:	86 83       	std	Z+6, r24	; 0x06
			if( pxQueue->u.pcReadFrom >= pxQueue->pcTail )
    35cc:	e9 81       	ldd	r30, Y+1	; 0x01
    35ce:	fa 81       	ldd	r31, Y+2	; 0x02
    35d0:	26 81       	ldd	r18, Z+6	; 0x06
    35d2:	37 81       	ldd	r19, Z+7	; 0x07
    35d4:	e9 81       	ldd	r30, Y+1	; 0x01
    35d6:	fa 81       	ldd	r31, Y+2	; 0x02
    35d8:	82 81       	ldd	r24, Z+2	; 0x02
    35da:	93 81       	ldd	r25, Z+3	; 0x03
    35dc:	28 17       	cp	r18, r24
    35de:	39 07       	cpc	r19, r25
    35e0:	40 f0       	brcs	.+16     	; 0x35f2 <xQueueCRReceiveFromISR+0x78>
			{
				pxQueue->u.pcReadFrom = pxQueue->pcHead;
    35e2:	e9 81       	ldd	r30, Y+1	; 0x01
    35e4:	fa 81       	ldd	r31, Y+2	; 0x02
    35e6:	80 81       	ld	r24, Z
    35e8:	91 81       	ldd	r25, Z+1	; 0x01
    35ea:	e9 81       	ldd	r30, Y+1	; 0x01
    35ec:	fa 81       	ldd	r31, Y+2	; 0x02
    35ee:	97 83       	std	Z+7, r25	; 0x07
    35f0:	86 83       	std	Z+6, r24	; 0x06
			}
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
			--( pxQueue->uxMessagesWaiting );
    35f2:	e9 81       	ldd	r30, Y+1	; 0x01
    35f4:	fa 81       	ldd	r31, Y+2	; 0x02
    35f6:	82 8d       	ldd	r24, Z+26	; 0x1a
    35f8:	81 50       	subi	r24, 0x01	; 1
    35fa:	e9 81       	ldd	r30, Y+1	; 0x01
    35fc:	fa 81       	ldd	r31, Y+2	; 0x02
    35fe:	82 8f       	std	Z+26, r24	; 0x1a
			( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    3600:	e9 81       	ldd	r30, Y+1	; 0x01
    3602:	fa 81       	ldd	r31, Y+2	; 0x02
    3604:	46 81       	ldd	r20, Z+6	; 0x06
    3606:	57 81       	ldd	r21, Z+7	; 0x07
    3608:	e9 81       	ldd	r30, Y+1	; 0x01
    360a:	fa 81       	ldd	r31, Y+2	; 0x02
    360c:	84 8d       	ldd	r24, Z+28	; 0x1c
    360e:	28 2f       	mov	r18, r24
    3610:	30 e0       	ldi	r19, 0x00	; 0
    3612:	8e 81       	ldd	r24, Y+6	; 0x06
    3614:	9f 81       	ldd	r25, Y+7	; 0x07
    3616:	ba 01       	movw	r22, r20
    3618:	a9 01       	movw	r20, r18
    361a:	0e 94 e3 36 	call	0x6dc6	; 0x6dc6 <memcpy>

			if( ( *pxCoRoutineWoken ) == pdFALSE )
    361e:	e8 85       	ldd	r30, Y+8	; 0x08
    3620:	f9 85       	ldd	r31, Y+9	; 0x09
    3622:	80 81       	ld	r24, Z
    3624:	88 23       	and	r24, r24
    3626:	81 f4       	brne	.+32     	; 0x3648 <xQueueCRReceiveFromISR+0xce>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    3628:	e9 81       	ldd	r30, Y+1	; 0x01
    362a:	fa 81       	ldd	r31, Y+2	; 0x02
    362c:	80 85       	ldd	r24, Z+8	; 0x08
    362e:	88 23       	and	r24, r24
    3630:	59 f0       	breq	.+22     	; 0x3648 <xQueueCRReceiveFromISR+0xce>
				{
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    3632:	89 81       	ldd	r24, Y+1	; 0x01
    3634:	9a 81       	ldd	r25, Y+2	; 0x02
    3636:	08 96       	adiw	r24, 0x08	; 8
    3638:	0e 94 b6 0a 	call	0x156c	; 0x156c <xCoRoutineRemoveFromEventList>
    363c:	88 23       	and	r24, r24
    363e:	21 f0       	breq	.+8      	; 0x3648 <xQueueCRReceiveFromISR+0xce>
					{
						*pxCoRoutineWoken = pdTRUE;
    3640:	e8 85       	ldd	r30, Y+8	; 0x08
    3642:	f9 85       	ldd	r31, Y+9	; 0x09
    3644:	81 e0       	ldi	r24, 0x01	; 1
    3646:	80 83       	st	Z, r24
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			xReturn = pdPASS;
    3648:	81 e0       	ldi	r24, 0x01	; 1
    364a:	8b 83       	std	Y+3, r24	; 0x03
    364c:	01 c0       	rjmp	.+2      	; 0x3650 <xQueueCRReceiveFromISR+0xd6>
		}
		else
		{
			xReturn = pdFAIL;
    364e:	1b 82       	std	Y+3, r1	; 0x03
		}

		return xReturn;
    3650:	8b 81       	ldd	r24, Y+3	; 0x03
	}
    3652:	29 96       	adiw	r28, 0x09	; 9
    3654:	0f b6       	in	r0, 0x3f	; 63
    3656:	f8 94       	cli
    3658:	de bf       	out	0x3e, r29	; 62
    365a:	0f be       	out	0x3f, r0	; 63
    365c:	cd bf       	out	0x3d, r28	; 61
    365e:	cf 91       	pop	r28
    3660:	df 91       	pop	r29
    3662:	08 95       	ret

00003664 <xTaskGenericCreate>:
static void prvResetNextTaskUnblockTime( void );

/*-----------------------------------------------------------*/

BaseType_t xTaskGenericCreate( TaskFunction_t pxTaskCode, const char * const pcName, const uint16_t usStackDepth, void * const pvParameters, UBaseType_t uxPriority, TaskHandle_t * const pxCreatedTask, StackType_t * const puxStackBuffer, const MemoryRegion_t * const xRegions ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
    3664:	af 92       	push	r10
    3666:	bf 92       	push	r11
    3668:	cf 92       	push	r12
    366a:	df 92       	push	r13
    366c:	ef 92       	push	r14
    366e:	ff 92       	push	r15
    3670:	0f 93       	push	r16
    3672:	1f 93       	push	r17
    3674:	df 93       	push	r29
    3676:	cf 93       	push	r28
    3678:	cd b7       	in	r28, 0x3d	; 61
    367a:	de b7       	in	r29, 0x3e	; 62
    367c:	64 97       	sbiw	r28, 0x14	; 20
    367e:	0f b6       	in	r0, 0x3f	; 63
    3680:	f8 94       	cli
    3682:	de bf       	out	0x3e, r29	; 62
    3684:	0f be       	out	0x3f, r0	; 63
    3686:	cd bf       	out	0x3d, r28	; 61
    3688:	9f 83       	std	Y+7, r25	; 0x07
    368a:	8e 83       	std	Y+6, r24	; 0x06
    368c:	79 87       	std	Y+9, r23	; 0x09
    368e:	68 87       	std	Y+8, r22	; 0x08
    3690:	5b 87       	std	Y+11, r21	; 0x0b
    3692:	4a 87       	std	Y+10, r20	; 0x0a
    3694:	3d 87       	std	Y+13, r19	; 0x0d
    3696:	2c 87       	std	Y+12, r18	; 0x0c
    3698:	0e 87       	std	Y+14, r16	; 0x0e
    369a:	f8 8a       	std	Y+16, r15	; 0x10
    369c:	ef 86       	std	Y+15, r14	; 0x0f
    369e:	da 8a       	std	Y+18, r13	; 0x12
    36a0:	c9 8a       	std	Y+17, r12	; 0x11
    36a2:	bc 8a       	std	Y+20, r11	; 0x14
    36a4:	ab 8a       	std	Y+19, r10	; 0x13
	configASSERT( pxTaskCode );
	configASSERT( ( ( uxPriority & ( ~portPRIVILEGE_BIT ) ) < configMAX_PRIORITIES ) );

	/* Allocate the memory required by the TCB and stack for the new task,
	checking that the allocation was successful. */
	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
    36a6:	8a 85       	ldd	r24, Y+10	; 0x0a
    36a8:	9b 85       	ldd	r25, Y+11	; 0x0b
    36aa:	29 89       	ldd	r18, Y+17	; 0x11
    36ac:	3a 89       	ldd	r19, Y+18	; 0x12
    36ae:	b9 01       	movw	r22, r18
    36b0:	0e 94 98 23 	call	0x4730	; 0x4730 <prvAllocateTCBAndStack>
    36b4:	9c 83       	std	Y+4, r25	; 0x04
    36b6:	8b 83       	std	Y+3, r24	; 0x03

	if( pxNewTCB != NULL )
    36b8:	8b 81       	ldd	r24, Y+3	; 0x03
    36ba:	9c 81       	ldd	r25, Y+4	; 0x04
    36bc:	00 97       	sbiw	r24, 0x00	; 0
    36be:	09 f4       	brne	.+2      	; 0x36c2 <xTaskGenericCreate+0x5e>
    36c0:	8d c0       	rjmp	.+282    	; 0x37dc <xTaskGenericCreate+0x178>
		stack grows from high memory to low (as per the 80x86) or vice versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( uint16_t ) 1 );
    36c2:	eb 81       	ldd	r30, Y+3	; 0x03
    36c4:	fc 81       	ldd	r31, Y+4	; 0x04
    36c6:	27 89       	ldd	r18, Z+23	; 0x17
    36c8:	30 8d       	ldd	r19, Z+24	; 0x18
    36ca:	8a 85       	ldd	r24, Y+10	; 0x0a
    36cc:	9b 85       	ldd	r25, Y+11	; 0x0b
    36ce:	01 97       	sbiw	r24, 0x01	; 1
    36d0:	82 0f       	add	r24, r18
    36d2:	93 1f       	adc	r25, r19
    36d4:	9a 83       	std	Y+2, r25	; 0x02
    36d6:	89 83       	std	Y+1, r24	; 0x01
			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
		}
		#endif /* portSTACK_GROWTH */

		/* Setup the newly allocated TCB with the initial state of the task. */
		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
    36d8:	8b 81       	ldd	r24, Y+3	; 0x03
    36da:	9c 81       	ldd	r25, Y+4	; 0x04
    36dc:	28 85       	ldd	r18, Y+8	; 0x08
    36de:	39 85       	ldd	r19, Y+9	; 0x09
    36e0:	eb 89       	ldd	r30, Y+19	; 0x13
    36e2:	fc 89       	ldd	r31, Y+20	; 0x14
    36e4:	aa 85       	ldd	r26, Y+10	; 0x0a
    36e6:	bb 85       	ldd	r27, Y+11	; 0x0b
    36e8:	b9 01       	movw	r22, r18
    36ea:	4e 85       	ldd	r20, Y+14	; 0x0e
    36ec:	9f 01       	movw	r18, r30
    36ee:	8d 01       	movw	r16, r26
    36f0:	0e 94 59 22 	call	0x44b2	; 0x44b2 <prvInitialiseTCBVariables>
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else /* portUSING_MPU_WRAPPERS */
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    36f4:	89 81       	ldd	r24, Y+1	; 0x01
    36f6:	9a 81       	ldd	r25, Y+2	; 0x02
    36f8:	2e 81       	ldd	r18, Y+6	; 0x06
    36fa:	3f 81       	ldd	r19, Y+7	; 0x07
    36fc:	4c 85       	ldd	r20, Y+12	; 0x0c
    36fe:	5d 85       	ldd	r21, Y+13	; 0x0d
    3700:	b9 01       	movw	r22, r18
    3702:	0e 94 b2 10 	call	0x2164	; 0x2164 <pxPortInitialiseStack>
    3706:	eb 81       	ldd	r30, Y+3	; 0x03
    3708:	fc 81       	ldd	r31, Y+4	; 0x04
    370a:	91 83       	std	Z+1, r25	; 0x01
    370c:	80 83       	st	Z, r24
		}
		#endif /* portUSING_MPU_WRAPPERS */

		if( ( void * ) pxCreatedTask != NULL )
    370e:	8f 85       	ldd	r24, Y+15	; 0x0f
    3710:	98 89       	ldd	r25, Y+16	; 0x10
    3712:	00 97       	sbiw	r24, 0x00	; 0
    3714:	31 f0       	breq	.+12     	; 0x3722 <xTaskGenericCreate+0xbe>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    3716:	ef 85       	ldd	r30, Y+15	; 0x0f
    3718:	f8 89       	ldd	r31, Y+16	; 0x10
    371a:	8b 81       	ldd	r24, Y+3	; 0x03
    371c:	9c 81       	ldd	r25, Y+4	; 0x04
    371e:	91 83       	std	Z+1, r25	; 0x01
    3720:	80 83       	st	Z, r24
			mtCOVERAGE_TEST_MARKER();
		}

		/* Ensure interrupts don't access the task lists while they are being
		updated. */
		taskENTER_CRITICAL();
    3722:	0f b6       	in	r0, 0x3f	; 63
    3724:	f8 94       	cli
    3726:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
    3728:	80 91 cc 06 	lds	r24, 0x06CC
    372c:	8f 5f       	subi	r24, 0xFF	; 255
    372e:	80 93 cc 06 	sts	0x06CC, r24
			if( pxCurrentTCB == NULL )
    3732:	80 91 c9 06 	lds	r24, 0x06C9
    3736:	90 91 ca 06 	lds	r25, 0x06CA
    373a:	00 97       	sbiw	r24, 0x00	; 0
    373c:	69 f4       	brne	.+26     	; 0x3758 <xTaskGenericCreate+0xf4>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
    373e:	8b 81       	ldd	r24, Y+3	; 0x03
    3740:	9c 81       	ldd	r25, Y+4	; 0x04
    3742:	90 93 ca 06 	sts	0x06CA, r25
    3746:	80 93 c9 06 	sts	0x06C9, r24

				if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    374a:	80 91 cc 06 	lds	r24, 0x06CC
    374e:	81 30       	cpi	r24, 0x01	; 1
    3750:	a9 f4       	brne	.+42     	; 0x377c <xTaskGenericCreate+0x118>
				{
					/* This is the first task to be created so do the preliminary
					initialisation required.  We will not recover if this call
					fails, but we will report the failure. */
					prvInitialiseTaskLists();
    3752:	0e 94 d3 22 	call	0x45a6	; 0x45a6 <prvInitialiseTaskLists>
    3756:	12 c0       	rjmp	.+36     	; 0x377c <xTaskGenericCreate+0x118>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
    3758:	80 91 d0 06 	lds	r24, 0x06D0
    375c:	88 23       	and	r24, r24
    375e:	71 f4       	brne	.+28     	; 0x377c <xTaskGenericCreate+0x118>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
    3760:	e0 91 c9 06 	lds	r30, 0x06C9
    3764:	f0 91 ca 06 	lds	r31, 0x06CA
    3768:	96 89       	ldd	r25, Z+22	; 0x16
    376a:	8e 85       	ldd	r24, Y+14	; 0x0e
    376c:	89 17       	cp	r24, r25
    376e:	30 f0       	brcs	.+12     	; 0x377c <xTaskGenericCreate+0x118>
					{
						pxCurrentTCB = pxNewTCB;
    3770:	8b 81       	ldd	r24, Y+3	; 0x03
    3772:	9c 81       	ldd	r25, Y+4	; 0x04
    3774:	90 93 ca 06 	sts	0x06CA, r25
    3778:	80 93 c9 06 	sts	0x06C9, r24
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}

			uxTaskNumber++;
    377c:	80 91 d4 06 	lds	r24, 0x06D4
    3780:	8f 5f       	subi	r24, 0xFF	; 255
    3782:	80 93 d4 06 	sts	0x06D4, r24
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif /* configUSE_TRACE_FACILITY */
			traceTASK_CREATE( pxNewTCB );

			prvAddTaskToReadyList( pxNewTCB );
    3786:	eb 81       	ldd	r30, Y+3	; 0x03
    3788:	fc 81       	ldd	r31, Y+4	; 0x04
    378a:	96 89       	ldd	r25, Z+22	; 0x16
    378c:	80 91 cf 06 	lds	r24, 0x06CF
    3790:	89 17       	cp	r24, r25
    3792:	28 f4       	brcc	.+10     	; 0x379e <xTaskGenericCreate+0x13a>
    3794:	eb 81       	ldd	r30, Y+3	; 0x03
    3796:	fc 81       	ldd	r31, Y+4	; 0x04
    3798:	86 89       	ldd	r24, Z+22	; 0x16
    379a:	80 93 cf 06 	sts	0x06CF, r24
    379e:	eb 81       	ldd	r30, Y+3	; 0x03
    37a0:	fc 81       	ldd	r31, Y+4	; 0x04
    37a2:	86 89       	ldd	r24, Z+22	; 0x16
    37a4:	28 2f       	mov	r18, r24
    37a6:	30 e0       	ldi	r19, 0x00	; 0
    37a8:	c9 01       	movw	r24, r18
    37aa:	88 0f       	add	r24, r24
    37ac:	99 1f       	adc	r25, r25
    37ae:	88 0f       	add	r24, r24
    37b0:	99 1f       	adc	r25, r25
    37b2:	88 0f       	add	r24, r24
    37b4:	99 1f       	adc	r25, r25
    37b6:	82 0f       	add	r24, r18
    37b8:	93 1f       	adc	r25, r19
    37ba:	ac 01       	movw	r20, r24
    37bc:	4a 52       	subi	r20, 0x2A	; 42
    37be:	59 4f       	sbci	r21, 0xF9	; 249
    37c0:	8b 81       	ldd	r24, Y+3	; 0x03
    37c2:	9c 81       	ldd	r25, Y+4	; 0x04
    37c4:	9c 01       	movw	r18, r24
    37c6:	2e 5f       	subi	r18, 0xFE	; 254
    37c8:	3f 4f       	sbci	r19, 0xFF	; 255
    37ca:	ca 01       	movw	r24, r20
    37cc:	b9 01       	movw	r22, r18
    37ce:	0e 94 b6 0f 	call	0x1f6c	; 0x1f6c <vListInsertEnd>

			xReturn = pdPASS;
    37d2:	81 e0       	ldi	r24, 0x01	; 1
    37d4:	8d 83       	std	Y+5, r24	; 0x05
			portSETUP_TCB( pxNewTCB );
		}
		taskEXIT_CRITICAL();
    37d6:	0f 90       	pop	r0
    37d8:	0f be       	out	0x3f, r0	; 63
    37da:	02 c0       	rjmp	.+4      	; 0x37e0 <xTaskGenericCreate+0x17c>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    37dc:	8f ef       	ldi	r24, 0xFF	; 255
    37de:	8d 83       	std	Y+5, r24	; 0x05
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
    37e0:	8d 81       	ldd	r24, Y+5	; 0x05
    37e2:	81 30       	cpi	r24, 0x01	; 1
    37e4:	71 f4       	brne	.+28     	; 0x3802 <xTaskGenericCreate+0x19e>
	{
		if( xSchedulerRunning != pdFALSE )
    37e6:	80 91 d0 06 	lds	r24, 0x06D0
    37ea:	88 23       	and	r24, r24
    37ec:	51 f0       	breq	.+20     	; 0x3802 <xTaskGenericCreate+0x19e>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
    37ee:	e0 91 c9 06 	lds	r30, 0x06C9
    37f2:	f0 91 ca 06 	lds	r31, 0x06CA
    37f6:	96 89       	ldd	r25, Z+22	; 0x16
    37f8:	8e 85       	ldd	r24, Y+14	; 0x0e
    37fa:	98 17       	cp	r25, r24
    37fc:	10 f4       	brcc	.+4      	; 0x3802 <xTaskGenericCreate+0x19e>
			{
				taskYIELD_IF_USING_PREEMPTION();
    37fe:	0e 94 71 12 	call	0x24e2	; 0x24e2 <vPortYield>
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	return xReturn;
    3802:	8d 81       	ldd	r24, Y+5	; 0x05
}
    3804:	64 96       	adiw	r28, 0x14	; 20
    3806:	0f b6       	in	r0, 0x3f	; 63
    3808:	f8 94       	cli
    380a:	de bf       	out	0x3e, r29	; 62
    380c:	0f be       	out	0x3f, r0	; 63
    380e:	cd bf       	out	0x3d, r28	; 61
    3810:	cf 91       	pop	r28
    3812:	df 91       	pop	r29
    3814:	1f 91       	pop	r17
    3816:	0f 91       	pop	r16
    3818:	ff 90       	pop	r15
    381a:	ef 90       	pop	r14
    381c:	df 90       	pop	r13
    381e:	cf 90       	pop	r12
    3820:	bf 90       	pop	r11
    3822:	af 90       	pop	r10
    3824:	08 95       	ret

00003826 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( TaskHandle_t xTaskToDelete )
	{
    3826:	df 93       	push	r29
    3828:	cf 93       	push	r28
    382a:	00 d0       	rcall	.+0      	; 0x382c <vTaskDelete+0x6>
    382c:	00 d0       	rcall	.+0      	; 0x382e <vTaskDelete+0x8>
    382e:	00 d0       	rcall	.+0      	; 0x3830 <vTaskDelete+0xa>
    3830:	cd b7       	in	r28, 0x3d	; 61
    3832:	de b7       	in	r29, 0x3e	; 62
    3834:	9c 83       	std	Y+4, r25	; 0x04
    3836:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
    3838:	0f b6       	in	r0, 0x3f	; 63
    383a:	f8 94       	cli
    383c:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the calling task that is
			being deleted. */
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
    383e:	8b 81       	ldd	r24, Y+3	; 0x03
    3840:	9c 81       	ldd	r25, Y+4	; 0x04
    3842:	00 97       	sbiw	r24, 0x00	; 0
    3844:	39 f4       	brne	.+14     	; 0x3854 <vTaskDelete+0x2e>
    3846:	80 91 c9 06 	lds	r24, 0x06C9
    384a:	90 91 ca 06 	lds	r25, 0x06CA
    384e:	9e 83       	std	Y+6, r25	; 0x06
    3850:	8d 83       	std	Y+5, r24	; 0x05
    3852:	04 c0       	rjmp	.+8      	; 0x385c <vTaskDelete+0x36>
    3854:	8b 81       	ldd	r24, Y+3	; 0x03
    3856:	9c 81       	ldd	r25, Y+4	; 0x04
    3858:	9e 83       	std	Y+6, r25	; 0x06
    385a:	8d 83       	std	Y+5, r24	; 0x05
    385c:	8d 81       	ldd	r24, Y+5	; 0x05
    385e:	9e 81       	ldd	r25, Y+6	; 0x06
    3860:	9a 83       	std	Y+2, r25	; 0x02
    3862:	89 83       	std	Y+1, r24	; 0x01

			/* Remove task from the ready list and place in the	termination list.
			This will stop the task from be scheduled.  The idle task will check
			the termination list and free up any memory allocated by the
			scheduler for the TCB and stack. */
			if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    3864:	89 81       	ldd	r24, Y+1	; 0x01
    3866:	9a 81       	ldd	r25, Y+2	; 0x02
    3868:	02 96       	adiw	r24, 0x02	; 2
    386a:	0e 94 66 10 	call	0x20cc	; 0x20cc <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    386e:	e9 81       	ldd	r30, Y+1	; 0x01
    3870:	fa 81       	ldd	r31, Y+2	; 0x02
    3872:	84 89       	ldd	r24, Z+20	; 0x14
    3874:	95 89       	ldd	r25, Z+21	; 0x15
    3876:	00 97       	sbiw	r24, 0x00	; 0
    3878:	29 f0       	breq	.+10     	; 0x3884 <vTaskDelete+0x5e>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    387a:	89 81       	ldd	r24, Y+1	; 0x01
    387c:	9a 81       	ldd	r25, Y+2	; 0x02
    387e:	0c 96       	adiw	r24, 0x0c	; 12
    3880:	0e 94 66 10 	call	0x20cc	; 0x20cc <uxListRemove>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
    3884:	89 81       	ldd	r24, Y+1	; 0x01
    3886:	9a 81       	ldd	r25, Y+2	; 0x02
    3888:	9c 01       	movw	r18, r24
    388a:	2e 5f       	subi	r18, 0xFE	; 254
    388c:	3f 4f       	sbci	r19, 0xFF	; 255
    388e:	84 e3       	ldi	r24, 0x34	; 52
    3890:	97 e0       	ldi	r25, 0x07	; 7
    3892:	b9 01       	movw	r22, r18
    3894:	0e 94 b6 0f 	call	0x1f6c	; 0x1f6c <vListInsertEnd>

			/* Increment the ucTasksDeleted variable so the idle task knows
			there is a task that has been deleted and that it should therefore
			check the xTasksWaitingTermination list. */
			++uxTasksDeleted;
    3898:	80 91 cb 06 	lds	r24, 0x06CB
    389c:	8f 5f       	subi	r24, 0xFF	; 255
    389e:	80 93 cb 06 	sts	0x06CB, r24

			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
			can detect that the task lists need re-generating. */
			uxTaskNumber++;
    38a2:	80 91 d4 06 	lds	r24, 0x06D4
    38a6:	8f 5f       	subi	r24, 0xFF	; 255
    38a8:	80 93 d4 06 	sts	0x06D4, r24

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
    38ac:	0f 90       	pop	r0
    38ae:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if it is the currently running task that has just
		been deleted. */
		if( xSchedulerRunning != pdFALSE )
    38b0:	80 91 d0 06 	lds	r24, 0x06D0
    38b4:	88 23       	and	r24, r24
    38b6:	99 f0       	breq	.+38     	; 0x38de <vTaskDelete+0xb8>
		{
			if( pxTCB == pxCurrentTCB )
    38b8:	20 91 c9 06 	lds	r18, 0x06C9
    38bc:	30 91 ca 06 	lds	r19, 0x06CA
    38c0:	89 81       	ldd	r24, Y+1	; 0x01
    38c2:	9a 81       	ldd	r25, Y+2	; 0x02
    38c4:	82 17       	cp	r24, r18
    38c6:	93 07       	cpc	r25, r19
    38c8:	19 f4       	brne	.+6      	; 0x38d0 <vTaskDelete+0xaa>
				in which Windows specific clean up operations are performed,
				after which it is not possible to yield away from this task -
				hence xYieldPending is used to latch that a context switch is
				required. */
				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
				portYIELD_WITHIN_API();
    38ca:	0e 94 71 12 	call	0x24e2	; 0x24e2 <vPortYield>
    38ce:	07 c0       	rjmp	.+14     	; 0x38de <vTaskDelete+0xb8>
			}
			else
			{
				/* Reset the next expected unblock time in case it referred to
				the task that has just been deleted. */
				taskENTER_CRITICAL();
    38d0:	0f b6       	in	r0, 0x3f	; 63
    38d2:	f8 94       	cli
    38d4:	0f 92       	push	r0
				{
					prvResetNextTaskUnblockTime();
    38d6:	0e 94 f2 23 	call	0x47e4	; 0x47e4 <prvResetNextTaskUnblockTime>
				}
				taskEXIT_CRITICAL();
    38da:	0f 90       	pop	r0
    38dc:	0f be       	out	0x3f, r0	; 63
			}
		}
	}
    38de:	26 96       	adiw	r28, 0x06	; 6
    38e0:	0f b6       	in	r0, 0x3f	; 63
    38e2:	f8 94       	cli
    38e4:	de bf       	out	0x3e, r29	; 62
    38e6:	0f be       	out	0x3f, r0	; 63
    38e8:	cd bf       	out	0x3d, r28	; 61
    38ea:	cf 91       	pop	r28
    38ec:	df 91       	pop	r29
    38ee:	08 95       	ret

000038f0 <vTaskDelayUntil>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
    38f0:	df 93       	push	r29
    38f2:	cf 93       	push	r28
    38f4:	cd b7       	in	r28, 0x3d	; 61
    38f6:	de b7       	in	r29, 0x3e	; 62
    38f8:	2a 97       	sbiw	r28, 0x0a	; 10
    38fa:	0f b6       	in	r0, 0x3f	; 63
    38fc:	f8 94       	cli
    38fe:	de bf       	out	0x3e, r29	; 62
    3900:	0f be       	out	0x3f, r0	; 63
    3902:	cd bf       	out	0x3d, r28	; 61
    3904:	98 87       	std	Y+8, r25	; 0x08
    3906:	8f 83       	std	Y+7, r24	; 0x07
    3908:	7a 87       	std	Y+10, r23	; 0x0a
    390a:	69 87       	std	Y+9, r22	; 0x09
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
    390c:	1b 82       	std	Y+3, r1	; 0x03

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );
		configASSERT( uxSchedulerSuspended == 0 );

		vTaskSuspendAll();
    390e:	0e 94 60 1e 	call	0x3cc0	; 0x3cc0 <vTaskSuspendAll>
		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
    3912:	80 91 cd 06 	lds	r24, 0x06CD
    3916:	90 91 ce 06 	lds	r25, 0x06CE
    391a:	9a 83       	std	Y+2, r25	; 0x02
    391c:	89 83       	std	Y+1, r24	; 0x01

			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    391e:	ef 81       	ldd	r30, Y+7	; 0x07
    3920:	f8 85       	ldd	r31, Y+8	; 0x08
    3922:	20 81       	ld	r18, Z
    3924:	31 81       	ldd	r19, Z+1	; 0x01
    3926:	89 85       	ldd	r24, Y+9	; 0x09
    3928:	9a 85       	ldd	r25, Y+10	; 0x0a
    392a:	82 0f       	add	r24, r18
    392c:	93 1f       	adc	r25, r19
    392e:	9e 83       	std	Y+6, r25	; 0x06
    3930:	8d 83       	std	Y+5, r24	; 0x05

			if( xConstTickCount < *pxPreviousWakeTime )
    3932:	ef 81       	ldd	r30, Y+7	; 0x07
    3934:	f8 85       	ldd	r31, Y+8	; 0x08
    3936:	20 81       	ld	r18, Z
    3938:	31 81       	ldd	r19, Z+1	; 0x01
    393a:	89 81       	ldd	r24, Y+1	; 0x01
    393c:	9a 81       	ldd	r25, Y+2	; 0x02
    393e:	82 17       	cp	r24, r18
    3940:	93 07       	cpc	r25, r19
    3942:	98 f4       	brcc	.+38     	; 0x396a <vTaskDelayUntil+0x7a>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
    3944:	ef 81       	ldd	r30, Y+7	; 0x07
    3946:	f8 85       	ldd	r31, Y+8	; 0x08
    3948:	20 81       	ld	r18, Z
    394a:	31 81       	ldd	r19, Z+1	; 0x01
    394c:	8d 81       	ldd	r24, Y+5	; 0x05
    394e:	9e 81       	ldd	r25, Y+6	; 0x06
    3950:	82 17       	cp	r24, r18
    3952:	93 07       	cpc	r25, r19
    3954:	e0 f4       	brcc	.+56     	; 0x398e <vTaskDelayUntil+0x9e>
    3956:	2d 81       	ldd	r18, Y+5	; 0x05
    3958:	3e 81       	ldd	r19, Y+6	; 0x06
    395a:	89 81       	ldd	r24, Y+1	; 0x01
    395c:	9a 81       	ldd	r25, Y+2	; 0x02
    395e:	82 17       	cp	r24, r18
    3960:	93 07       	cpc	r25, r19
    3962:	a8 f4       	brcc	.+42     	; 0x398e <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    3964:	81 e0       	ldi	r24, 0x01	; 1
    3966:	8b 83       	std	Y+3, r24	; 0x03
    3968:	12 c0       	rjmp	.+36     	; 0x398e <vTaskDelayUntil+0x9e>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
    396a:	ef 81       	ldd	r30, Y+7	; 0x07
    396c:	f8 85       	ldd	r31, Y+8	; 0x08
    396e:	20 81       	ld	r18, Z
    3970:	31 81       	ldd	r19, Z+1	; 0x01
    3972:	8d 81       	ldd	r24, Y+5	; 0x05
    3974:	9e 81       	ldd	r25, Y+6	; 0x06
    3976:	82 17       	cp	r24, r18
    3978:	93 07       	cpc	r25, r19
    397a:	38 f0       	brcs	.+14     	; 0x398a <vTaskDelayUntil+0x9a>
    397c:	2d 81       	ldd	r18, Y+5	; 0x05
    397e:	3e 81       	ldd	r19, Y+6	; 0x06
    3980:	89 81       	ldd	r24, Y+1	; 0x01
    3982:	9a 81       	ldd	r25, Y+2	; 0x02
    3984:	82 17       	cp	r24, r18
    3986:	93 07       	cpc	r25, r19
    3988:	10 f4       	brcc	.+4      	; 0x398e <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    398a:	81 e0       	ldi	r24, 0x01	; 1
    398c:	8b 83       	std	Y+3, r24	; 0x03
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    398e:	ef 81       	ldd	r30, Y+7	; 0x07
    3990:	f8 85       	ldd	r31, Y+8	; 0x08
    3992:	8d 81       	ldd	r24, Y+5	; 0x05
    3994:	9e 81       	ldd	r25, Y+6	; 0x06
    3996:	91 83       	std	Z+1, r25	; 0x01
    3998:	80 83       	st	Z, r24

			if( xShouldDelay != pdFALSE )
    399a:	8b 81       	ldd	r24, Y+3	; 0x03
    399c:	88 23       	and	r24, r24
    399e:	59 f0       	breq	.+22     	; 0x39b6 <vTaskDelayUntil+0xc6>
			{
				traceTASK_DELAY_UNTIL();

				/* Remove the task from the ready list before adding it to the
				blocked list as the same list item is used for both lists. */
				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    39a0:	80 91 c9 06 	lds	r24, 0x06C9
    39a4:	90 91 ca 06 	lds	r25, 0x06CA
    39a8:	02 96       	adiw	r24, 0x02	; 2
    39aa:	0e 94 66 10 	call	0x20cc	; 0x20cc <uxListRemove>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				prvAddCurrentTaskToDelayedList( xTimeToWake );
    39ae:	8d 81       	ldd	r24, Y+5	; 0x05
    39b0:	9e 81       	ldd	r25, Y+6	; 0x06
    39b2:	0e 94 4f 23 	call	0x469e	; 0x469e <prvAddCurrentTaskToDelayedList>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    39b6:	0e 94 6c 1e 	call	0x3cd8	; 0x3cd8 <xTaskResumeAll>
    39ba:	8c 83       	std	Y+4, r24	; 0x04

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    39bc:	8c 81       	ldd	r24, Y+4	; 0x04
    39be:	88 23       	and	r24, r24
    39c0:	11 f4       	brne	.+4      	; 0x39c6 <vTaskDelayUntil+0xd6>
		{
			portYIELD_WITHIN_API();
    39c2:	0e 94 71 12 	call	0x24e2	; 0x24e2 <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    39c6:	2a 96       	adiw	r28, 0x0a	; 10
    39c8:	0f b6       	in	r0, 0x3f	; 63
    39ca:	f8 94       	cli
    39cc:	de bf       	out	0x3e, r29	; 62
    39ce:	0f be       	out	0x3f, r0	; 63
    39d0:	cd bf       	out	0x3d, r28	; 61
    39d2:	cf 91       	pop	r28
    39d4:	df 91       	pop	r29
    39d6:	08 95       	ret

000039d8 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
    39d8:	df 93       	push	r29
    39da:	cf 93       	push	r28
    39dc:	00 d0       	rcall	.+0      	; 0x39de <vTaskDelay+0x6>
    39de:	00 d0       	rcall	.+0      	; 0x39e0 <vTaskDelay+0x8>
    39e0:	0f 92       	push	r0
    39e2:	cd b7       	in	r28, 0x3d	; 61
    39e4:	de b7       	in	r29, 0x3e	; 62
    39e6:	9d 83       	std	Y+5, r25	; 0x05
    39e8:	8c 83       	std	Y+4, r24	; 0x04
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded = pdFALSE;
    39ea:	19 82       	std	Y+1, r1	; 0x01


		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
    39ec:	8c 81       	ldd	r24, Y+4	; 0x04
    39ee:	9d 81       	ldd	r25, Y+5	; 0x05
    39f0:	00 97       	sbiw	r24, 0x00	; 0
    39f2:	d1 f0       	breq	.+52     	; 0x3a28 <vTaskDelay+0x50>
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
    39f4:	0e 94 60 1e 	call	0x3cc0	; 0x3cc0 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    39f8:	20 91 cd 06 	lds	r18, 0x06CD
    39fc:	30 91 ce 06 	lds	r19, 0x06CE
    3a00:	8c 81       	ldd	r24, Y+4	; 0x04
    3a02:	9d 81       	ldd	r25, Y+5	; 0x05
    3a04:	82 0f       	add	r24, r18
    3a06:	93 1f       	adc	r25, r19
    3a08:	9b 83       	std	Y+3, r25	; 0x03
    3a0a:	8a 83       	std	Y+2, r24	; 0x02

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    3a0c:	80 91 c9 06 	lds	r24, 0x06C9
    3a10:	90 91 ca 06 	lds	r25, 0x06CA
    3a14:	02 96       	adiw	r24, 0x02	; 2
    3a16:	0e 94 66 10 	call	0x20cc	; 0x20cc <uxListRemove>
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    3a1a:	8a 81       	ldd	r24, Y+2	; 0x02
    3a1c:	9b 81       	ldd	r25, Y+3	; 0x03
    3a1e:	0e 94 4f 23 	call	0x469e	; 0x469e <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    3a22:	0e 94 6c 1e 	call	0x3cd8	; 0x3cd8 <xTaskResumeAll>
    3a26:	89 83       	std	Y+1, r24	; 0x01
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    3a28:	89 81       	ldd	r24, Y+1	; 0x01
    3a2a:	88 23       	and	r24, r24
    3a2c:	11 f4       	brne	.+4      	; 0x3a32 <vTaskDelay+0x5a>
		{
			portYIELD_WITHIN_API();
    3a2e:	0e 94 71 12 	call	0x24e2	; 0x24e2 <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    3a32:	0f 90       	pop	r0
    3a34:	0f 90       	pop	r0
    3a36:	0f 90       	pop	r0
    3a38:	0f 90       	pop	r0
    3a3a:	0f 90       	pop	r0
    3a3c:	cf 91       	pop	r28
    3a3e:	df 91       	pop	r29
    3a40:	08 95       	ret

00003a42 <uxTaskPriorityGet>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_uxTaskPriorityGet == 1 )

	UBaseType_t uxTaskPriorityGet( TaskHandle_t xTask )
	{
    3a42:	df 93       	push	r29
    3a44:	cf 93       	push	r28
    3a46:	cd b7       	in	r28, 0x3d	; 61
    3a48:	de b7       	in	r29, 0x3e	; 62
    3a4a:	27 97       	sbiw	r28, 0x07	; 7
    3a4c:	0f b6       	in	r0, 0x3f	; 63
    3a4e:	f8 94       	cli
    3a50:	de bf       	out	0x3e, r29	; 62
    3a52:	0f be       	out	0x3f, r0	; 63
    3a54:	cd bf       	out	0x3d, r28	; 61
    3a56:	9d 83       	std	Y+5, r25	; 0x05
    3a58:	8c 83       	std	Y+4, r24	; 0x04
	TCB_t *pxTCB;
	UBaseType_t uxReturn;

		taskENTER_CRITICAL();
    3a5a:	0f b6       	in	r0, 0x3f	; 63
    3a5c:	f8 94       	cli
    3a5e:	0f 92       	push	r0
		{
			/* If null is passed in here then we are changing the
			priority of the calling function. */
			pxTCB = prvGetTCBFromHandle( xTask );
    3a60:	8c 81       	ldd	r24, Y+4	; 0x04
    3a62:	9d 81       	ldd	r25, Y+5	; 0x05
    3a64:	00 97       	sbiw	r24, 0x00	; 0
    3a66:	39 f4       	brne	.+14     	; 0x3a76 <uxTaskPriorityGet+0x34>
    3a68:	80 91 c9 06 	lds	r24, 0x06C9
    3a6c:	90 91 ca 06 	lds	r25, 0x06CA
    3a70:	9f 83       	std	Y+7, r25	; 0x07
    3a72:	8e 83       	std	Y+6, r24	; 0x06
    3a74:	04 c0       	rjmp	.+8      	; 0x3a7e <uxTaskPriorityGet+0x3c>
    3a76:	8c 81       	ldd	r24, Y+4	; 0x04
    3a78:	9d 81       	ldd	r25, Y+5	; 0x05
    3a7a:	9f 83       	std	Y+7, r25	; 0x07
    3a7c:	8e 83       	std	Y+6, r24	; 0x06
    3a7e:	8e 81       	ldd	r24, Y+6	; 0x06
    3a80:	9f 81       	ldd	r25, Y+7	; 0x07
    3a82:	9b 83       	std	Y+3, r25	; 0x03
    3a84:	8a 83       	std	Y+2, r24	; 0x02
			uxReturn = pxTCB->uxPriority;
    3a86:	ea 81       	ldd	r30, Y+2	; 0x02
    3a88:	fb 81       	ldd	r31, Y+3	; 0x03
    3a8a:	86 89       	ldd	r24, Z+22	; 0x16
    3a8c:	89 83       	std	Y+1, r24	; 0x01
		}
		taskEXIT_CRITICAL();
    3a8e:	0f 90       	pop	r0
    3a90:	0f be       	out	0x3f, r0	; 63

		return uxReturn;
    3a92:	89 81       	ldd	r24, Y+1	; 0x01
	}
    3a94:	27 96       	adiw	r28, 0x07	; 7
    3a96:	0f b6       	in	r0, 0x3f	; 63
    3a98:	f8 94       	cli
    3a9a:	de bf       	out	0x3e, r29	; 62
    3a9c:	0f be       	out	0x3f, r0	; 63
    3a9e:	cd bf       	out	0x3d, r28	; 61
    3aa0:	cf 91       	pop	r28
    3aa2:	df 91       	pop	r29
    3aa4:	08 95       	ret

00003aa6 <vTaskPrioritySet>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskPrioritySet == 1 )

	void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority )
	{
    3aa6:	df 93       	push	r29
    3aa8:	cf 93       	push	r28
    3aaa:	cd b7       	in	r28, 0x3d	; 61
    3aac:	de b7       	in	r29, 0x3e	; 62
    3aae:	2a 97       	sbiw	r28, 0x0a	; 10
    3ab0:	0f b6       	in	r0, 0x3f	; 63
    3ab2:	f8 94       	cli
    3ab4:	de bf       	out	0x3e, r29	; 62
    3ab6:	0f be       	out	0x3f, r0	; 63
    3ab8:	cd bf       	out	0x3d, r28	; 61
    3aba:	9f 83       	std	Y+7, r25	; 0x07
    3abc:	8e 83       	std	Y+6, r24	; 0x06
    3abe:	68 87       	std	Y+8, r22	; 0x08
	TCB_t *pxTCB;
	UBaseType_t uxCurrentBasePriority, uxPriorityUsedOnEntry;
	BaseType_t xYieldRequired = pdFALSE;
    3ac0:	19 82       	std	Y+1, r1	; 0x01

		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );

		/* Ensure the new priority is valid. */
		if( uxNewPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
    3ac2:	88 85       	ldd	r24, Y+8	; 0x08
    3ac4:	87 30       	cpi	r24, 0x07	; 7
    3ac6:	10 f0       	brcs	.+4      	; 0x3acc <vTaskPrioritySet+0x26>
		{
			uxNewPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
    3ac8:	86 e0       	ldi	r24, 0x06	; 6
    3aca:	88 87       	std	Y+8, r24	; 0x08
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		taskENTER_CRITICAL();
    3acc:	0f b6       	in	r0, 0x3f	; 63
    3ace:	f8 94       	cli
    3ad0:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the priority of the calling
			task that is being changed. */
			pxTCB = prvGetTCBFromHandle( xTask );
    3ad2:	8e 81       	ldd	r24, Y+6	; 0x06
    3ad4:	9f 81       	ldd	r25, Y+7	; 0x07
    3ad6:	00 97       	sbiw	r24, 0x00	; 0
    3ad8:	39 f4       	brne	.+14     	; 0x3ae8 <vTaskPrioritySet+0x42>
    3ada:	80 91 c9 06 	lds	r24, 0x06C9
    3ade:	90 91 ca 06 	lds	r25, 0x06CA
    3ae2:	9a 87       	std	Y+10, r25	; 0x0a
    3ae4:	89 87       	std	Y+9, r24	; 0x09
    3ae6:	04 c0       	rjmp	.+8      	; 0x3af0 <vTaskPrioritySet+0x4a>
    3ae8:	8e 81       	ldd	r24, Y+6	; 0x06
    3aea:	9f 81       	ldd	r25, Y+7	; 0x07
    3aec:	9a 87       	std	Y+10, r25	; 0x0a
    3aee:	89 87       	std	Y+9, r24	; 0x09
    3af0:	89 85       	ldd	r24, Y+9	; 0x09
    3af2:	9a 85       	ldd	r25, Y+10	; 0x0a
    3af4:	9d 83       	std	Y+5, r25	; 0x05
    3af6:	8c 83       	std	Y+4, r24	; 0x04

			traceTASK_PRIORITY_SET( pxTCB, uxNewPriority );

			#if ( configUSE_MUTEXES == 1 )
			{
				uxCurrentBasePriority = pxTCB->uxBasePriority;
    3af8:	ec 81       	ldd	r30, Y+4	; 0x04
    3afa:	fd 81       	ldd	r31, Y+5	; 0x05
    3afc:	85 a5       	ldd	r24, Z+45	; 0x2d
    3afe:	8b 83       	std	Y+3, r24	; 0x03
			{
				uxCurrentBasePriority = pxTCB->uxPriority;
			}
			#endif

			if( uxCurrentBasePriority != uxNewPriority )
    3b00:	9b 81       	ldd	r25, Y+3	; 0x03
    3b02:	88 85       	ldd	r24, Y+8	; 0x08
    3b04:	98 17       	cp	r25, r24
    3b06:	09 f4       	brne	.+2      	; 0x3b0a <vTaskPrioritySet+0x64>
    3b08:	8d c0       	rjmp	.+282    	; 0x3c24 <vTaskPrioritySet+0x17e>
			{
				/* The priority change may have readied a task of higher
				priority than the calling task. */
				if( uxNewPriority > uxCurrentBasePriority )
    3b0a:	98 85       	ldd	r25, Y+8	; 0x08
    3b0c:	8b 81       	ldd	r24, Y+3	; 0x03
    3b0e:	89 17       	cp	r24, r25
    3b10:	a0 f4       	brcc	.+40     	; 0x3b3a <vTaskPrioritySet+0x94>
				{
					if( pxTCB != pxCurrentTCB )
    3b12:	20 91 c9 06 	lds	r18, 0x06C9
    3b16:	30 91 ca 06 	lds	r19, 0x06CA
    3b1a:	8c 81       	ldd	r24, Y+4	; 0x04
    3b1c:	9d 81       	ldd	r25, Y+5	; 0x05
    3b1e:	82 17       	cp	r24, r18
    3b20:	93 07       	cpc	r25, r19
    3b22:	b1 f0       	breq	.+44     	; 0x3b50 <vTaskPrioritySet+0xaa>
					{
						/* The priority of a task other than the currently
						running task is being raised.  Is the priority being
						raised above that of the running task? */
						if( uxNewPriority >= pxCurrentTCB->uxPriority )
    3b24:	e0 91 c9 06 	lds	r30, 0x06C9
    3b28:	f0 91 ca 06 	lds	r31, 0x06CA
    3b2c:	96 89       	ldd	r25, Z+22	; 0x16
    3b2e:	88 85       	ldd	r24, Y+8	; 0x08
    3b30:	89 17       	cp	r24, r25
    3b32:	70 f0       	brcs	.+28     	; 0x3b50 <vTaskPrioritySet+0xaa>
						{
							xYieldRequired = pdTRUE;
    3b34:	81 e0       	ldi	r24, 0x01	; 1
    3b36:	89 83       	std	Y+1, r24	; 0x01
    3b38:	0b c0       	rjmp	.+22     	; 0x3b50 <vTaskPrioritySet+0xaa>
						/* The priority of the running task is being raised,
						but the running task must already be the highest
						priority task able to run so no yield is required. */
					}
				}
				else if( pxTCB == pxCurrentTCB )
    3b3a:	20 91 c9 06 	lds	r18, 0x06C9
    3b3e:	30 91 ca 06 	lds	r19, 0x06CA
    3b42:	8c 81       	ldd	r24, Y+4	; 0x04
    3b44:	9d 81       	ldd	r25, Y+5	; 0x05
    3b46:	82 17       	cp	r24, r18
    3b48:	93 07       	cpc	r25, r19
    3b4a:	11 f4       	brne	.+4      	; 0x3b50 <vTaskPrioritySet+0xaa>
				{
					/* Setting the priority of the running task down means
					there may now be another task of higher priority that
					is ready to execute. */
					xYieldRequired = pdTRUE;
    3b4c:	81 e0       	ldi	r24, 0x01	; 1
    3b4e:	89 83       	std	Y+1, r24	; 0x01
				}

				/* Remember the ready list the task might be referenced from
				before its uxPriority member is changed so the
				taskRESET_READY_PRIORITY() macro can function correctly. */
				uxPriorityUsedOnEntry = pxTCB->uxPriority;
    3b50:	ec 81       	ldd	r30, Y+4	; 0x04
    3b52:	fd 81       	ldd	r31, Y+5	; 0x05
    3b54:	86 89       	ldd	r24, Z+22	; 0x16
    3b56:	8a 83       	std	Y+2, r24	; 0x02

				#if ( configUSE_MUTEXES == 1 )
				{
					/* Only change the priority being used if the task is not
					currently using an inherited priority. */
					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
    3b58:	ec 81       	ldd	r30, Y+4	; 0x04
    3b5a:	fd 81       	ldd	r31, Y+5	; 0x05
    3b5c:	95 a5       	ldd	r25, Z+45	; 0x2d
    3b5e:	ec 81       	ldd	r30, Y+4	; 0x04
    3b60:	fd 81       	ldd	r31, Y+5	; 0x05
    3b62:	86 89       	ldd	r24, Z+22	; 0x16
    3b64:	98 17       	cp	r25, r24
    3b66:	21 f4       	brne	.+8      	; 0x3b70 <vTaskPrioritySet+0xca>
					{
						pxTCB->uxPriority = uxNewPriority;
    3b68:	ec 81       	ldd	r30, Y+4	; 0x04
    3b6a:	fd 81       	ldd	r31, Y+5	; 0x05
    3b6c:	88 85       	ldd	r24, Y+8	; 0x08
    3b6e:	86 8b       	std	Z+22, r24	; 0x16
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* The base priority gets set whatever. */
					pxTCB->uxBasePriority = uxNewPriority;
    3b70:	ec 81       	ldd	r30, Y+4	; 0x04
    3b72:	fd 81       	ldd	r31, Y+5	; 0x05
    3b74:	88 85       	ldd	r24, Y+8	; 0x08
    3b76:	85 a7       	std	Z+45, r24	; 0x2d
				}
				#endif

				/* Only reset the event list item value if the value is not
				being used for anything else. */
				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
    3b78:	ec 81       	ldd	r30, Y+4	; 0x04
    3b7a:	fd 81       	ldd	r31, Y+5	; 0x05
    3b7c:	84 85       	ldd	r24, Z+12	; 0x0c
    3b7e:	95 85       	ldd	r25, Z+13	; 0x0d
    3b80:	99 23       	and	r25, r25
    3b82:	5c f0       	brlt	.+22     	; 0x3b9a <vTaskPrioritySet+0xf4>
				{
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxNewPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    3b84:	88 85       	ldd	r24, Y+8	; 0x08
    3b86:	28 2f       	mov	r18, r24
    3b88:	30 e0       	ldi	r19, 0x00	; 0
    3b8a:	87 e0       	ldi	r24, 0x07	; 7
    3b8c:	90 e0       	ldi	r25, 0x00	; 0
    3b8e:	82 1b       	sub	r24, r18
    3b90:	93 0b       	sbc	r25, r19
    3b92:	ec 81       	ldd	r30, Y+4	; 0x04
    3b94:	fd 81       	ldd	r31, Y+5	; 0x05
    3b96:	95 87       	std	Z+13, r25	; 0x0d
    3b98:	84 87       	std	Z+12, r24	; 0x0c

				/* If the task is in the blocked or suspended list we need do
				nothing more than change it's priority variable. However, if
				the task is in a ready list it needs to be removed and placed
				in the list appropriate to its new priority. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
    3b9a:	ec 81       	ldd	r30, Y+4	; 0x04
    3b9c:	fd 81       	ldd	r31, Y+5	; 0x05
    3b9e:	42 85       	ldd	r20, Z+10	; 0x0a
    3ba0:	53 85       	ldd	r21, Z+11	; 0x0b
    3ba2:	8a 81       	ldd	r24, Y+2	; 0x02
    3ba4:	28 2f       	mov	r18, r24
    3ba6:	30 e0       	ldi	r19, 0x00	; 0
    3ba8:	c9 01       	movw	r24, r18
    3baa:	88 0f       	add	r24, r24
    3bac:	99 1f       	adc	r25, r25
    3bae:	88 0f       	add	r24, r24
    3bb0:	99 1f       	adc	r25, r25
    3bb2:	88 0f       	add	r24, r24
    3bb4:	99 1f       	adc	r25, r25
    3bb6:	82 0f       	add	r24, r18
    3bb8:	93 1f       	adc	r25, r19
    3bba:	8a 52       	subi	r24, 0x2A	; 42
    3bbc:	99 4f       	sbci	r25, 0xF9	; 249
    3bbe:	48 17       	cp	r20, r24
    3bc0:	59 07       	cpc	r21, r25
    3bc2:	59 f5       	brne	.+86     	; 0x3c1a <vTaskPrioritySet+0x174>
				{
					/* The task is currently in its ready list - remove before adding
					it to it's new ready list.  As we are in a critical section we
					can do this even if the scheduler is suspended. */
					if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    3bc4:	8c 81       	ldd	r24, Y+4	; 0x04
    3bc6:	9d 81       	ldd	r25, Y+5	; 0x05
    3bc8:	02 96       	adiw	r24, 0x02	; 2
    3bca:	0e 94 66 10 	call	0x20cc	; 0x20cc <uxListRemove>
					}
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}
					prvAddTaskToReadyList( pxTCB );
    3bce:	ec 81       	ldd	r30, Y+4	; 0x04
    3bd0:	fd 81       	ldd	r31, Y+5	; 0x05
    3bd2:	96 89       	ldd	r25, Z+22	; 0x16
    3bd4:	80 91 cf 06 	lds	r24, 0x06CF
    3bd8:	89 17       	cp	r24, r25
    3bda:	28 f4       	brcc	.+10     	; 0x3be6 <vTaskPrioritySet+0x140>
    3bdc:	ec 81       	ldd	r30, Y+4	; 0x04
    3bde:	fd 81       	ldd	r31, Y+5	; 0x05
    3be0:	86 89       	ldd	r24, Z+22	; 0x16
    3be2:	80 93 cf 06 	sts	0x06CF, r24
    3be6:	ec 81       	ldd	r30, Y+4	; 0x04
    3be8:	fd 81       	ldd	r31, Y+5	; 0x05
    3bea:	86 89       	ldd	r24, Z+22	; 0x16
    3bec:	28 2f       	mov	r18, r24
    3bee:	30 e0       	ldi	r19, 0x00	; 0
    3bf0:	c9 01       	movw	r24, r18
    3bf2:	88 0f       	add	r24, r24
    3bf4:	99 1f       	adc	r25, r25
    3bf6:	88 0f       	add	r24, r24
    3bf8:	99 1f       	adc	r25, r25
    3bfa:	88 0f       	add	r24, r24
    3bfc:	99 1f       	adc	r25, r25
    3bfe:	82 0f       	add	r24, r18
    3c00:	93 1f       	adc	r25, r19
    3c02:	ac 01       	movw	r20, r24
    3c04:	4a 52       	subi	r20, 0x2A	; 42
    3c06:	59 4f       	sbci	r21, 0xF9	; 249
    3c08:	8c 81       	ldd	r24, Y+4	; 0x04
    3c0a:	9d 81       	ldd	r25, Y+5	; 0x05
    3c0c:	9c 01       	movw	r18, r24
    3c0e:	2e 5f       	subi	r18, 0xFE	; 254
    3c10:	3f 4f       	sbci	r19, 0xFF	; 255
    3c12:	ca 01       	movw	r24, r20
    3c14:	b9 01       	movw	r22, r18
    3c16:	0e 94 b6 0f 	call	0x1f6c	; 0x1f6c <vListInsertEnd>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				if( xYieldRequired == pdTRUE )
    3c1a:	89 81       	ldd	r24, Y+1	; 0x01
    3c1c:	81 30       	cpi	r24, 0x01	; 1
    3c1e:	11 f4       	brne	.+4      	; 0x3c24 <vTaskPrioritySet+0x17e>
				{
					taskYIELD_IF_USING_PREEMPTION();
    3c20:	0e 94 71 12 	call	0x24e2	; 0x24e2 <vPortYield>
				/* Remove compiler warning about unused variables when the port
				optimised task selection is not being used. */
				( void ) uxPriorityUsedOnEntry;
			}
		}
		taskEXIT_CRITICAL();
    3c24:	0f 90       	pop	r0
    3c26:	0f be       	out	0x3f, r0	; 63
	}
    3c28:	2a 96       	adiw	r28, 0x0a	; 10
    3c2a:	0f b6       	in	r0, 0x3f	; 63
    3c2c:	f8 94       	cli
    3c2e:	de bf       	out	0x3e, r29	; 62
    3c30:	0f be       	out	0x3f, r0	; 63
    3c32:	cd bf       	out	0x3d, r28	; 61
    3c34:	cf 91       	pop	r28
    3c36:	df 91       	pop	r29
    3c38:	08 95       	ret

00003c3a <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
    3c3a:	af 92       	push	r10
    3c3c:	bf 92       	push	r11
    3c3e:	cf 92       	push	r12
    3c40:	df 92       	push	r13
    3c42:	ef 92       	push	r14
    3c44:	ff 92       	push	r15
    3c46:	0f 93       	push	r16
    3c48:	df 93       	push	r29
    3c4a:	cf 93       	push	r28
    3c4c:	0f 92       	push	r0
    3c4e:	cd b7       	in	r28, 0x3d	; 61
    3c50:	de b7       	in	r29, 0x3e	; 62
		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );  /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
    3c52:	89 e4       	ldi	r24, 0x49	; 73
    3c54:	92 e2       	ldi	r25, 0x22	; 34
    3c56:	28 e7       	ldi	r18, 0x78	; 120
    3c58:	30 e0       	ldi	r19, 0x00	; 0
    3c5a:	b9 01       	movw	r22, r18
    3c5c:	45 e5       	ldi	r20, 0x55	; 85
    3c5e:	50 e0       	ldi	r21, 0x00	; 0
    3c60:	20 e0       	ldi	r18, 0x00	; 0
    3c62:	30 e0       	ldi	r19, 0x00	; 0
    3c64:	00 e0       	ldi	r16, 0x00	; 0
    3c66:	ee 24       	eor	r14, r14
    3c68:	ff 24       	eor	r15, r15
    3c6a:	cc 24       	eor	r12, r12
    3c6c:	dd 24       	eor	r13, r13
    3c6e:	aa 24       	eor	r10, r10
    3c70:	bb 24       	eor	r11, r11
    3c72:	0e 94 32 1b 	call	0x3664	; 0x3664 <xTaskGenericCreate>
    3c76:	89 83       	std	Y+1, r24	; 0x01
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
    3c78:	89 81       	ldd	r24, Y+1	; 0x01
    3c7a:	81 30       	cpi	r24, 0x01	; 1
    3c7c:	51 f4       	brne	.+20     	; 0x3c92 <vTaskStartScheduler+0x58>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
    3c7e:	f8 94       	cli
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xSchedulerRunning = pdTRUE;
    3c80:	81 e0       	ldi	r24, 0x01	; 1
    3c82:	80 93 d0 06 	sts	0x06D0, r24
		xTickCount = ( TickType_t ) 0U;
    3c86:	10 92 ce 06 	sts	0x06CE, r1
    3c8a:	10 92 cd 06 	sts	0x06CD, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    3c8e:	0e 94 35 12 	call	0x246a	; 0x246a <xPortStartScheduler>
		/* This line will only be reached if the kernel could not be started,
		because there was not enough FreeRTOS heap to create the idle task
		or the timer task. */
		configASSERT( xReturn );
	}
}
    3c92:	0f 90       	pop	r0
    3c94:	cf 91       	pop	r28
    3c96:	df 91       	pop	r29
    3c98:	0f 91       	pop	r16
    3c9a:	ff 90       	pop	r15
    3c9c:	ef 90       	pop	r14
    3c9e:	df 90       	pop	r13
    3ca0:	cf 90       	pop	r12
    3ca2:	bf 90       	pop	r11
    3ca4:	af 90       	pop	r10
    3ca6:	08 95       	ret

00003ca8 <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
    3ca8:	df 93       	push	r29
    3caa:	cf 93       	push	r28
    3cac:	cd b7       	in	r28, 0x3d	; 61
    3cae:	de b7       	in	r29, 0x3e	; 62
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    3cb0:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    3cb2:	10 92 d0 06 	sts	0x06D0, r1
	vPortEndScheduler();
    3cb6:	0e 94 6a 12 	call	0x24d4	; 0x24d4 <vPortEndScheduler>
}
    3cba:	cf 91       	pop	r28
    3cbc:	df 91       	pop	r29
    3cbe:	08 95       	ret

00003cc0 <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
    3cc0:	df 93       	push	r29
    3cc2:	cf 93       	push	r28
    3cc4:	cd b7       	in	r28, 0x3d	; 61
    3cc6:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
    3cc8:	80 91 d5 06 	lds	r24, 0x06D5
    3ccc:	8f 5f       	subi	r24, 0xFF	; 255
    3cce:	80 93 d5 06 	sts	0x06D5, r24
}
    3cd2:	cf 91       	pop	r28
    3cd4:	df 91       	pop	r29
    3cd6:	08 95       	ret

00003cd8 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
    3cd8:	df 93       	push	r29
    3cda:	cf 93       	push	r28
    3cdc:	00 d0       	rcall	.+0      	; 0x3cde <xTaskResumeAll+0x6>
    3cde:	0f 92       	push	r0
    3ce0:	cd b7       	in	r28, 0x3d	; 61
    3ce2:	de b7       	in	r29, 0x3e	; 62
TCB_t *pxTCB;
BaseType_t xAlreadyYielded = pdFALSE;
    3ce4:	19 82       	std	Y+1, r1	; 0x01
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    3ce6:	0f b6       	in	r0, 0x3f	; 63
    3ce8:	f8 94       	cli
    3cea:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    3cec:	80 91 d5 06 	lds	r24, 0x06D5
    3cf0:	81 50       	subi	r24, 0x01	; 1
    3cf2:	80 93 d5 06 	sts	0x06D5, r24

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    3cf6:	80 91 d5 06 	lds	r24, 0x06D5
    3cfa:	88 23       	and	r24, r24
    3cfc:	09 f0       	breq	.+2      	; 0x3d00 <xTaskResumeAll+0x28>
    3cfe:	6d c0       	rjmp	.+218    	; 0x3dda <xTaskResumeAll+0x102>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    3d00:	80 91 cc 06 	lds	r24, 0x06CC
    3d04:	88 23       	and	r24, r24
    3d06:	09 f4       	brne	.+2      	; 0x3d0a <xTaskResumeAll+0x32>
    3d08:	68 c0       	rjmp	.+208    	; 0x3dda <xTaskResumeAll+0x102>
    3d0a:	45 c0       	rjmp	.+138    	; 0x3d96 <xTaskResumeAll+0xbe>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
    3d0c:	e0 91 30 07 	lds	r30, 0x0730
    3d10:	f0 91 31 07 	lds	r31, 0x0731
    3d14:	86 81       	ldd	r24, Z+6	; 0x06
    3d16:	97 81       	ldd	r25, Z+7	; 0x07
    3d18:	9b 83       	std	Y+3, r25	; 0x03
    3d1a:	8a 83       	std	Y+2, r24	; 0x02
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    3d1c:	8a 81       	ldd	r24, Y+2	; 0x02
    3d1e:	9b 81       	ldd	r25, Y+3	; 0x03
    3d20:	0c 96       	adiw	r24, 0x0c	; 12
    3d22:	0e 94 66 10 	call	0x20cc	; 0x20cc <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
    3d26:	8a 81       	ldd	r24, Y+2	; 0x02
    3d28:	9b 81       	ldd	r25, Y+3	; 0x03
    3d2a:	02 96       	adiw	r24, 0x02	; 2
    3d2c:	0e 94 66 10 	call	0x20cc	; 0x20cc <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    3d30:	ea 81       	ldd	r30, Y+2	; 0x02
    3d32:	fb 81       	ldd	r31, Y+3	; 0x03
    3d34:	96 89       	ldd	r25, Z+22	; 0x16
    3d36:	80 91 cf 06 	lds	r24, 0x06CF
    3d3a:	89 17       	cp	r24, r25
    3d3c:	28 f4       	brcc	.+10     	; 0x3d48 <xTaskResumeAll+0x70>
    3d3e:	ea 81       	ldd	r30, Y+2	; 0x02
    3d40:	fb 81       	ldd	r31, Y+3	; 0x03
    3d42:	86 89       	ldd	r24, Z+22	; 0x16
    3d44:	80 93 cf 06 	sts	0x06CF, r24
    3d48:	ea 81       	ldd	r30, Y+2	; 0x02
    3d4a:	fb 81       	ldd	r31, Y+3	; 0x03
    3d4c:	86 89       	ldd	r24, Z+22	; 0x16
    3d4e:	28 2f       	mov	r18, r24
    3d50:	30 e0       	ldi	r19, 0x00	; 0
    3d52:	c9 01       	movw	r24, r18
    3d54:	88 0f       	add	r24, r24
    3d56:	99 1f       	adc	r25, r25
    3d58:	88 0f       	add	r24, r24
    3d5a:	99 1f       	adc	r25, r25
    3d5c:	88 0f       	add	r24, r24
    3d5e:	99 1f       	adc	r25, r25
    3d60:	82 0f       	add	r24, r18
    3d62:	93 1f       	adc	r25, r19
    3d64:	ac 01       	movw	r20, r24
    3d66:	4a 52       	subi	r20, 0x2A	; 42
    3d68:	59 4f       	sbci	r21, 0xF9	; 249
    3d6a:	8a 81       	ldd	r24, Y+2	; 0x02
    3d6c:	9b 81       	ldd	r25, Y+3	; 0x03
    3d6e:	9c 01       	movw	r18, r24
    3d70:	2e 5f       	subi	r18, 0xFE	; 254
    3d72:	3f 4f       	sbci	r19, 0xFF	; 255
    3d74:	ca 01       	movw	r24, r20
    3d76:	b9 01       	movw	r22, r18
    3d78:	0e 94 b6 0f 	call	0x1f6c	; 0x1f6c <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    3d7c:	ea 81       	ldd	r30, Y+2	; 0x02
    3d7e:	fb 81       	ldd	r31, Y+3	; 0x03
    3d80:	96 89       	ldd	r25, Z+22	; 0x16
    3d82:	e0 91 c9 06 	lds	r30, 0x06C9
    3d86:	f0 91 ca 06 	lds	r31, 0x06CA
    3d8a:	86 89       	ldd	r24, Z+22	; 0x16
    3d8c:	98 17       	cp	r25, r24
    3d8e:	18 f0       	brcs	.+6      	; 0x3d96 <xTaskResumeAll+0xbe>
					{
						xYieldPending = pdTRUE;
    3d90:	81 e0       	ldi	r24, 0x01	; 1
    3d92:	80 93 d2 06 	sts	0x06D2, r24
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    3d96:	80 91 2b 07 	lds	r24, 0x072B
    3d9a:	88 23       	and	r24, r24
    3d9c:	09 f0       	breq	.+2      	; 0x3da0 <xTaskResumeAll+0xc8>
    3d9e:	b6 cf       	rjmp	.-148    	; 0x3d0c <xTaskResumeAll+0x34>

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				if( uxPendedTicks > ( UBaseType_t ) 0U )
    3da0:	80 91 d1 06 	lds	r24, 0x06D1
    3da4:	88 23       	and	r24, r24
    3da6:	89 f0       	breq	.+34     	; 0x3dca <xTaskResumeAll+0xf2>
    3da8:	0c c0       	rjmp	.+24     	; 0x3dc2 <xTaskResumeAll+0xea>
				{
					while( uxPendedTicks > ( UBaseType_t ) 0U )
					{
						if( xTaskIncrementTick() != pdFALSE )
    3daa:	0e 94 2b 1f 	call	0x3e56	; 0x3e56 <xTaskIncrementTick>
    3dae:	88 23       	and	r24, r24
    3db0:	19 f0       	breq	.+6      	; 0x3db8 <xTaskResumeAll+0xe0>
						{
							xYieldPending = pdTRUE;
    3db2:	81 e0       	ldi	r24, 0x01	; 1
    3db4:	80 93 d2 06 	sts	0x06D2, r24
						}
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
						--uxPendedTicks;
    3db8:	80 91 d1 06 	lds	r24, 0x06D1
    3dbc:	81 50       	subi	r24, 0x01	; 1
    3dbe:	80 93 d1 06 	sts	0x06D1, r24
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				if( uxPendedTicks > ( UBaseType_t ) 0U )
				{
					while( uxPendedTicks > ( UBaseType_t ) 0U )
    3dc2:	80 91 d1 06 	lds	r24, 0x06D1
    3dc6:	88 23       	and	r24, r24
    3dc8:	81 f7       	brne	.-32     	; 0x3daa <xTaskResumeAll+0xd2>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				if( xYieldPending == pdTRUE )
    3dca:	80 91 d2 06 	lds	r24, 0x06D2
    3dce:	81 30       	cpi	r24, 0x01	; 1
    3dd0:	21 f4       	brne	.+8      	; 0x3dda <xTaskResumeAll+0x102>
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
    3dd2:	81 e0       	ldi	r24, 0x01	; 1
    3dd4:	89 83       	std	Y+1, r24	; 0x01
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
    3dd6:	0e 94 71 12 	call	0x24e2	; 0x24e2 <vPortYield>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
    3dda:	0f 90       	pop	r0
    3ddc:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
    3dde:	89 81       	ldd	r24, Y+1	; 0x01
}
    3de0:	0f 90       	pop	r0
    3de2:	0f 90       	pop	r0
    3de4:	0f 90       	pop	r0
    3de6:	cf 91       	pop	r28
    3de8:	df 91       	pop	r29
    3dea:	08 95       	ret

00003dec <xTaskGetTickCount>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCount( void )
{
    3dec:	df 93       	push	r29
    3dee:	cf 93       	push	r28
    3df0:	00 d0       	rcall	.+0      	; 0x3df2 <xTaskGetTickCount+0x6>
    3df2:	cd b7       	in	r28, 0x3d	; 61
    3df4:	de b7       	in	r29, 0x3e	; 62
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
    3df6:	0f b6       	in	r0, 0x3f	; 63
    3df8:	f8 94       	cli
    3dfa:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    3dfc:	80 91 cd 06 	lds	r24, 0x06CD
    3e00:	90 91 ce 06 	lds	r25, 0x06CE
    3e04:	9a 83       	std	Y+2, r25	; 0x02
    3e06:	89 83       	std	Y+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    3e08:	0f 90       	pop	r0
    3e0a:	0f be       	out	0x3f, r0	; 63

	return xTicks;
    3e0c:	89 81       	ldd	r24, Y+1	; 0x01
    3e0e:	9a 81       	ldd	r25, Y+2	; 0x02
}
    3e10:	0f 90       	pop	r0
    3e12:	0f 90       	pop	r0
    3e14:	cf 91       	pop	r28
    3e16:	df 91       	pop	r29
    3e18:	08 95       	ret

00003e1a <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCountFromISR( void )
{
    3e1a:	df 93       	push	r29
    3e1c:	cf 93       	push	r28
    3e1e:	00 d0       	rcall	.+0      	; 0x3e20 <xTaskGetTickCountFromISR+0x6>
    3e20:	0f 92       	push	r0
    3e22:	cd b7       	in	r28, 0x3d	; 61
    3e24:	de b7       	in	r29, 0x3e	; 62
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    3e26:	19 82       	std	Y+1, r1	; 0x01
	{
		xReturn = xTickCount;
    3e28:	80 91 cd 06 	lds	r24, 0x06CD
    3e2c:	90 91 ce 06 	lds	r25, 0x06CE
    3e30:	9b 83       	std	Y+3, r25	; 0x03
    3e32:	8a 83       	std	Y+2, r24	; 0x02
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    3e34:	8a 81       	ldd	r24, Y+2	; 0x02
    3e36:	9b 81       	ldd	r25, Y+3	; 0x03
}
    3e38:	0f 90       	pop	r0
    3e3a:	0f 90       	pop	r0
    3e3c:	0f 90       	pop	r0
    3e3e:	cf 91       	pop	r28
    3e40:	df 91       	pop	r29
    3e42:	08 95       	ret

00003e44 <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

UBaseType_t uxTaskGetNumberOfTasks( void )
{
    3e44:	df 93       	push	r29
    3e46:	cf 93       	push	r28
    3e48:	cd b7       	in	r28, 0x3d	; 61
    3e4a:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required because the variables are of type
	BaseType_t. */
	return uxCurrentNumberOfTasks;
    3e4c:	80 91 cc 06 	lds	r24, 0x06CC
}
    3e50:	cf 91       	pop	r28
    3e52:	df 91       	pop	r29
    3e54:	08 95       	ret

00003e56 <xTaskIncrementTick>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
    3e56:	df 93       	push	r29
    3e58:	cf 93       	push	r28
    3e5a:	cd b7       	in	r28, 0x3d	; 61
    3e5c:	de b7       	in	r29, 0x3e	; 62
    3e5e:	29 97       	sbiw	r28, 0x09	; 9
    3e60:	0f b6       	in	r0, 0x3f	; 63
    3e62:	f8 94       	cli
    3e64:	de bf       	out	0x3e, r29	; 62
    3e66:	0f be       	out	0x3f, r0	; 63
    3e68:	cd bf       	out	0x3d, r28	; 61
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
    3e6a:	1d 82       	std	Y+5, r1	; 0x05

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    3e6c:	80 91 d5 06 	lds	r24, 0x06D5
    3e70:	88 23       	and	r24, r24
    3e72:	09 f0       	breq	.+2      	; 0x3e76 <xTaskIncrementTick+0x20>
    3e74:	c2 c0       	rjmp	.+388    	; 0x3ffa <xTaskIncrementTick+0x1a4>
	{
		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		++xTickCount;
    3e76:	80 91 cd 06 	lds	r24, 0x06CD
    3e7a:	90 91 ce 06 	lds	r25, 0x06CE
    3e7e:	01 96       	adiw	r24, 0x01	; 1
    3e80:	90 93 ce 06 	sts	0x06CE, r25
    3e84:	80 93 cd 06 	sts	0x06CD, r24

		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
    3e88:	80 91 cd 06 	lds	r24, 0x06CD
    3e8c:	90 91 ce 06 	lds	r25, 0x06CE
    3e90:	9c 83       	std	Y+4, r25	; 0x04
    3e92:	8b 83       	std	Y+3, r24	; 0x03

			if( xConstTickCount == ( TickType_t ) 0U )
    3e94:	8b 81       	ldd	r24, Y+3	; 0x03
    3e96:	9c 81       	ldd	r25, Y+4	; 0x04
    3e98:	00 97       	sbiw	r24, 0x00	; 0
    3e9a:	d9 f4       	brne	.+54     	; 0x3ed2 <xTaskIncrementTick+0x7c>
			{
				taskSWITCH_DELAYED_LISTS();
    3e9c:	80 91 27 07 	lds	r24, 0x0727
    3ea0:	90 91 28 07 	lds	r25, 0x0728
    3ea4:	9a 83       	std	Y+2, r25	; 0x02
    3ea6:	89 83       	std	Y+1, r24	; 0x01
    3ea8:	80 91 29 07 	lds	r24, 0x0729
    3eac:	90 91 2a 07 	lds	r25, 0x072A
    3eb0:	90 93 28 07 	sts	0x0728, r25
    3eb4:	80 93 27 07 	sts	0x0727, r24
    3eb8:	89 81       	ldd	r24, Y+1	; 0x01
    3eba:	9a 81       	ldd	r25, Y+2	; 0x02
    3ebc:	90 93 2a 07 	sts	0x072A, r25
    3ec0:	80 93 29 07 	sts	0x0729, r24
    3ec4:	80 91 d3 06 	lds	r24, 0x06D3
    3ec8:	8f 5f       	subi	r24, 0xFF	; 255
    3eca:	80 93 d3 06 	sts	0x06D3, r24
    3ece:	0e 94 f2 23 	call	0x47e4	; 0x47e4 <prvResetNextTaskUnblockTime>

			/* See if this tick has made a timeout expire.  Tasks are stored in
			the	queue in the order of their wake time - meaning once one task
			has been found whose block time has not expired there is no need to
			look any further	down the list. */
			if( xConstTickCount >= xNextTaskUnblockTime )
    3ed2:	20 91 eb 01 	lds	r18, 0x01EB
    3ed6:	30 91 ec 01 	lds	r19, 0x01EC
    3eda:	8b 81       	ldd	r24, Y+3	; 0x03
    3edc:	9c 81       	ldd	r25, Y+4	; 0x04
    3ede:	82 17       	cp	r24, r18
    3ee0:	93 07       	cpc	r25, r19
    3ee2:	08 f4       	brcc	.+2      	; 0x3ee6 <xTaskIncrementTick+0x90>
    3ee4:	71 c0       	rjmp	.+226    	; 0x3fc8 <xTaskIncrementTick+0x172>
			{
				for( ;; )
				{
					if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    3ee6:	e0 91 27 07 	lds	r30, 0x0727
    3eea:	f0 91 28 07 	lds	r31, 0x0728
    3eee:	80 81       	ld	r24, Z
    3ef0:	88 23       	and	r24, r24
    3ef2:	39 f4       	brne	.+14     	; 0x3f02 <xTaskIncrementTick+0xac>
						/* The delayed list is empty.  Set xNextTaskUnblockTime
						to the maximum possible value so it is extremely
						unlikely that the
						if( xTickCount >= xNextTaskUnblockTime ) test will pass
						next time through. */
						xNextTaskUnblockTime = portMAX_DELAY;
    3ef4:	8f ef       	ldi	r24, 0xFF	; 255
    3ef6:	9f ef       	ldi	r25, 0xFF	; 255
    3ef8:	90 93 ec 01 	sts	0x01EC, r25
    3efc:	80 93 eb 01 	sts	0x01EB, r24
    3f00:	63 c0       	rjmp	.+198    	; 0x3fc8 <xTaskIncrementTick+0x172>
					{
						/* The delayed list is not empty, get the value of the
						item at the head of the delayed list.  This is the time
						at which the task at the head of the delayed list must
						be removed from the Blocked state. */
						pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    3f02:	e0 91 27 07 	lds	r30, 0x0727
    3f06:	f0 91 28 07 	lds	r31, 0x0728
    3f0a:	05 80       	ldd	r0, Z+5	; 0x05
    3f0c:	f6 81       	ldd	r31, Z+6	; 0x06
    3f0e:	e0 2d       	mov	r30, r0
    3f10:	86 81       	ldd	r24, Z+6	; 0x06
    3f12:	97 81       	ldd	r25, Z+7	; 0x07
    3f14:	99 87       	std	Y+9, r25	; 0x09
    3f16:	88 87       	std	Y+8, r24	; 0x08
						xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    3f18:	e8 85       	ldd	r30, Y+8	; 0x08
    3f1a:	f9 85       	ldd	r31, Y+9	; 0x09
    3f1c:	82 81       	ldd	r24, Z+2	; 0x02
    3f1e:	93 81       	ldd	r25, Z+3	; 0x03
    3f20:	9f 83       	std	Y+7, r25	; 0x07
    3f22:	8e 83       	std	Y+6, r24	; 0x06

						if( xConstTickCount < xItemValue )
    3f24:	2b 81       	ldd	r18, Y+3	; 0x03
    3f26:	3c 81       	ldd	r19, Y+4	; 0x04
    3f28:	8e 81       	ldd	r24, Y+6	; 0x06
    3f2a:	9f 81       	ldd	r25, Y+7	; 0x07
    3f2c:	28 17       	cp	r18, r24
    3f2e:	39 07       	cpc	r19, r25
    3f30:	38 f4       	brcc	.+14     	; 0x3f40 <xTaskIncrementTick+0xea>
							/* It is not time to unblock this item yet, but the
							item value is the time at which the task at the head
							of the blocked list must be removed from the Blocked
							state -	so record the item value in
							xNextTaskUnblockTime. */
							xNextTaskUnblockTime = xItemValue;
    3f32:	8e 81       	ldd	r24, Y+6	; 0x06
    3f34:	9f 81       	ldd	r25, Y+7	; 0x07
    3f36:	90 93 ec 01 	sts	0x01EC, r25
    3f3a:	80 93 eb 01 	sts	0x01EB, r24
    3f3e:	44 c0       	rjmp	.+136    	; 0x3fc8 <xTaskIncrementTick+0x172>
						{
							mtCOVERAGE_TEST_MARKER();
						}

						/* It is time to remove the item from the Blocked state. */
						( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
    3f40:	88 85       	ldd	r24, Y+8	; 0x08
    3f42:	99 85       	ldd	r25, Y+9	; 0x09
    3f44:	02 96       	adiw	r24, 0x02	; 2
    3f46:	0e 94 66 10 	call	0x20cc	; 0x20cc <uxListRemove>

						/* Is the task waiting on an event also?  If so remove
						it from the event list. */
						if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    3f4a:	e8 85       	ldd	r30, Y+8	; 0x08
    3f4c:	f9 85       	ldd	r31, Y+9	; 0x09
    3f4e:	84 89       	ldd	r24, Z+20	; 0x14
    3f50:	95 89       	ldd	r25, Z+21	; 0x15
    3f52:	00 97       	sbiw	r24, 0x00	; 0
    3f54:	29 f0       	breq	.+10     	; 0x3f60 <xTaskIncrementTick+0x10a>
						{
							( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    3f56:	88 85       	ldd	r24, Y+8	; 0x08
    3f58:	99 85       	ldd	r25, Y+9	; 0x09
    3f5a:	0c 96       	adiw	r24, 0x0c	; 12
    3f5c:	0e 94 66 10 	call	0x20cc	; 0x20cc <uxListRemove>
							mtCOVERAGE_TEST_MARKER();
						}

						/* Place the unblocked task into the appropriate ready
						list. */
						prvAddTaskToReadyList( pxTCB );
    3f60:	e8 85       	ldd	r30, Y+8	; 0x08
    3f62:	f9 85       	ldd	r31, Y+9	; 0x09
    3f64:	96 89       	ldd	r25, Z+22	; 0x16
    3f66:	80 91 cf 06 	lds	r24, 0x06CF
    3f6a:	89 17       	cp	r24, r25
    3f6c:	28 f4       	brcc	.+10     	; 0x3f78 <xTaskIncrementTick+0x122>
    3f6e:	e8 85       	ldd	r30, Y+8	; 0x08
    3f70:	f9 85       	ldd	r31, Y+9	; 0x09
    3f72:	86 89       	ldd	r24, Z+22	; 0x16
    3f74:	80 93 cf 06 	sts	0x06CF, r24
    3f78:	e8 85       	ldd	r30, Y+8	; 0x08
    3f7a:	f9 85       	ldd	r31, Y+9	; 0x09
    3f7c:	86 89       	ldd	r24, Z+22	; 0x16
    3f7e:	28 2f       	mov	r18, r24
    3f80:	30 e0       	ldi	r19, 0x00	; 0
    3f82:	c9 01       	movw	r24, r18
    3f84:	88 0f       	add	r24, r24
    3f86:	99 1f       	adc	r25, r25
    3f88:	88 0f       	add	r24, r24
    3f8a:	99 1f       	adc	r25, r25
    3f8c:	88 0f       	add	r24, r24
    3f8e:	99 1f       	adc	r25, r25
    3f90:	82 0f       	add	r24, r18
    3f92:	93 1f       	adc	r25, r19
    3f94:	ac 01       	movw	r20, r24
    3f96:	4a 52       	subi	r20, 0x2A	; 42
    3f98:	59 4f       	sbci	r21, 0xF9	; 249
    3f9a:	88 85       	ldd	r24, Y+8	; 0x08
    3f9c:	99 85       	ldd	r25, Y+9	; 0x09
    3f9e:	9c 01       	movw	r18, r24
    3fa0:	2e 5f       	subi	r18, 0xFE	; 254
    3fa2:	3f 4f       	sbci	r19, 0xFF	; 255
    3fa4:	ca 01       	movw	r24, r20
    3fa6:	b9 01       	movw	r22, r18
    3fa8:	0e 94 b6 0f 	call	0x1f6c	; 0x1f6c <vListInsertEnd>
						{
							/* Preemption is on, but a context switch should
							only be performed if the unblocked task has a
							priority that is equal to or higher than the
							currently executing task. */
							if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    3fac:	e8 85       	ldd	r30, Y+8	; 0x08
    3fae:	f9 85       	ldd	r31, Y+9	; 0x09
    3fb0:	96 89       	ldd	r25, Z+22	; 0x16
    3fb2:	e0 91 c9 06 	lds	r30, 0x06C9
    3fb6:	f0 91 ca 06 	lds	r31, 0x06CA
    3fba:	86 89       	ldd	r24, Z+22	; 0x16
    3fbc:	98 17       	cp	r25, r24
    3fbe:	08 f4       	brcc	.+2      	; 0x3fc2 <xTaskIncrementTick+0x16c>
    3fc0:	92 cf       	rjmp	.-220    	; 0x3ee6 <xTaskIncrementTick+0x90>
							{
								xSwitchRequired = pdTRUE;
    3fc2:	81 e0       	ldi	r24, 0x01	; 1
    3fc4:	8d 83       	std	Y+5, r24	; 0x05
    3fc6:	8f cf       	rjmp	.-226    	; 0x3ee6 <xTaskIncrementTick+0x90>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
    3fc8:	e0 91 c9 06 	lds	r30, 0x06C9
    3fcc:	f0 91 ca 06 	lds	r31, 0x06CA
    3fd0:	86 89       	ldd	r24, Z+22	; 0x16
    3fd2:	28 2f       	mov	r18, r24
    3fd4:	30 e0       	ldi	r19, 0x00	; 0
    3fd6:	c9 01       	movw	r24, r18
    3fd8:	88 0f       	add	r24, r24
    3fda:	99 1f       	adc	r25, r25
    3fdc:	88 0f       	add	r24, r24
    3fde:	99 1f       	adc	r25, r25
    3fe0:	88 0f       	add	r24, r24
    3fe2:	99 1f       	adc	r25, r25
    3fe4:	82 0f       	add	r24, r18
    3fe6:	93 1f       	adc	r25, r19
    3fe8:	fc 01       	movw	r30, r24
    3fea:	ea 52       	subi	r30, 0x2A	; 42
    3fec:	f9 4f       	sbci	r31, 0xF9	; 249
    3fee:	80 81       	ld	r24, Z
    3ff0:	82 30       	cpi	r24, 0x02	; 2
    3ff2:	40 f0       	brcs	.+16     	; 0x4004 <xTaskIncrementTick+0x1ae>
			{
				xSwitchRequired = pdTRUE;
    3ff4:	81 e0       	ldi	r24, 0x01	; 1
    3ff6:	8d 83       	std	Y+5, r24	; 0x05
    3ff8:	05 c0       	rjmp	.+10     	; 0x4004 <xTaskIncrementTick+0x1ae>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
    3ffa:	80 91 d1 06 	lds	r24, 0x06D1
    3ffe:	8f 5f       	subi	r24, 0xFF	; 255
    4000:	80 93 d1 06 	sts	0x06D1, r24
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
    4004:	80 91 d2 06 	lds	r24, 0x06D2
    4008:	88 23       	and	r24, r24
    400a:	11 f0       	breq	.+4      	; 0x4010 <xTaskIncrementTick+0x1ba>
		{
			xSwitchRequired = pdTRUE;
    400c:	81 e0       	ldi	r24, 0x01	; 1
    400e:	8d 83       	std	Y+5, r24	; 0x05
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
    4010:	8d 81       	ldd	r24, Y+5	; 0x05
}
    4012:	29 96       	adiw	r28, 0x09	; 9
    4014:	0f b6       	in	r0, 0x3f	; 63
    4016:	f8 94       	cli
    4018:	de bf       	out	0x3e, r29	; 62
    401a:	0f be       	out	0x3f, r0	; 63
    401c:	cd bf       	out	0x3d, r28	; 61
    401e:	cf 91       	pop	r28
    4020:	df 91       	pop	r29
    4022:	08 95       	ret

00004024 <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    4024:	df 93       	push	r29
    4026:	cf 93       	push	r28
    4028:	00 d0       	rcall	.+0      	; 0x402a <vTaskSwitchContext+0x6>
    402a:	cd b7       	in	r28, 0x3d	; 61
    402c:	de b7       	in	r29, 0x3e	; 62
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    402e:	80 91 d5 06 	lds	r24, 0x06D5
    4032:	88 23       	and	r24, r24
    4034:	21 f0       	breq	.+8      	; 0x403e <vTaskSwitchContext+0x1a>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
    4036:	81 e0       	ldi	r24, 0x01	; 1
    4038:	80 93 d2 06 	sts	0x06D2, r24
    403c:	57 c0       	rjmp	.+174    	; 0x40ec <vTaskSwitchContext+0xc8>
	}
	else
	{
		xYieldPending = pdFALSE;
    403e:	10 92 d2 06 	sts	0x06D2, r1
    4042:	05 c0       	rjmp	.+10     	; 0x404e <vTaskSwitchContext+0x2a>
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
    4044:	80 91 cf 06 	lds	r24, 0x06CF
    4048:	81 50       	subi	r24, 0x01	; 1
    404a:	80 93 cf 06 	sts	0x06CF, r24
    404e:	80 91 cf 06 	lds	r24, 0x06CF
    4052:	28 2f       	mov	r18, r24
    4054:	30 e0       	ldi	r19, 0x00	; 0
    4056:	c9 01       	movw	r24, r18
    4058:	88 0f       	add	r24, r24
    405a:	99 1f       	adc	r25, r25
    405c:	88 0f       	add	r24, r24
    405e:	99 1f       	adc	r25, r25
    4060:	88 0f       	add	r24, r24
    4062:	99 1f       	adc	r25, r25
    4064:	82 0f       	add	r24, r18
    4066:	93 1f       	adc	r25, r19
    4068:	fc 01       	movw	r30, r24
    406a:	ea 52       	subi	r30, 0x2A	; 42
    406c:	f9 4f       	sbci	r31, 0xF9	; 249
    406e:	80 81       	ld	r24, Z
    4070:	88 23       	and	r24, r24
    4072:	41 f3       	breq	.-48     	; 0x4044 <vTaskSwitchContext+0x20>
    4074:	80 91 cf 06 	lds	r24, 0x06CF
    4078:	28 2f       	mov	r18, r24
    407a:	30 e0       	ldi	r19, 0x00	; 0
    407c:	c9 01       	movw	r24, r18
    407e:	88 0f       	add	r24, r24
    4080:	99 1f       	adc	r25, r25
    4082:	88 0f       	add	r24, r24
    4084:	99 1f       	adc	r25, r25
    4086:	88 0f       	add	r24, r24
    4088:	99 1f       	adc	r25, r25
    408a:	82 0f       	add	r24, r18
    408c:	93 1f       	adc	r25, r19
    408e:	8a 52       	subi	r24, 0x2A	; 42
    4090:	99 4f       	sbci	r25, 0xF9	; 249
    4092:	9a 83       	std	Y+2, r25	; 0x02
    4094:	89 83       	std	Y+1, r24	; 0x01
    4096:	e9 81       	ldd	r30, Y+1	; 0x01
    4098:	fa 81       	ldd	r31, Y+2	; 0x02
    409a:	01 80       	ldd	r0, Z+1	; 0x01
    409c:	f2 81       	ldd	r31, Z+2	; 0x02
    409e:	e0 2d       	mov	r30, r0
    40a0:	82 81       	ldd	r24, Z+2	; 0x02
    40a2:	93 81       	ldd	r25, Z+3	; 0x03
    40a4:	e9 81       	ldd	r30, Y+1	; 0x01
    40a6:	fa 81       	ldd	r31, Y+2	; 0x02
    40a8:	92 83       	std	Z+2, r25	; 0x02
    40aa:	81 83       	std	Z+1, r24	; 0x01
    40ac:	e9 81       	ldd	r30, Y+1	; 0x01
    40ae:	fa 81       	ldd	r31, Y+2	; 0x02
    40b0:	21 81       	ldd	r18, Z+1	; 0x01
    40b2:	32 81       	ldd	r19, Z+2	; 0x02
    40b4:	89 81       	ldd	r24, Y+1	; 0x01
    40b6:	9a 81       	ldd	r25, Y+2	; 0x02
    40b8:	03 96       	adiw	r24, 0x03	; 3
    40ba:	28 17       	cp	r18, r24
    40bc:	39 07       	cpc	r19, r25
    40be:	59 f4       	brne	.+22     	; 0x40d6 <vTaskSwitchContext+0xb2>
    40c0:	e9 81       	ldd	r30, Y+1	; 0x01
    40c2:	fa 81       	ldd	r31, Y+2	; 0x02
    40c4:	01 80       	ldd	r0, Z+1	; 0x01
    40c6:	f2 81       	ldd	r31, Z+2	; 0x02
    40c8:	e0 2d       	mov	r30, r0
    40ca:	82 81       	ldd	r24, Z+2	; 0x02
    40cc:	93 81       	ldd	r25, Z+3	; 0x03
    40ce:	e9 81       	ldd	r30, Y+1	; 0x01
    40d0:	fa 81       	ldd	r31, Y+2	; 0x02
    40d2:	92 83       	std	Z+2, r25	; 0x02
    40d4:	81 83       	std	Z+1, r24	; 0x01
    40d6:	e9 81       	ldd	r30, Y+1	; 0x01
    40d8:	fa 81       	ldd	r31, Y+2	; 0x02
    40da:	01 80       	ldd	r0, Z+1	; 0x01
    40dc:	f2 81       	ldd	r31, Z+2	; 0x02
    40de:	e0 2d       	mov	r30, r0
    40e0:	86 81       	ldd	r24, Z+6	; 0x06
    40e2:	97 81       	ldd	r25, Z+7	; 0x07
    40e4:	90 93 ca 06 	sts	0x06CA, r25
    40e8:	80 93 c9 06 	sts	0x06C9, r24
			structure specific to this task. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
	}
}
    40ec:	0f 90       	pop	r0
    40ee:	0f 90       	pop	r0
    40f0:	cf 91       	pop	r28
    40f2:	df 91       	pop	r29
    40f4:	08 95       	ret

000040f6 <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
    40f6:	df 93       	push	r29
    40f8:	cf 93       	push	r28
    40fa:	00 d0       	rcall	.+0      	; 0x40fc <vTaskPlaceOnEventList+0x6>
    40fc:	00 d0       	rcall	.+0      	; 0x40fe <vTaskPlaceOnEventList+0x8>
    40fe:	00 d0       	rcall	.+0      	; 0x4100 <vTaskPlaceOnEventList+0xa>
    4100:	cd b7       	in	r28, 0x3d	; 61
    4102:	de b7       	in	r29, 0x3e	; 62
    4104:	9c 83       	std	Y+4, r25	; 0x04
    4106:	8b 83       	std	Y+3, r24	; 0x03
    4108:	7e 83       	std	Y+6, r23	; 0x06
    410a:	6d 83       	std	Y+5, r22	; 0x05

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    410c:	80 91 c9 06 	lds	r24, 0x06C9
    4110:	90 91 ca 06 	lds	r25, 0x06CA
    4114:	9c 01       	movw	r18, r24
    4116:	24 5f       	subi	r18, 0xF4	; 244
    4118:	3f 4f       	sbci	r19, 0xFF	; 255
    411a:	8b 81       	ldd	r24, Y+3	; 0x03
    411c:	9c 81       	ldd	r25, Y+4	; 0x04
    411e:	b9 01       	movw	r22, r18
    4120:	0e 94 fa 0f 	call	0x1ff4	; 0x1ff4 <vListInsert>

	/* The task must be removed from from the ready list before it is added to
	the blocked list as the same list item is used for both lists.  Exclusive
	access to the ready lists guaranteed because the scheduler is locked. */
	if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    4124:	80 91 c9 06 	lds	r24, 0x06C9
    4128:	90 91 ca 06 	lds	r25, 0x06CA
    412c:	02 96       	adiw	r24, 0x02	; 2
    412e:	0e 94 66 10 	call	0x20cc	; 0x20cc <uxListRemove>
	#else /* INCLUDE_vTaskSuspend */
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter, the scheduler
			will handle it. */
			xTimeToWake = xTickCount + xTicksToWait;
    4132:	20 91 cd 06 	lds	r18, 0x06CD
    4136:	30 91 ce 06 	lds	r19, 0x06CE
    413a:	8d 81       	ldd	r24, Y+5	; 0x05
    413c:	9e 81       	ldd	r25, Y+6	; 0x06
    413e:	82 0f       	add	r24, r18
    4140:	93 1f       	adc	r25, r19
    4142:	9a 83       	std	Y+2, r25	; 0x02
    4144:	89 83       	std	Y+1, r24	; 0x01
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    4146:	89 81       	ldd	r24, Y+1	; 0x01
    4148:	9a 81       	ldd	r25, Y+2	; 0x02
    414a:	0e 94 4f 23 	call	0x469e	; 0x469e <prvAddCurrentTaskToDelayedList>
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    414e:	26 96       	adiw	r28, 0x06	; 6
    4150:	0f b6       	in	r0, 0x3f	; 63
    4152:	f8 94       	cli
    4154:	de bf       	out	0x3e, r29	; 62
    4156:	0f be       	out	0x3f, r0	; 63
    4158:	cd bf       	out	0x3d, r28	; 61
    415a:	cf 91       	pop	r28
    415c:	df 91       	pop	r29
    415e:	08 95       	ret

00004160 <vTaskPlaceOnUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
{
    4160:	df 93       	push	r29
    4162:	cf 93       	push	r28
    4164:	cd b7       	in	r28, 0x3d	; 61
    4166:	de b7       	in	r29, 0x3e	; 62
    4168:	28 97       	sbiw	r28, 0x08	; 8
    416a:	0f b6       	in	r0, 0x3f	; 63
    416c:	f8 94       	cli
    416e:	de bf       	out	0x3e, r29	; 62
    4170:	0f be       	out	0x3f, r0	; 63
    4172:	cd bf       	out	0x3d, r28	; 61
    4174:	9c 83       	std	Y+4, r25	; 0x04
    4176:	8b 83       	std	Y+3, r24	; 0x03
    4178:	7e 83       	std	Y+6, r23	; 0x06
    417a:	6d 83       	std	Y+5, r22	; 0x05
    417c:	58 87       	std	Y+8, r21	; 0x08
    417e:	4f 83       	std	Y+7, r20	; 0x07
	configASSERT( uxSchedulerSuspended != 0 );

	/* Store the item value in the event list item.  It is safe to access the
	event list item here as interrupts won't access the event list item of a
	task that is not in the Blocked state. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    4180:	e0 91 c9 06 	lds	r30, 0x06C9
    4184:	f0 91 ca 06 	lds	r31, 0x06CA
    4188:	8d 81       	ldd	r24, Y+5	; 0x05
    418a:	9e 81       	ldd	r25, Y+6	; 0x06
    418c:	90 68       	ori	r25, 0x80	; 128
    418e:	95 87       	std	Z+13, r25	; 0x0d
    4190:	84 87       	std	Z+12, r24	; 0x0c
	/* Place the event list item of the TCB at the end of the appropriate event
	list.  It is safe to access the event list here because it is part of an
	event group implementation - and interrupts don't access event groups
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    4192:	80 91 c9 06 	lds	r24, 0x06C9
    4196:	90 91 ca 06 	lds	r25, 0x06CA
    419a:	9c 01       	movw	r18, r24
    419c:	24 5f       	subi	r18, 0xF4	; 244
    419e:	3f 4f       	sbci	r19, 0xFF	; 255
    41a0:	8b 81       	ldd	r24, Y+3	; 0x03
    41a2:	9c 81       	ldd	r25, Y+4	; 0x04
    41a4:	b9 01       	movw	r22, r18
    41a6:	0e 94 b6 0f 	call	0x1f6c	; 0x1f6c <vListInsertEnd>

	/* The task must be removed from the ready list before it is added to the
	blocked list.  Exclusive access can be assured to the ready list as the
	scheduler is locked. */
	if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    41aa:	80 91 c9 06 	lds	r24, 0x06C9
    41ae:	90 91 ca 06 	lds	r25, 0x06CA
    41b2:	02 96       	adiw	r24, 0x02	; 2
    41b4:	0e 94 66 10 	call	0x20cc	; 0x20cc <uxListRemove>
	#else /* INCLUDE_vTaskSuspend */
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter, the kernel
			will manage it correctly. */
			xTimeToWake = xTickCount + xTicksToWait;
    41b8:	20 91 cd 06 	lds	r18, 0x06CD
    41bc:	30 91 ce 06 	lds	r19, 0x06CE
    41c0:	8f 81       	ldd	r24, Y+7	; 0x07
    41c2:	98 85       	ldd	r25, Y+8	; 0x08
    41c4:	82 0f       	add	r24, r18
    41c6:	93 1f       	adc	r25, r19
    41c8:	9a 83       	std	Y+2, r25	; 0x02
    41ca:	89 83       	std	Y+1, r24	; 0x01
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    41cc:	89 81       	ldd	r24, Y+1	; 0x01
    41ce:	9a 81       	ldd	r25, Y+2	; 0x02
    41d0:	0e 94 4f 23 	call	0x469e	; 0x469e <prvAddCurrentTaskToDelayedList>
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    41d4:	28 96       	adiw	r28, 0x08	; 8
    41d6:	0f b6       	in	r0, 0x3f	; 63
    41d8:	f8 94       	cli
    41da:	de bf       	out	0x3e, r29	; 62
    41dc:	0f be       	out	0x3f, r0	; 63
    41de:	cd bf       	out	0x3d, r28	; 61
    41e0:	cf 91       	pop	r28
    41e2:	df 91       	pop	r29
    41e4:	08 95       	ret

000041e6 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
    41e6:	df 93       	push	r29
    41e8:	cf 93       	push	r28
    41ea:	00 d0       	rcall	.+0      	; 0x41ec <xTaskRemoveFromEventList+0x6>
    41ec:	00 d0       	rcall	.+0      	; 0x41ee <xTaskRemoveFromEventList+0x8>
    41ee:	0f 92       	push	r0
    41f0:	cd b7       	in	r28, 0x3d	; 61
    41f2:	de b7       	in	r29, 0x3e	; 62
    41f4:	9d 83       	std	Y+5, r25	; 0x05
    41f6:	8c 83       	std	Y+4, r24	; 0x04
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    41f8:	ec 81       	ldd	r30, Y+4	; 0x04
    41fa:	fd 81       	ldd	r31, Y+5	; 0x05
    41fc:	05 80       	ldd	r0, Z+5	; 0x05
    41fe:	f6 81       	ldd	r31, Z+6	; 0x06
    4200:	e0 2d       	mov	r30, r0
    4202:	86 81       	ldd	r24, Z+6	; 0x06
    4204:	97 81       	ldd	r25, Z+7	; 0x07
    4206:	9b 83       	std	Y+3, r25	; 0x03
    4208:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
    420a:	8a 81       	ldd	r24, Y+2	; 0x02
    420c:	9b 81       	ldd	r25, Y+3	; 0x03
    420e:	0c 96       	adiw	r24, 0x0c	; 12
    4210:	0e 94 66 10 	call	0x20cc	; 0x20cc <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    4214:	80 91 d5 06 	lds	r24, 0x06D5
    4218:	88 23       	and	r24, r24
    421a:	61 f5       	brne	.+88     	; 0x4274 <xTaskRemoveFromEventList+0x8e>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    421c:	8a 81       	ldd	r24, Y+2	; 0x02
    421e:	9b 81       	ldd	r25, Y+3	; 0x03
    4220:	02 96       	adiw	r24, 0x02	; 2
    4222:	0e 94 66 10 	call	0x20cc	; 0x20cc <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
    4226:	ea 81       	ldd	r30, Y+2	; 0x02
    4228:	fb 81       	ldd	r31, Y+3	; 0x03
    422a:	96 89       	ldd	r25, Z+22	; 0x16
    422c:	80 91 cf 06 	lds	r24, 0x06CF
    4230:	89 17       	cp	r24, r25
    4232:	28 f4       	brcc	.+10     	; 0x423e <xTaskRemoveFromEventList+0x58>
    4234:	ea 81       	ldd	r30, Y+2	; 0x02
    4236:	fb 81       	ldd	r31, Y+3	; 0x03
    4238:	86 89       	ldd	r24, Z+22	; 0x16
    423a:	80 93 cf 06 	sts	0x06CF, r24
    423e:	ea 81       	ldd	r30, Y+2	; 0x02
    4240:	fb 81       	ldd	r31, Y+3	; 0x03
    4242:	86 89       	ldd	r24, Z+22	; 0x16
    4244:	28 2f       	mov	r18, r24
    4246:	30 e0       	ldi	r19, 0x00	; 0
    4248:	c9 01       	movw	r24, r18
    424a:	88 0f       	add	r24, r24
    424c:	99 1f       	adc	r25, r25
    424e:	88 0f       	add	r24, r24
    4250:	99 1f       	adc	r25, r25
    4252:	88 0f       	add	r24, r24
    4254:	99 1f       	adc	r25, r25
    4256:	82 0f       	add	r24, r18
    4258:	93 1f       	adc	r25, r19
    425a:	ac 01       	movw	r20, r24
    425c:	4a 52       	subi	r20, 0x2A	; 42
    425e:	59 4f       	sbci	r21, 0xF9	; 249
    4260:	8a 81       	ldd	r24, Y+2	; 0x02
    4262:	9b 81       	ldd	r25, Y+3	; 0x03
    4264:	9c 01       	movw	r18, r24
    4266:	2e 5f       	subi	r18, 0xFE	; 254
    4268:	3f 4f       	sbci	r19, 0xFF	; 255
    426a:	ca 01       	movw	r24, r20
    426c:	b9 01       	movw	r22, r18
    426e:	0e 94 b6 0f 	call	0x1f6c	; 0x1f6c <vListInsertEnd>
    4272:	0a c0       	rjmp	.+20     	; 0x4288 <xTaskRemoveFromEventList+0xa2>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    4274:	8a 81       	ldd	r24, Y+2	; 0x02
    4276:	9b 81       	ldd	r25, Y+3	; 0x03
    4278:	9c 01       	movw	r18, r24
    427a:	24 5f       	subi	r18, 0xF4	; 244
    427c:	3f 4f       	sbci	r19, 0xFF	; 255
    427e:	8b e2       	ldi	r24, 0x2B	; 43
    4280:	97 e0       	ldi	r25, 0x07	; 7
    4282:	b9 01       	movw	r22, r18
    4284:	0e 94 b6 0f 	call	0x1f6c	; 0x1f6c <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    4288:	ea 81       	ldd	r30, Y+2	; 0x02
    428a:	fb 81       	ldd	r31, Y+3	; 0x03
    428c:	96 89       	ldd	r25, Z+22	; 0x16
    428e:	e0 91 c9 06 	lds	r30, 0x06C9
    4292:	f0 91 ca 06 	lds	r31, 0x06CA
    4296:	86 89       	ldd	r24, Z+22	; 0x16
    4298:	89 17       	cp	r24, r25
    429a:	30 f4       	brcc	.+12     	; 0x42a8 <xTaskRemoveFromEventList+0xc2>
	{
		/* Return true if the task removed from the event list has a higher
		priority than the calling task.  This allows the calling task to know if
		it should force a context switch now. */
		xReturn = pdTRUE;
    429c:	81 e0       	ldi	r24, 0x01	; 1
    429e:	89 83       	std	Y+1, r24	; 0x01

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    42a0:	81 e0       	ldi	r24, 0x01	; 1
    42a2:	80 93 d2 06 	sts	0x06D2, r24
    42a6:	01 c0       	rjmp	.+2      	; 0x42aa <xTaskRemoveFromEventList+0xc4>
	}
	else
	{
		xReturn = pdFALSE;
    42a8:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    42aa:	89 81       	ldd	r24, Y+1	; 0x01
}
    42ac:	0f 90       	pop	r0
    42ae:	0f 90       	pop	r0
    42b0:	0f 90       	pop	r0
    42b2:	0f 90       	pop	r0
    42b4:	0f 90       	pop	r0
    42b6:	cf 91       	pop	r28
    42b8:	df 91       	pop	r29
    42ba:	08 95       	ret

000042bc <xTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
{
    42bc:	df 93       	push	r29
    42be:	cf 93       	push	r28
    42c0:	cd b7       	in	r28, 0x3d	; 61
    42c2:	de b7       	in	r29, 0x3e	; 62
    42c4:	27 97       	sbiw	r28, 0x07	; 7
    42c6:	0f b6       	in	r0, 0x3f	; 63
    42c8:	f8 94       	cli
    42ca:	de bf       	out	0x3e, r29	; 62
    42cc:	0f be       	out	0x3f, r0	; 63
    42ce:	cd bf       	out	0x3d, r28	; 61
    42d0:	9d 83       	std	Y+5, r25	; 0x05
    42d2:	8c 83       	std	Y+4, r24	; 0x04
    42d4:	7f 83       	std	Y+7, r23	; 0x07
    42d6:	6e 83       	std	Y+6, r22	; 0x06
	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
	the event flags implementation. */
	configASSERT( uxSchedulerSuspended != pdFALSE );

	/* Store the new item value in the event list. */
	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    42d8:	8e 81       	ldd	r24, Y+6	; 0x06
    42da:	9f 81       	ldd	r25, Y+7	; 0x07
    42dc:	90 68       	ori	r25, 0x80	; 128
    42de:	ec 81       	ldd	r30, Y+4	; 0x04
    42e0:	fd 81       	ldd	r31, Y+5	; 0x05
    42e2:	91 83       	std	Z+1, r25	; 0x01
    42e4:	80 83       	st	Z, r24

	/* Remove the event list form the event flag.  Interrupts do not access
	event flags. */
	pxUnblockedTCB = ( TCB_t * ) listGET_LIST_ITEM_OWNER( pxEventListItem );
    42e6:	ec 81       	ldd	r30, Y+4	; 0x04
    42e8:	fd 81       	ldd	r31, Y+5	; 0x05
    42ea:	86 81       	ldd	r24, Z+6	; 0x06
    42ec:	97 81       	ldd	r25, Z+7	; 0x07
    42ee:	9b 83       	std	Y+3, r25	; 0x03
    42f0:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( pxEventListItem );
    42f2:	8c 81       	ldd	r24, Y+4	; 0x04
    42f4:	9d 81       	ldd	r25, Y+5	; 0x05
    42f6:	0e 94 66 10 	call	0x20cc	; 0x20cc <uxListRemove>

	/* Remove the task from the delayed list and add it to the ready list.  The
	scheduler is suspended so interrupts will not be accessing the ready
	lists. */
	( void ) uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    42fa:	8a 81       	ldd	r24, Y+2	; 0x02
    42fc:	9b 81       	ldd	r25, Y+3	; 0x03
    42fe:	02 96       	adiw	r24, 0x02	; 2
    4300:	0e 94 66 10 	call	0x20cc	; 0x20cc <uxListRemove>
	prvAddTaskToReadyList( pxUnblockedTCB );
    4304:	ea 81       	ldd	r30, Y+2	; 0x02
    4306:	fb 81       	ldd	r31, Y+3	; 0x03
    4308:	96 89       	ldd	r25, Z+22	; 0x16
    430a:	80 91 cf 06 	lds	r24, 0x06CF
    430e:	89 17       	cp	r24, r25
    4310:	28 f4       	brcc	.+10     	; 0x431c <xTaskRemoveFromUnorderedEventList+0x60>
    4312:	ea 81       	ldd	r30, Y+2	; 0x02
    4314:	fb 81       	ldd	r31, Y+3	; 0x03
    4316:	86 89       	ldd	r24, Z+22	; 0x16
    4318:	80 93 cf 06 	sts	0x06CF, r24
    431c:	ea 81       	ldd	r30, Y+2	; 0x02
    431e:	fb 81       	ldd	r31, Y+3	; 0x03
    4320:	86 89       	ldd	r24, Z+22	; 0x16
    4322:	28 2f       	mov	r18, r24
    4324:	30 e0       	ldi	r19, 0x00	; 0
    4326:	c9 01       	movw	r24, r18
    4328:	88 0f       	add	r24, r24
    432a:	99 1f       	adc	r25, r25
    432c:	88 0f       	add	r24, r24
    432e:	99 1f       	adc	r25, r25
    4330:	88 0f       	add	r24, r24
    4332:	99 1f       	adc	r25, r25
    4334:	82 0f       	add	r24, r18
    4336:	93 1f       	adc	r25, r19
    4338:	ac 01       	movw	r20, r24
    433a:	4a 52       	subi	r20, 0x2A	; 42
    433c:	59 4f       	sbci	r21, 0xF9	; 249
    433e:	8a 81       	ldd	r24, Y+2	; 0x02
    4340:	9b 81       	ldd	r25, Y+3	; 0x03
    4342:	9c 01       	movw	r18, r24
    4344:	2e 5f       	subi	r18, 0xFE	; 254
    4346:	3f 4f       	sbci	r19, 0xFF	; 255
    4348:	ca 01       	movw	r24, r20
    434a:	b9 01       	movw	r22, r18
    434c:	0e 94 b6 0f 	call	0x1f6c	; 0x1f6c <vListInsertEnd>

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    4350:	ea 81       	ldd	r30, Y+2	; 0x02
    4352:	fb 81       	ldd	r31, Y+3	; 0x03
    4354:	96 89       	ldd	r25, Z+22	; 0x16
    4356:	e0 91 c9 06 	lds	r30, 0x06C9
    435a:	f0 91 ca 06 	lds	r31, 0x06CA
    435e:	86 89       	ldd	r24, Z+22	; 0x16
    4360:	89 17       	cp	r24, r25
    4362:	30 f4       	brcc	.+12     	; 0x4370 <xTaskRemoveFromUnorderedEventList+0xb4>
	{
		/* Return true if the task removed from the event list has
		a higher priority than the calling task.  This allows
		the calling task to know if it should force a context
		switch now. */
		xReturn = pdTRUE;
    4364:	81 e0       	ldi	r24, 0x01	; 1
    4366:	89 83       	std	Y+1, r24	; 0x01

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    4368:	81 e0       	ldi	r24, 0x01	; 1
    436a:	80 93 d2 06 	sts	0x06D2, r24
    436e:	01 c0       	rjmp	.+2      	; 0x4372 <xTaskRemoveFromUnorderedEventList+0xb6>
	}
	else
	{
		xReturn = pdFALSE;
    4370:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    4372:	89 81       	ldd	r24, Y+1	; 0x01
}
    4374:	27 96       	adiw	r28, 0x07	; 7
    4376:	0f b6       	in	r0, 0x3f	; 63
    4378:	f8 94       	cli
    437a:	de bf       	out	0x3e, r29	; 62
    437c:	0f be       	out	0x3f, r0	; 63
    437e:	cd bf       	out	0x3d, r28	; 61
    4380:	cf 91       	pop	r28
    4382:	df 91       	pop	r29
    4384:	08 95       	ret

00004386 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    4386:	df 93       	push	r29
    4388:	cf 93       	push	r28
    438a:	00 d0       	rcall	.+0      	; 0x438c <vTaskSetTimeOutState+0x6>
    438c:	cd b7       	in	r28, 0x3d	; 61
    438e:	de b7       	in	r29, 0x3e	; 62
    4390:	9a 83       	std	Y+2, r25	; 0x02
    4392:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    4394:	80 91 d3 06 	lds	r24, 0x06D3
    4398:	e9 81       	ldd	r30, Y+1	; 0x01
    439a:	fa 81       	ldd	r31, Y+2	; 0x02
    439c:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    439e:	80 91 cd 06 	lds	r24, 0x06CD
    43a2:	90 91 ce 06 	lds	r25, 0x06CE
    43a6:	e9 81       	ldd	r30, Y+1	; 0x01
    43a8:	fa 81       	ldd	r31, Y+2	; 0x02
    43aa:	92 83       	std	Z+2, r25	; 0x02
    43ac:	81 83       	std	Z+1, r24	; 0x01
}
    43ae:	0f 90       	pop	r0
    43b0:	0f 90       	pop	r0
    43b2:	cf 91       	pop	r28
    43b4:	df 91       	pop	r29
    43b6:	08 95       	ret

000043b8 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
    43b8:	df 93       	push	r29
    43ba:	cf 93       	push	r28
    43bc:	cd b7       	in	r28, 0x3d	; 61
    43be:	de b7       	in	r29, 0x3e	; 62
    43c0:	27 97       	sbiw	r28, 0x07	; 7
    43c2:	0f b6       	in	r0, 0x3f	; 63
    43c4:	f8 94       	cli
    43c6:	de bf       	out	0x3e, r29	; 62
    43c8:	0f be       	out	0x3f, r0	; 63
    43ca:	cd bf       	out	0x3d, r28	; 61
    43cc:	9d 83       	std	Y+5, r25	; 0x05
    43ce:	8c 83       	std	Y+4, r24	; 0x04
    43d0:	7f 83       	std	Y+7, r23	; 0x07
    43d2:	6e 83       	std	Y+6, r22	; 0x06
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    43d4:	0f b6       	in	r0, 0x3f	; 63
    43d6:	f8 94       	cli
    43d8:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
    43da:	80 91 cd 06 	lds	r24, 0x06CD
    43de:	90 91 ce 06 	lds	r25, 0x06CE
    43e2:	9a 83       	std	Y+2, r25	; 0x02
    43e4:	89 83       	std	Y+1, r24	; 0x01
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    43e6:	ec 81       	ldd	r30, Y+4	; 0x04
    43e8:	fd 81       	ldd	r31, Y+5	; 0x05
    43ea:	90 81       	ld	r25, Z
    43ec:	80 91 d3 06 	lds	r24, 0x06D3
    43f0:	98 17       	cp	r25, r24
    43f2:	61 f0       	breq	.+24     	; 0x440c <xTaskCheckForTimeOut+0x54>
    43f4:	ec 81       	ldd	r30, Y+4	; 0x04
    43f6:	fd 81       	ldd	r31, Y+5	; 0x05
    43f8:	21 81       	ldd	r18, Z+1	; 0x01
    43fa:	32 81       	ldd	r19, Z+2	; 0x02
    43fc:	89 81       	ldd	r24, Y+1	; 0x01
    43fe:	9a 81       	ldd	r25, Y+2	; 0x02
    4400:	82 17       	cp	r24, r18
    4402:	93 07       	cpc	r25, r19
    4404:	18 f0       	brcs	.+6      	; 0x440c <xTaskCheckForTimeOut+0x54>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    4406:	81 e0       	ldi	r24, 0x01	; 1
    4408:	8b 83       	std	Y+3, r24	; 0x03
    440a:	2d c0       	rjmp	.+90     	; 0x4466 <xTaskCheckForTimeOut+0xae>
		}
		else if( ( xConstTickCount - pxTimeOut->xTimeOnEntering ) < *pxTicksToWait )
    440c:	ec 81       	ldd	r30, Y+4	; 0x04
    440e:	fd 81       	ldd	r31, Y+5	; 0x05
    4410:	21 81       	ldd	r18, Z+1	; 0x01
    4412:	32 81       	ldd	r19, Z+2	; 0x02
    4414:	89 81       	ldd	r24, Y+1	; 0x01
    4416:	9a 81       	ldd	r25, Y+2	; 0x02
    4418:	ac 01       	movw	r20, r24
    441a:	42 1b       	sub	r20, r18
    441c:	53 0b       	sbc	r21, r19
    441e:	9a 01       	movw	r18, r20
    4420:	ee 81       	ldd	r30, Y+6	; 0x06
    4422:	ff 81       	ldd	r31, Y+7	; 0x07
    4424:	80 81       	ld	r24, Z
    4426:	91 81       	ldd	r25, Z+1	; 0x01
    4428:	28 17       	cp	r18, r24
    442a:	39 07       	cpc	r19, r25
    442c:	d0 f4       	brcc	.+52     	; 0x4462 <xTaskCheckForTimeOut+0xaa>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( xConstTickCount -  pxTimeOut->xTimeOnEntering );
    442e:	ee 81       	ldd	r30, Y+6	; 0x06
    4430:	ff 81       	ldd	r31, Y+7	; 0x07
    4432:	40 81       	ld	r20, Z
    4434:	51 81       	ldd	r21, Z+1	; 0x01
    4436:	ec 81       	ldd	r30, Y+4	; 0x04
    4438:	fd 81       	ldd	r31, Y+5	; 0x05
    443a:	21 81       	ldd	r18, Z+1	; 0x01
    443c:	32 81       	ldd	r19, Z+2	; 0x02
    443e:	89 81       	ldd	r24, Y+1	; 0x01
    4440:	9a 81       	ldd	r25, Y+2	; 0x02
    4442:	b9 01       	movw	r22, r18
    4444:	68 1b       	sub	r22, r24
    4446:	79 0b       	sbc	r23, r25
    4448:	cb 01       	movw	r24, r22
    444a:	84 0f       	add	r24, r20
    444c:	95 1f       	adc	r25, r21
    444e:	ee 81       	ldd	r30, Y+6	; 0x06
    4450:	ff 81       	ldd	r31, Y+7	; 0x07
    4452:	91 83       	std	Z+1, r25	; 0x01
    4454:	80 83       	st	Z, r24
			vTaskSetTimeOutState( pxTimeOut );
    4456:	8c 81       	ldd	r24, Y+4	; 0x04
    4458:	9d 81       	ldd	r25, Y+5	; 0x05
    445a:	0e 94 c3 21 	call	0x4386	; 0x4386 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    445e:	1b 82       	std	Y+3, r1	; 0x03
    4460:	02 c0       	rjmp	.+4      	; 0x4466 <xTaskCheckForTimeOut+0xae>
		}
		else
		{
			xReturn = pdTRUE;
    4462:	81 e0       	ldi	r24, 0x01	; 1
    4464:	8b 83       	std	Y+3, r24	; 0x03
		}
	}
	taskEXIT_CRITICAL();
    4466:	0f 90       	pop	r0
    4468:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    446a:	8b 81       	ldd	r24, Y+3	; 0x03
}
    446c:	27 96       	adiw	r28, 0x07	; 7
    446e:	0f b6       	in	r0, 0x3f	; 63
    4470:	f8 94       	cli
    4472:	de bf       	out	0x3e, r29	; 62
    4474:	0f be       	out	0x3f, r0	; 63
    4476:	cd bf       	out	0x3d, r28	; 61
    4478:	cf 91       	pop	r28
    447a:	df 91       	pop	r29
    447c:	08 95       	ret

0000447e <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    447e:	df 93       	push	r29
    4480:	cf 93       	push	r28
    4482:	cd b7       	in	r28, 0x3d	; 61
    4484:	de b7       	in	r29, 0x3e	; 62
	xYieldPending = pdTRUE;
    4486:	81 e0       	ldi	r24, 0x01	; 1
    4488:	80 93 d2 06 	sts	0x06D2, r24
}
    448c:	cf 91       	pop	r28
    448e:	df 91       	pop	r29
    4490:	08 95       	ret

00004492 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    4492:	df 93       	push	r29
    4494:	cf 93       	push	r28
    4496:	00 d0       	rcall	.+0      	; 0x4498 <prvIdleTask+0x6>
    4498:	cd b7       	in	r28, 0x3d	; 61
    449a:	de b7       	in	r29, 0x3e	; 62
    449c:	9a 83       	std	Y+2, r25	; 0x02
    449e:	89 83       	std	Y+1, r24	; 0x01
	( void ) pvParameters;

	for( ;; )
	{
		/* See if any tasks have been deleted. */
		prvCheckTasksWaitingTermination();
    44a0:	0e 94 10 23 	call	0x4620	; 0x4620 <prvCheckTasksWaitingTermination>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
    44a4:	80 91 d6 06 	lds	r24, 0x06D6
    44a8:	82 30       	cpi	r24, 0x02	; 2
    44aa:	d0 f3       	brcs	.-12     	; 0x44a0 <prvIdleTask+0xe>
			{
				taskYIELD();
    44ac:	0e 94 71 12 	call	0x24e2	; 0x24e2 <vPortYield>
    44b0:	f7 cf       	rjmp	.-18     	; 0x44a0 <prvIdleTask+0xe>

000044b2 <prvInitialiseTCBVariables>:
	}
#endif /* configUSE_TICKLESS_IDLE */
/*-----------------------------------------------------------*/

static void prvInitialiseTCBVariables( TCB_t * const pxTCB, const char * const pcName, UBaseType_t uxPriority, const MemoryRegion_t * const xRegions, const uint16_t usStackDepth ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
    44b2:	0f 93       	push	r16
    44b4:	1f 93       	push	r17
    44b6:	df 93       	push	r29
    44b8:	cf 93       	push	r28
    44ba:	cd b7       	in	r28, 0x3d	; 61
    44bc:	de b7       	in	r29, 0x3e	; 62
    44be:	2a 97       	sbiw	r28, 0x0a	; 10
    44c0:	0f b6       	in	r0, 0x3f	; 63
    44c2:	f8 94       	cli
    44c4:	de bf       	out	0x3e, r29	; 62
    44c6:	0f be       	out	0x3f, r0	; 63
    44c8:	cd bf       	out	0x3d, r28	; 61
    44ca:	9b 83       	std	Y+3, r25	; 0x03
    44cc:	8a 83       	std	Y+2, r24	; 0x02
    44ce:	7d 83       	std	Y+5, r23	; 0x05
    44d0:	6c 83       	std	Y+4, r22	; 0x04
    44d2:	4e 83       	std	Y+6, r20	; 0x06
    44d4:	38 87       	std	Y+8, r19	; 0x08
    44d6:	2f 83       	std	Y+7, r18	; 0x07
    44d8:	1a 87       	std	Y+10, r17	; 0x0a
    44da:	09 87       	std	Y+9, r16	; 0x09
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    44dc:	19 82       	std	Y+1, r1	; 0x01
    44de:	21 c0       	rjmp	.+66     	; 0x4522 <prvInitialiseTCBVariables+0x70>
	{
		pxTCB->pcTaskName[ x ] = pcName[ x ];
    44e0:	89 81       	ldd	r24, Y+1	; 0x01
    44e2:	48 2f       	mov	r20, r24
    44e4:	50 e0       	ldi	r21, 0x00	; 0
    44e6:	89 81       	ldd	r24, Y+1	; 0x01
    44e8:	28 2f       	mov	r18, r24
    44ea:	30 e0       	ldi	r19, 0x00	; 0
    44ec:	8c 81       	ldd	r24, Y+4	; 0x04
    44ee:	9d 81       	ldd	r25, Y+5	; 0x05
    44f0:	fc 01       	movw	r30, r24
    44f2:	e2 0f       	add	r30, r18
    44f4:	f3 1f       	adc	r31, r19
    44f6:	20 81       	ld	r18, Z
    44f8:	8a 81       	ldd	r24, Y+2	; 0x02
    44fa:	9b 81       	ldd	r25, Y+3	; 0x03
    44fc:	84 0f       	add	r24, r20
    44fe:	95 1f       	adc	r25, r21
    4500:	fc 01       	movw	r30, r24
    4502:	79 96       	adiw	r30, 0x19	; 25
    4504:	20 83       	st	Z, r18

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
    4506:	89 81       	ldd	r24, Y+1	; 0x01
    4508:	28 2f       	mov	r18, r24
    450a:	30 e0       	ldi	r19, 0x00	; 0
    450c:	8c 81       	ldd	r24, Y+4	; 0x04
    450e:	9d 81       	ldd	r25, Y+5	; 0x05
    4510:	fc 01       	movw	r30, r24
    4512:	e2 0f       	add	r30, r18
    4514:	f3 1f       	adc	r31, r19
    4516:	80 81       	ld	r24, Z
    4518:	88 23       	and	r24, r24
    451a:	31 f0       	breq	.+12     	; 0x4528 <prvInitialiseTCBVariables+0x76>
static void prvInitialiseTCBVariables( TCB_t * const pxTCB, const char * const pcName, UBaseType_t uxPriority, const MemoryRegion_t * const xRegions, const uint16_t usStackDepth ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    451c:	89 81       	ldd	r24, Y+1	; 0x01
    451e:	8f 5f       	subi	r24, 0xFF	; 255
    4520:	89 83       	std	Y+1, r24	; 0x01
    4522:	89 81       	ldd	r24, Y+1	; 0x01
    4524:	84 31       	cpi	r24, 0x14	; 20
    4526:	e0 f2       	brcs	.-72     	; 0x44e0 <prvInitialiseTCBVariables+0x2e>
		}
	}

	/* Ensure the name string is terminated in the case that the string length
	was greater or equal to configMAX_TASK_NAME_LEN. */
	pxTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    4528:	ea 81       	ldd	r30, Y+2	; 0x02
    452a:	fb 81       	ldd	r31, Y+3	; 0x03
    452c:	14 a6       	std	Z+44, r1	; 0x2c

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
    452e:	8e 81       	ldd	r24, Y+6	; 0x06
    4530:	87 30       	cpi	r24, 0x07	; 7
    4532:	10 f0       	brcs	.+4      	; 0x4538 <prvInitialiseTCBVariables+0x86>
	{
		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
    4534:	86 e0       	ldi	r24, 0x06	; 6
    4536:	8e 83       	std	Y+6, r24	; 0x06
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxTCB->uxPriority = uxPriority;
    4538:	ea 81       	ldd	r30, Y+2	; 0x02
    453a:	fb 81       	ldd	r31, Y+3	; 0x03
    453c:	8e 81       	ldd	r24, Y+6	; 0x06
    453e:	86 8b       	std	Z+22, r24	; 0x16
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
    4540:	ea 81       	ldd	r30, Y+2	; 0x02
    4542:	fb 81       	ldd	r31, Y+3	; 0x03
    4544:	8e 81       	ldd	r24, Y+6	; 0x06
    4546:	85 a7       	std	Z+45, r24	; 0x2d
		pxTCB->uxMutexesHeld = 0;
    4548:	ea 81       	ldd	r30, Y+2	; 0x02
    454a:	fb 81       	ldd	r31, Y+3	; 0x03
    454c:	16 a6       	std	Z+46, r1	; 0x2e
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    454e:	8a 81       	ldd	r24, Y+2	; 0x02
    4550:	9b 81       	ldd	r25, Y+3	; 0x03
    4552:	02 96       	adiw	r24, 0x02	; 2
    4554:	0e 94 a6 0f 	call	0x1f4c	; 0x1f4c <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    4558:	8a 81       	ldd	r24, Y+2	; 0x02
    455a:	9b 81       	ldd	r25, Y+3	; 0x03
    455c:	0c 96       	adiw	r24, 0x0c	; 12
    455e:	0e 94 a6 0f 	call	0x1f4c	; 0x1f4c <vListInitialiseItem>

	/* Set the pxTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    4562:	ea 81       	ldd	r30, Y+2	; 0x02
    4564:	fb 81       	ldd	r31, Y+3	; 0x03
    4566:	8a 81       	ldd	r24, Y+2	; 0x02
    4568:	9b 81       	ldd	r25, Y+3	; 0x03
    456a:	91 87       	std	Z+9, r25	; 0x09
    456c:	80 87       	std	Z+8, r24	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    456e:	8e 81       	ldd	r24, Y+6	; 0x06
    4570:	28 2f       	mov	r18, r24
    4572:	30 e0       	ldi	r19, 0x00	; 0
    4574:	87 e0       	ldi	r24, 0x07	; 7
    4576:	90 e0       	ldi	r25, 0x00	; 0
    4578:	82 1b       	sub	r24, r18
    457a:	93 0b       	sbc	r25, r19
    457c:	ea 81       	ldd	r30, Y+2	; 0x02
    457e:	fb 81       	ldd	r31, Y+3	; 0x03
    4580:	95 87       	std	Z+13, r25	; 0x0d
    4582:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    4584:	ea 81       	ldd	r30, Y+2	; 0x02
    4586:	fb 81       	ldd	r31, Y+3	; 0x03
    4588:	8a 81       	ldd	r24, Y+2	; 0x02
    458a:	9b 81       	ldd	r25, Y+3	; 0x03
    458c:	93 8b       	std	Z+19, r25	; 0x13
    458e:	82 8b       	std	Z+18, r24	; 0x12
	{
		/* Initialise this task's Newlib reent structure. */
		_REENT_INIT_PTR( ( &( pxTCB->xNewLib_reent ) ) );
	}
	#endif /* configUSE_NEWLIB_REENTRANT */
}
    4590:	2a 96       	adiw	r28, 0x0a	; 10
    4592:	0f b6       	in	r0, 0x3f	; 63
    4594:	f8 94       	cli
    4596:	de bf       	out	0x3e, r29	; 62
    4598:	0f be       	out	0x3f, r0	; 63
    459a:	cd bf       	out	0x3d, r28	; 61
    459c:	cf 91       	pop	r28
    459e:	df 91       	pop	r29
    45a0:	1f 91       	pop	r17
    45a2:	0f 91       	pop	r16
    45a4:	08 95       	ret

000045a6 <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
    45a6:	df 93       	push	r29
    45a8:	cf 93       	push	r28
    45aa:	0f 92       	push	r0
    45ac:	cd b7       	in	r28, 0x3d	; 61
    45ae:	de b7       	in	r29, 0x3e	; 62
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    45b0:	19 82       	std	Y+1, r1	; 0x01
    45b2:	13 c0       	rjmp	.+38     	; 0x45da <prvInitialiseTaskLists+0x34>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    45b4:	89 81       	ldd	r24, Y+1	; 0x01
    45b6:	28 2f       	mov	r18, r24
    45b8:	30 e0       	ldi	r19, 0x00	; 0
    45ba:	c9 01       	movw	r24, r18
    45bc:	88 0f       	add	r24, r24
    45be:	99 1f       	adc	r25, r25
    45c0:	88 0f       	add	r24, r24
    45c2:	99 1f       	adc	r25, r25
    45c4:	88 0f       	add	r24, r24
    45c6:	99 1f       	adc	r25, r25
    45c8:	82 0f       	add	r24, r18
    45ca:	93 1f       	adc	r25, r19
    45cc:	8a 52       	subi	r24, 0x2A	; 42
    45ce:	99 4f       	sbci	r25, 0xF9	; 249
    45d0:	0e 94 7c 0f 	call	0x1ef8	; 0x1ef8 <vListInitialise>

static void prvInitialiseTaskLists( void )
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    45d4:	89 81       	ldd	r24, Y+1	; 0x01
    45d6:	8f 5f       	subi	r24, 0xFF	; 255
    45d8:	89 83       	std	Y+1, r24	; 0x01
    45da:	89 81       	ldd	r24, Y+1	; 0x01
    45dc:	87 30       	cpi	r24, 0x07	; 7
    45de:	50 f3       	brcs	.-44     	; 0x45b4 <prvInitialiseTaskLists+0xe>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( &xDelayedTaskList1 );
    45e0:	85 e1       	ldi	r24, 0x15	; 21
    45e2:	97 e0       	ldi	r25, 0x07	; 7
    45e4:	0e 94 7c 0f 	call	0x1ef8	; 0x1ef8 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
    45e8:	8e e1       	ldi	r24, 0x1E	; 30
    45ea:	97 e0       	ldi	r25, 0x07	; 7
    45ec:	0e 94 7c 0f 	call	0x1ef8	; 0x1ef8 <vListInitialise>
	vListInitialise( &xPendingReadyList );
    45f0:	8b e2       	ldi	r24, 0x2B	; 43
    45f2:	97 e0       	ldi	r25, 0x07	; 7
    45f4:	0e 94 7c 0f 	call	0x1ef8	; 0x1ef8 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
    45f8:	84 e3       	ldi	r24, 0x34	; 52
    45fa:	97 e0       	ldi	r25, 0x07	; 7
    45fc:	0e 94 7c 0f 	call	0x1ef8	; 0x1ef8 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    4600:	85 e1       	ldi	r24, 0x15	; 21
    4602:	97 e0       	ldi	r25, 0x07	; 7
    4604:	90 93 28 07 	sts	0x0728, r25
    4608:	80 93 27 07 	sts	0x0727, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    460c:	8e e1       	ldi	r24, 0x1E	; 30
    460e:	97 e0       	ldi	r25, 0x07	; 7
    4610:	90 93 2a 07 	sts	0x072A, r25
    4614:	80 93 29 07 	sts	0x0729, r24
}
    4618:	0f 90       	pop	r0
    461a:	cf 91       	pop	r28
    461c:	df 91       	pop	r29
    461e:	08 95       	ret

00004620 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    4620:	df 93       	push	r29
    4622:	cf 93       	push	r28
    4624:	00 d0       	rcall	.+0      	; 0x4626 <prvCheckTasksWaitingTermination+0x6>
    4626:	0f 92       	push	r0
    4628:	cd b7       	in	r28, 0x3d	; 61
    462a:	de b7       	in	r29, 0x3e	; 62
    462c:	2e c0       	rjmp	.+92     	; 0x468a <prvCheckTasksWaitingTermination+0x6a>

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
		{
			vTaskSuspendAll();
    462e:	0e 94 60 1e 	call	0x3cc0	; 0x3cc0 <vTaskSuspendAll>
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    4632:	80 91 34 07 	lds	r24, 0x0734
    4636:	1b 82       	std	Y+3, r1	; 0x03
    4638:	88 23       	and	r24, r24
    463a:	11 f4       	brne	.+4      	; 0x4640 <prvCheckTasksWaitingTermination+0x20>
    463c:	81 e0       	ldi	r24, 0x01	; 1
    463e:	8b 83       	std	Y+3, r24	; 0x03
			}
			( void ) xTaskResumeAll();
    4640:	0e 94 6c 1e 	call	0x3cd8	; 0x3cd8 <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
    4644:	8b 81       	ldd	r24, Y+3	; 0x03
    4646:	88 23       	and	r24, r24
    4648:	01 f5       	brne	.+64     	; 0x468a <prvCheckTasksWaitingTermination+0x6a>
			{
				TCB_t *pxTCB;

				taskENTER_CRITICAL();
    464a:	0f b6       	in	r0, 0x3f	; 63
    464c:	f8 94       	cli
    464e:	0f 92       	push	r0
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
    4650:	e0 91 39 07 	lds	r30, 0x0739
    4654:	f0 91 3a 07 	lds	r31, 0x073A
    4658:	86 81       	ldd	r24, Z+6	; 0x06
    465a:	97 81       	ldd	r25, Z+7	; 0x07
    465c:	9a 83       	std	Y+2, r25	; 0x02
    465e:	89 83       	std	Y+1, r24	; 0x01
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
    4660:	89 81       	ldd	r24, Y+1	; 0x01
    4662:	9a 81       	ldd	r25, Y+2	; 0x02
    4664:	02 96       	adiw	r24, 0x02	; 2
    4666:	0e 94 66 10 	call	0x20cc	; 0x20cc <uxListRemove>
					--uxCurrentNumberOfTasks;
    466a:	80 91 cc 06 	lds	r24, 0x06CC
    466e:	81 50       	subi	r24, 0x01	; 1
    4670:	80 93 cc 06 	sts	0x06CC, r24
					--uxTasksDeleted;
    4674:	80 91 cb 06 	lds	r24, 0x06CB
    4678:	81 50       	subi	r24, 0x01	; 1
    467a:	80 93 cb 06 	sts	0x06CB, r24
				}
				taskEXIT_CRITICAL();
    467e:	0f 90       	pop	r0
    4680:	0f be       	out	0x3f, r0	; 63

				prvDeleteTCB( pxTCB );
    4682:	89 81       	ldd	r24, Y+1	; 0x01
    4684:	9a 81       	ldd	r25, Y+2	; 0x02
    4686:	0e 94 dc 23 	call	0x47b8	; 0x47b8 <prvDeleteTCB>
	{
		BaseType_t xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
    468a:	80 91 cb 06 	lds	r24, 0x06CB
    468e:	88 23       	and	r24, r24
    4690:	71 f6       	brne	.-100    	; 0x462e <prvCheckTasksWaitingTermination+0xe>
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
	#endif /* vTaskDelete */
}
    4692:	0f 90       	pop	r0
    4694:	0f 90       	pop	r0
    4696:	0f 90       	pop	r0
    4698:	cf 91       	pop	r28
    469a:	df 91       	pop	r29
    469c:	08 95       	ret

0000469e <prvAddCurrentTaskToDelayedList>:
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( const TickType_t xTimeToWake )
{
    469e:	df 93       	push	r29
    46a0:	cf 93       	push	r28
    46a2:	00 d0       	rcall	.+0      	; 0x46a4 <prvAddCurrentTaskToDelayedList+0x6>
    46a4:	cd b7       	in	r28, 0x3d	; 61
    46a6:	de b7       	in	r29, 0x3e	; 62
    46a8:	9a 83       	std	Y+2, r25	; 0x02
    46aa:	89 83       	std	Y+1, r24	; 0x01
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    46ac:	e0 91 c9 06 	lds	r30, 0x06C9
    46b0:	f0 91 ca 06 	lds	r31, 0x06CA
    46b4:	89 81       	ldd	r24, Y+1	; 0x01
    46b6:	9a 81       	ldd	r25, Y+2	; 0x02
    46b8:	93 83       	std	Z+3, r25	; 0x03
    46ba:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xTickCount )
    46bc:	20 91 cd 06 	lds	r18, 0x06CD
    46c0:	30 91 ce 06 	lds	r19, 0x06CE
    46c4:	89 81       	ldd	r24, Y+1	; 0x01
    46c6:	9a 81       	ldd	r25, Y+2	; 0x02
    46c8:	82 17       	cp	r24, r18
    46ca:	93 07       	cpc	r25, r19
    46cc:	70 f4       	brcc	.+28     	; 0x46ea <prvAddCurrentTaskToDelayedList+0x4c>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
    46ce:	80 91 29 07 	lds	r24, 0x0729
    46d2:	90 91 2a 07 	lds	r25, 0x072A
    46d6:	20 91 c9 06 	lds	r18, 0x06C9
    46da:	30 91 ca 06 	lds	r19, 0x06CA
    46de:	2e 5f       	subi	r18, 0xFE	; 254
    46e0:	3f 4f       	sbci	r19, 0xFF	; 255
    46e2:	b9 01       	movw	r22, r18
    46e4:	0e 94 fa 0f 	call	0x1ff4	; 0x1ff4 <vListInsert>
    46e8:	1e c0       	rjmp	.+60     	; 0x4726 <prvAddCurrentTaskToDelayedList+0x88>
	}
	else
	{
		/* The wake time has not overflowed, so the current block list is used. */
		vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
    46ea:	40 91 27 07 	lds	r20, 0x0727
    46ee:	50 91 28 07 	lds	r21, 0x0728
    46f2:	80 91 c9 06 	lds	r24, 0x06C9
    46f6:	90 91 ca 06 	lds	r25, 0x06CA
    46fa:	9c 01       	movw	r18, r24
    46fc:	2e 5f       	subi	r18, 0xFE	; 254
    46fe:	3f 4f       	sbci	r19, 0xFF	; 255
    4700:	ca 01       	movw	r24, r20
    4702:	b9 01       	movw	r22, r18
    4704:	0e 94 fa 0f 	call	0x1ff4	; 0x1ff4 <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
    4708:	20 91 eb 01 	lds	r18, 0x01EB
    470c:	30 91 ec 01 	lds	r19, 0x01EC
    4710:	89 81       	ldd	r24, Y+1	; 0x01
    4712:	9a 81       	ldd	r25, Y+2	; 0x02
    4714:	82 17       	cp	r24, r18
    4716:	93 07       	cpc	r25, r19
    4718:	30 f4       	brcc	.+12     	; 0x4726 <prvAddCurrentTaskToDelayedList+0x88>
		{
			xNextTaskUnblockTime = xTimeToWake;
    471a:	89 81       	ldd	r24, Y+1	; 0x01
    471c:	9a 81       	ldd	r25, Y+2	; 0x02
    471e:	90 93 ec 01 	sts	0x01EC, r25
    4722:	80 93 eb 01 	sts	0x01EB, r24
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
}
    4726:	0f 90       	pop	r0
    4728:	0f 90       	pop	r0
    472a:	cf 91       	pop	r28
    472c:	df 91       	pop	r29
    472e:	08 95       	ret

00004730 <prvAllocateTCBAndStack>:
/*-----------------------------------------------------------*/

static TCB_t *prvAllocateTCBAndStack( const uint16_t usStackDepth, StackType_t * const puxStackBuffer )
{
    4730:	df 93       	push	r29
    4732:	cf 93       	push	r28
    4734:	cd b7       	in	r28, 0x3d	; 61
    4736:	de b7       	in	r29, 0x3e	; 62
    4738:	28 97       	sbiw	r28, 0x08	; 8
    473a:	0f b6       	in	r0, 0x3f	; 63
    473c:	f8 94       	cli
    473e:	de bf       	out	0x3e, r29	; 62
    4740:	0f be       	out	0x3f, r0	; 63
    4742:	cd bf       	out	0x3d, r28	; 61
    4744:	9c 83       	std	Y+4, r25	; 0x04
    4746:	8b 83       	std	Y+3, r24	; 0x03
    4748:	7e 83       	std	Y+6, r23	; 0x06
    474a:	6d 83       	std	Y+5, r22	; 0x05
TCB_t *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
    474c:	8f e2       	ldi	r24, 0x2F	; 47
    474e:	90 e0       	ldi	r25, 0x00	; 0
    4750:	0e 94 2e 0e 	call	0x1c5c	; 0x1c5c <pvPortMalloc>
    4754:	9a 83       	std	Y+2, r25	; 0x02
    4756:	89 83       	std	Y+1, r24	; 0x01

	if( pxNewTCB != NULL )
    4758:	89 81       	ldd	r24, Y+1	; 0x01
    475a:	9a 81       	ldd	r25, Y+2	; 0x02
    475c:	00 97       	sbiw	r24, 0x00	; 0
    475e:	09 f1       	breq	.+66     	; 0x47a2 <prvAllocateTCBAndStack+0x72>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( StackType_t * ) pvPortMallocAligned( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ), puxStackBuffer ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    4760:	8d 81       	ldd	r24, Y+5	; 0x05
    4762:	9e 81       	ldd	r25, Y+6	; 0x06
    4764:	00 97       	sbiw	r24, 0x00	; 0
    4766:	39 f4       	brne	.+14     	; 0x4776 <prvAllocateTCBAndStack+0x46>
    4768:	8b 81       	ldd	r24, Y+3	; 0x03
    476a:	9c 81       	ldd	r25, Y+4	; 0x04
    476c:	0e 94 2e 0e 	call	0x1c5c	; 0x1c5c <pvPortMalloc>
    4770:	98 87       	std	Y+8, r25	; 0x08
    4772:	8f 83       	std	Y+7, r24	; 0x07
    4774:	04 c0       	rjmp	.+8      	; 0x477e <prvAllocateTCBAndStack+0x4e>
    4776:	8d 81       	ldd	r24, Y+5	; 0x05
    4778:	9e 81       	ldd	r25, Y+6	; 0x06
    477a:	98 87       	std	Y+8, r25	; 0x08
    477c:	8f 83       	std	Y+7, r24	; 0x07
    477e:	e9 81       	ldd	r30, Y+1	; 0x01
    4780:	fa 81       	ldd	r31, Y+2	; 0x02
    4782:	8f 81       	ldd	r24, Y+7	; 0x07
    4784:	98 85       	ldd	r25, Y+8	; 0x08
    4786:	90 8f       	std	Z+24, r25	; 0x18
    4788:	87 8b       	std	Z+23, r24	; 0x17

		if( pxNewTCB->pxStack == NULL )
    478a:	e9 81       	ldd	r30, Y+1	; 0x01
    478c:	fa 81       	ldd	r31, Y+2	; 0x02
    478e:	87 89       	ldd	r24, Z+23	; 0x17
    4790:	90 8d       	ldd	r25, Z+24	; 0x18
    4792:	00 97       	sbiw	r24, 0x00	; 0
    4794:	31 f4       	brne	.+12     	; 0x47a2 <prvAllocateTCBAndStack+0x72>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
    4796:	89 81       	ldd	r24, Y+1	; 0x01
    4798:	9a 81       	ldd	r25, Y+2	; 0x02
    479a:	0e 94 84 0e 	call	0x1d08	; 0x1d08 <vPortFree>
			pxNewTCB = NULL;
    479e:	1a 82       	std	Y+2, r1	; 0x02
    47a0:	19 82       	std	Y+1, r1	; 0x01
			}
			#endif /* ( ( configCHECK_FOR_STACK_OVERFLOW > 1 ) || ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) ) ) */
		}
	}

	return pxNewTCB;
    47a2:	89 81       	ldd	r24, Y+1	; 0x01
    47a4:	9a 81       	ldd	r25, Y+2	; 0x02
}
    47a6:	28 96       	adiw	r28, 0x08	; 8
    47a8:	0f b6       	in	r0, 0x3f	; 63
    47aa:	f8 94       	cli
    47ac:	de bf       	out	0x3e, r29	; 62
    47ae:	0f be       	out	0x3f, r0	; 63
    47b0:	cd bf       	out	0x3d, r28	; 61
    47b2:	cf 91       	pop	r28
    47b4:	df 91       	pop	r29
    47b6:	08 95       	ret

000047b8 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( TCB_t *pxTCB )
	{
    47b8:	df 93       	push	r29
    47ba:	cf 93       	push	r28
    47bc:	00 d0       	rcall	.+0      	; 0x47be <prvDeleteTCB+0x6>
    47be:	cd b7       	in	r28, 0x3d	; 61
    47c0:	de b7       	in	r29, 0x3e	; 62
    47c2:	9a 83       	std	Y+2, r25	; 0x02
    47c4:	89 83       	std	Y+1, r24	; 0x01
		#if ( configUSE_NEWLIB_REENTRANT == 1 )
		{
			_reclaim_reent( &( pxTCB->xNewLib_reent ) );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
		vPortFreeAligned( pxTCB->pxStack );
    47c6:	e9 81       	ldd	r30, Y+1	; 0x01
    47c8:	fa 81       	ldd	r31, Y+2	; 0x02
    47ca:	87 89       	ldd	r24, Z+23	; 0x17
    47cc:	90 8d       	ldd	r25, Z+24	; 0x18
    47ce:	0e 94 84 0e 	call	0x1d08	; 0x1d08 <vPortFree>
		vPortFree( pxTCB );
    47d2:	89 81       	ldd	r24, Y+1	; 0x01
    47d4:	9a 81       	ldd	r25, Y+2	; 0x02
    47d6:	0e 94 84 0e 	call	0x1d08	; 0x1d08 <vPortFree>
	}
    47da:	0f 90       	pop	r0
    47dc:	0f 90       	pop	r0
    47de:	cf 91       	pop	r28
    47e0:	df 91       	pop	r29
    47e2:	08 95       	ret

000047e4 <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
    47e4:	df 93       	push	r29
    47e6:	cf 93       	push	r28
    47e8:	00 d0       	rcall	.+0      	; 0x47ea <prvResetNextTaskUnblockTime+0x6>
    47ea:	cd b7       	in	r28, 0x3d	; 61
    47ec:	de b7       	in	r29, 0x3e	; 62
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    47ee:	e0 91 27 07 	lds	r30, 0x0727
    47f2:	f0 91 28 07 	lds	r31, 0x0728
    47f6:	80 81       	ld	r24, Z
    47f8:	88 23       	and	r24, r24
    47fa:	39 f4       	brne	.+14     	; 0x480a <prvResetNextTaskUnblockTime+0x26>
		/* The new current delayed list is empty.  Set
		xNextTaskUnblockTime to the maximum possible value so it is
		extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
    47fc:	8f ef       	ldi	r24, 0xFF	; 255
    47fe:	9f ef       	ldi	r25, 0xFF	; 255
    4800:	90 93 ec 01 	sts	0x01EC, r25
    4804:	80 93 eb 01 	sts	0x01EB, r24
    4808:	13 c0       	rjmp	.+38     	; 0x4830 <prvResetNextTaskUnblockTime+0x4c>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    480a:	e0 91 27 07 	lds	r30, 0x0727
    480e:	f0 91 28 07 	lds	r31, 0x0728
    4812:	05 80       	ldd	r0, Z+5	; 0x05
    4814:	f6 81       	ldd	r31, Z+6	; 0x06
    4816:	e0 2d       	mov	r30, r0
    4818:	86 81       	ldd	r24, Z+6	; 0x06
    481a:	97 81       	ldd	r25, Z+7	; 0x07
    481c:	9a 83       	std	Y+2, r25	; 0x02
    481e:	89 83       	std	Y+1, r24	; 0x01
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xGenericListItem ) );
    4820:	e9 81       	ldd	r30, Y+1	; 0x01
    4822:	fa 81       	ldd	r31, Y+2	; 0x02
    4824:	82 81       	ldd	r24, Z+2	; 0x02
    4826:	93 81       	ldd	r25, Z+3	; 0x03
    4828:	90 93 ec 01 	sts	0x01EC, r25
    482c:	80 93 eb 01 	sts	0x01EB, r24
	}
}
    4830:	0f 90       	pop	r0
    4832:	0f 90       	pop	r0
    4834:	cf 91       	pop	r28
    4836:	df 91       	pop	r29
    4838:	08 95       	ret

0000483a <xTaskGetCurrentTaskHandle>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )

	TaskHandle_t xTaskGetCurrentTaskHandle( void )
	{
    483a:	df 93       	push	r29
    483c:	cf 93       	push	r28
    483e:	00 d0       	rcall	.+0      	; 0x4840 <xTaskGetCurrentTaskHandle+0x6>
    4840:	cd b7       	in	r28, 0x3d	; 61
    4842:	de b7       	in	r29, 0x3e	; 62
	TaskHandle_t xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
    4844:	80 91 c9 06 	lds	r24, 0x06C9
    4848:	90 91 ca 06 	lds	r25, 0x06CA
    484c:	9a 83       	std	Y+2, r25	; 0x02
    484e:	89 83       	std	Y+1, r24	; 0x01

		return xReturn;
    4850:	89 81       	ldd	r24, Y+1	; 0x01
    4852:	9a 81       	ldd	r25, Y+2	; 0x02
	}
    4854:	0f 90       	pop	r0
    4856:	0f 90       	pop	r0
    4858:	cf 91       	pop	r28
    485a:	df 91       	pop	r29
    485c:	08 95       	ret

0000485e <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
	{
    485e:	df 93       	push	r29
    4860:	cf 93       	push	r28
    4862:	00 d0       	rcall	.+0      	; 0x4864 <vTaskPriorityInherit+0x6>
    4864:	00 d0       	rcall	.+0      	; 0x4866 <vTaskPriorityInherit+0x8>
    4866:	cd b7       	in	r28, 0x3d	; 61
    4868:	de b7       	in	r29, 0x3e	; 62
    486a:	9c 83       	std	Y+4, r25	; 0x04
    486c:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
    486e:	8b 81       	ldd	r24, Y+3	; 0x03
    4870:	9c 81       	ldd	r25, Y+4	; 0x04
    4872:	9a 83       	std	Y+2, r25	; 0x02
    4874:	89 83       	std	Y+1, r24	; 0x01

		/* If the mutex was given back by an interrupt while the queue was
		locked then the mutex holder might now be NULL. */
		if( pxMutexHolder != NULL )
    4876:	8b 81       	ldd	r24, Y+3	; 0x03
    4878:	9c 81       	ldd	r25, Y+4	; 0x04
    487a:	00 97       	sbiw	r24, 0x00	; 0
    487c:	09 f4       	brne	.+2      	; 0x4880 <vTaskPriorityInherit+0x22>
    487e:	73 c0       	rjmp	.+230    	; 0x4966 <vTaskPriorityInherit+0x108>
		{
			if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
    4880:	e9 81       	ldd	r30, Y+1	; 0x01
    4882:	fa 81       	ldd	r31, Y+2	; 0x02
    4884:	96 89       	ldd	r25, Z+22	; 0x16
    4886:	e0 91 c9 06 	lds	r30, 0x06C9
    488a:	f0 91 ca 06 	lds	r31, 0x06CA
    488e:	86 89       	ldd	r24, Z+22	; 0x16
    4890:	98 17       	cp	r25, r24
    4892:	08 f0       	brcs	.+2      	; 0x4896 <vTaskPriorityInherit+0x38>
    4894:	68 c0       	rjmp	.+208    	; 0x4966 <vTaskPriorityInherit+0x108>
			{
				/* Adjust the mutex holder state to account for its new
				priority.  Only reset the event list item value if the value is
				not	being used for anything else. */
				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
    4896:	e9 81       	ldd	r30, Y+1	; 0x01
    4898:	fa 81       	ldd	r31, Y+2	; 0x02
    489a:	84 85       	ldd	r24, Z+12	; 0x0c
    489c:	95 85       	ldd	r25, Z+13	; 0x0d
    489e:	99 23       	and	r25, r25
    48a0:	7c f0       	brlt	.+30     	; 0x48c0 <vTaskPriorityInherit+0x62>
				{
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    48a2:	e0 91 c9 06 	lds	r30, 0x06C9
    48a6:	f0 91 ca 06 	lds	r31, 0x06CA
    48aa:	86 89       	ldd	r24, Z+22	; 0x16
    48ac:	28 2f       	mov	r18, r24
    48ae:	30 e0       	ldi	r19, 0x00	; 0
    48b0:	87 e0       	ldi	r24, 0x07	; 7
    48b2:	90 e0       	ldi	r25, 0x00	; 0
    48b4:	82 1b       	sub	r24, r18
    48b6:	93 0b       	sbc	r25, r19
    48b8:	e9 81       	ldd	r30, Y+1	; 0x01
    48ba:	fa 81       	ldd	r31, Y+2	; 0x02
    48bc:	95 87       	std	Z+13, r25	; 0x0d
    48be:	84 87       	std	Z+12, r24	; 0x0c
					mtCOVERAGE_TEST_MARKER();
				}

				/* If the task being modified is in the ready state it will need to
				be moved into a new list. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
    48c0:	e9 81       	ldd	r30, Y+1	; 0x01
    48c2:	fa 81       	ldd	r31, Y+2	; 0x02
    48c4:	42 85       	ldd	r20, Z+10	; 0x0a
    48c6:	53 85       	ldd	r21, Z+11	; 0x0b
    48c8:	e9 81       	ldd	r30, Y+1	; 0x01
    48ca:	fa 81       	ldd	r31, Y+2	; 0x02
    48cc:	86 89       	ldd	r24, Z+22	; 0x16
    48ce:	28 2f       	mov	r18, r24
    48d0:	30 e0       	ldi	r19, 0x00	; 0
    48d2:	c9 01       	movw	r24, r18
    48d4:	88 0f       	add	r24, r24
    48d6:	99 1f       	adc	r25, r25
    48d8:	88 0f       	add	r24, r24
    48da:	99 1f       	adc	r25, r25
    48dc:	88 0f       	add	r24, r24
    48de:	99 1f       	adc	r25, r25
    48e0:	82 0f       	add	r24, r18
    48e2:	93 1f       	adc	r25, r19
    48e4:	8a 52       	subi	r24, 0x2A	; 42
    48e6:	99 4f       	sbci	r25, 0xF9	; 249
    48e8:	48 17       	cp	r20, r24
    48ea:	59 07       	cpc	r21, r25
    48ec:	a1 f5       	brne	.+104    	; 0x4956 <vTaskPriorityInherit+0xf8>
				{
					if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    48ee:	89 81       	ldd	r24, Y+1	; 0x01
    48f0:	9a 81       	ldd	r25, Y+2	; 0x02
    48f2:	02 96       	adiw	r24, 0x02	; 2
    48f4:	0e 94 66 10 	call	0x20cc	; 0x20cc <uxListRemove>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* Inherit the priority before being moved into the new list. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    48f8:	e0 91 c9 06 	lds	r30, 0x06C9
    48fc:	f0 91 ca 06 	lds	r31, 0x06CA
    4900:	86 89       	ldd	r24, Z+22	; 0x16
    4902:	e9 81       	ldd	r30, Y+1	; 0x01
    4904:	fa 81       	ldd	r31, Y+2	; 0x02
    4906:	86 8b       	std	Z+22, r24	; 0x16
					prvAddTaskToReadyList( pxTCB );
    4908:	e9 81       	ldd	r30, Y+1	; 0x01
    490a:	fa 81       	ldd	r31, Y+2	; 0x02
    490c:	96 89       	ldd	r25, Z+22	; 0x16
    490e:	80 91 cf 06 	lds	r24, 0x06CF
    4912:	89 17       	cp	r24, r25
    4914:	28 f4       	brcc	.+10     	; 0x4920 <vTaskPriorityInherit+0xc2>
    4916:	e9 81       	ldd	r30, Y+1	; 0x01
    4918:	fa 81       	ldd	r31, Y+2	; 0x02
    491a:	86 89       	ldd	r24, Z+22	; 0x16
    491c:	80 93 cf 06 	sts	0x06CF, r24
    4920:	e9 81       	ldd	r30, Y+1	; 0x01
    4922:	fa 81       	ldd	r31, Y+2	; 0x02
    4924:	86 89       	ldd	r24, Z+22	; 0x16
    4926:	28 2f       	mov	r18, r24
    4928:	30 e0       	ldi	r19, 0x00	; 0
    492a:	c9 01       	movw	r24, r18
    492c:	88 0f       	add	r24, r24
    492e:	99 1f       	adc	r25, r25
    4930:	88 0f       	add	r24, r24
    4932:	99 1f       	adc	r25, r25
    4934:	88 0f       	add	r24, r24
    4936:	99 1f       	adc	r25, r25
    4938:	82 0f       	add	r24, r18
    493a:	93 1f       	adc	r25, r19
    493c:	ac 01       	movw	r20, r24
    493e:	4a 52       	subi	r20, 0x2A	; 42
    4940:	59 4f       	sbci	r21, 0xF9	; 249
    4942:	89 81       	ldd	r24, Y+1	; 0x01
    4944:	9a 81       	ldd	r25, Y+2	; 0x02
    4946:	9c 01       	movw	r18, r24
    4948:	2e 5f       	subi	r18, 0xFE	; 254
    494a:	3f 4f       	sbci	r19, 0xFF	; 255
    494c:	ca 01       	movw	r24, r20
    494e:	b9 01       	movw	r22, r18
    4950:	0e 94 b6 0f 	call	0x1f6c	; 0x1f6c <vListInsertEnd>
    4954:	08 c0       	rjmp	.+16     	; 0x4966 <vTaskPriorityInherit+0x108>
				}
				else
				{
					/* Just inherit the priority. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    4956:	e0 91 c9 06 	lds	r30, 0x06C9
    495a:	f0 91 ca 06 	lds	r31, 0x06CA
    495e:	86 89       	ldd	r24, Z+22	; 0x16
    4960:	e9 81       	ldd	r30, Y+1	; 0x01
    4962:	fa 81       	ldd	r31, Y+2	; 0x02
    4964:	86 8b       	std	Z+22, r24	; 0x16
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    4966:	0f 90       	pop	r0
    4968:	0f 90       	pop	r0
    496a:	0f 90       	pop	r0
    496c:	0f 90       	pop	r0
    496e:	cf 91       	pop	r28
    4970:	df 91       	pop	r29
    4972:	08 95       	ret

00004974 <xTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
	{
    4974:	df 93       	push	r29
    4976:	cf 93       	push	r28
    4978:	00 d0       	rcall	.+0      	; 0x497a <xTaskPriorityDisinherit+0x6>
    497a:	00 d0       	rcall	.+0      	; 0x497c <xTaskPriorityDisinherit+0x8>
    497c:	0f 92       	push	r0
    497e:	cd b7       	in	r28, 0x3d	; 61
    4980:	de b7       	in	r29, 0x3e	; 62
    4982:	9d 83       	std	Y+5, r25	; 0x05
    4984:	8c 83       	std	Y+4, r24	; 0x04
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
    4986:	8c 81       	ldd	r24, Y+4	; 0x04
    4988:	9d 81       	ldd	r25, Y+5	; 0x05
    498a:	9b 83       	std	Y+3, r25	; 0x03
    498c:	8a 83       	std	Y+2, r24	; 0x02
	BaseType_t xReturn = pdFALSE;
    498e:	19 82       	std	Y+1, r1	; 0x01

		if( pxMutexHolder != NULL )
    4990:	8c 81       	ldd	r24, Y+4	; 0x04
    4992:	9d 81       	ldd	r25, Y+5	; 0x05
    4994:	00 97       	sbiw	r24, 0x00	; 0
    4996:	09 f4       	brne	.+2      	; 0x499a <xTaskPriorityDisinherit+0x26>
    4998:	56 c0       	rjmp	.+172    	; 0x4a46 <xTaskPriorityDisinherit+0xd2>
		{
			configASSERT( pxTCB->uxMutexesHeld );
			( pxTCB->uxMutexesHeld )--;
    499a:	ea 81       	ldd	r30, Y+2	; 0x02
    499c:	fb 81       	ldd	r31, Y+3	; 0x03
    499e:	86 a5       	ldd	r24, Z+46	; 0x2e
    49a0:	81 50       	subi	r24, 0x01	; 1
    49a2:	ea 81       	ldd	r30, Y+2	; 0x02
    49a4:	fb 81       	ldd	r31, Y+3	; 0x03
    49a6:	86 a7       	std	Z+46, r24	; 0x2e

			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    49a8:	ea 81       	ldd	r30, Y+2	; 0x02
    49aa:	fb 81       	ldd	r31, Y+3	; 0x03
    49ac:	96 89       	ldd	r25, Z+22	; 0x16
    49ae:	ea 81       	ldd	r30, Y+2	; 0x02
    49b0:	fb 81       	ldd	r31, Y+3	; 0x03
    49b2:	85 a5       	ldd	r24, Z+45	; 0x2d
    49b4:	98 17       	cp	r25, r24
    49b6:	09 f4       	brne	.+2      	; 0x49ba <xTaskPriorityDisinherit+0x46>
    49b8:	46 c0       	rjmp	.+140    	; 0x4a46 <xTaskPriorityDisinherit+0xd2>
			{
				/* Only disinherit if no other mutexes are held. */
				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
    49ba:	ea 81       	ldd	r30, Y+2	; 0x02
    49bc:	fb 81       	ldd	r31, Y+3	; 0x03
    49be:	86 a5       	ldd	r24, Z+46	; 0x2e
    49c0:	88 23       	and	r24, r24
    49c2:	09 f0       	breq	.+2      	; 0x49c6 <xTaskPriorityDisinherit+0x52>
    49c4:	40 c0       	rjmp	.+128    	; 0x4a46 <xTaskPriorityDisinherit+0xd2>
				{
					/* The holding task must be the running task to be able to give
					the mutex back.  Remove the holding task from the ready list. */
					if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    49c6:	8a 81       	ldd	r24, Y+2	; 0x02
    49c8:	9b 81       	ldd	r25, Y+3	; 0x03
    49ca:	02 96       	adiw	r24, 0x02	; 2
    49cc:	0e 94 66 10 	call	0x20cc	; 0x20cc <uxListRemove>
					}

					/* Disinherit the priority before adding the task into the new
					ready list. */
					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
					pxTCB->uxPriority = pxTCB->uxBasePriority;
    49d0:	ea 81       	ldd	r30, Y+2	; 0x02
    49d2:	fb 81       	ldd	r31, Y+3	; 0x03
    49d4:	85 a5       	ldd	r24, Z+45	; 0x2d
    49d6:	ea 81       	ldd	r30, Y+2	; 0x02
    49d8:	fb 81       	ldd	r31, Y+3	; 0x03
    49da:	86 8b       	std	Z+22, r24	; 0x16

					/* Reset the event list item value.  It cannot be in use for
					any other purpose if this task is running, and it must be
					running to give back the mutex. */
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    49dc:	ea 81       	ldd	r30, Y+2	; 0x02
    49de:	fb 81       	ldd	r31, Y+3	; 0x03
    49e0:	86 89       	ldd	r24, Z+22	; 0x16
    49e2:	28 2f       	mov	r18, r24
    49e4:	30 e0       	ldi	r19, 0x00	; 0
    49e6:	87 e0       	ldi	r24, 0x07	; 7
    49e8:	90 e0       	ldi	r25, 0x00	; 0
    49ea:	82 1b       	sub	r24, r18
    49ec:	93 0b       	sbc	r25, r19
    49ee:	ea 81       	ldd	r30, Y+2	; 0x02
    49f0:	fb 81       	ldd	r31, Y+3	; 0x03
    49f2:	95 87       	std	Z+13, r25	; 0x0d
    49f4:	84 87       	std	Z+12, r24	; 0x0c
					prvAddTaskToReadyList( pxTCB );
    49f6:	ea 81       	ldd	r30, Y+2	; 0x02
    49f8:	fb 81       	ldd	r31, Y+3	; 0x03
    49fa:	96 89       	ldd	r25, Z+22	; 0x16
    49fc:	80 91 cf 06 	lds	r24, 0x06CF
    4a00:	89 17       	cp	r24, r25
    4a02:	28 f4       	brcc	.+10     	; 0x4a0e <xTaskPriorityDisinherit+0x9a>
    4a04:	ea 81       	ldd	r30, Y+2	; 0x02
    4a06:	fb 81       	ldd	r31, Y+3	; 0x03
    4a08:	86 89       	ldd	r24, Z+22	; 0x16
    4a0a:	80 93 cf 06 	sts	0x06CF, r24
    4a0e:	ea 81       	ldd	r30, Y+2	; 0x02
    4a10:	fb 81       	ldd	r31, Y+3	; 0x03
    4a12:	86 89       	ldd	r24, Z+22	; 0x16
    4a14:	28 2f       	mov	r18, r24
    4a16:	30 e0       	ldi	r19, 0x00	; 0
    4a18:	c9 01       	movw	r24, r18
    4a1a:	88 0f       	add	r24, r24
    4a1c:	99 1f       	adc	r25, r25
    4a1e:	88 0f       	add	r24, r24
    4a20:	99 1f       	adc	r25, r25
    4a22:	88 0f       	add	r24, r24
    4a24:	99 1f       	adc	r25, r25
    4a26:	82 0f       	add	r24, r18
    4a28:	93 1f       	adc	r25, r19
    4a2a:	ac 01       	movw	r20, r24
    4a2c:	4a 52       	subi	r20, 0x2A	; 42
    4a2e:	59 4f       	sbci	r21, 0xF9	; 249
    4a30:	8a 81       	ldd	r24, Y+2	; 0x02
    4a32:	9b 81       	ldd	r25, Y+3	; 0x03
    4a34:	9c 01       	movw	r18, r24
    4a36:	2e 5f       	subi	r18, 0xFE	; 254
    4a38:	3f 4f       	sbci	r19, 0xFF	; 255
    4a3a:	ca 01       	movw	r24, r20
    4a3c:	b9 01       	movw	r22, r18
    4a3e:	0e 94 b6 0f 	call	0x1f6c	; 0x1f6c <vListInsertEnd>

					/* Return true to indicate that a context switch is required.
					This is only actually required in the corner case whereby
					multiple mutexes were held and the mutexes were given back
					in an order different to that in which they were taken. */
					xReturn = pdTRUE;
    4a42:	81 e0       	ldi	r24, 0x01	; 1
    4a44:	89 83       	std	Y+1, r24	; 0x01
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
    4a46:	89 81       	ldd	r24, Y+1	; 0x01
	}
    4a48:	0f 90       	pop	r0
    4a4a:	0f 90       	pop	r0
    4a4c:	0f 90       	pop	r0
    4a4e:	0f 90       	pop	r0
    4a50:	0f 90       	pop	r0
    4a52:	cf 91       	pop	r28
    4a54:	df 91       	pop	r29
    4a56:	08 95       	ret

00004a58 <uxTaskResetEventItemValue>:

#endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS == 1 ) ) */
/*-----------------------------------------------------------*/

TickType_t uxTaskResetEventItemValue( void )
{
    4a58:	df 93       	push	r29
    4a5a:	cf 93       	push	r28
    4a5c:	00 d0       	rcall	.+0      	; 0x4a5e <uxTaskResetEventItemValue+0x6>
    4a5e:	cd b7       	in	r28, 0x3d	; 61
    4a60:	de b7       	in	r29, 0x3e	; 62
TickType_t uxReturn;

	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
    4a62:	e0 91 c9 06 	lds	r30, 0x06C9
    4a66:	f0 91 ca 06 	lds	r31, 0x06CA
    4a6a:	84 85       	ldd	r24, Z+12	; 0x0c
    4a6c:	95 85       	ldd	r25, Z+13	; 0x0d
    4a6e:	9a 83       	std	Y+2, r25	; 0x02
    4a70:	89 83       	std	Y+1, r24	; 0x01

	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    4a72:	a0 91 c9 06 	lds	r26, 0x06C9
    4a76:	b0 91 ca 06 	lds	r27, 0x06CA
    4a7a:	e0 91 c9 06 	lds	r30, 0x06C9
    4a7e:	f0 91 ca 06 	lds	r31, 0x06CA
    4a82:	86 89       	ldd	r24, Z+22	; 0x16
    4a84:	28 2f       	mov	r18, r24
    4a86:	30 e0       	ldi	r19, 0x00	; 0
    4a88:	87 e0       	ldi	r24, 0x07	; 7
    4a8a:	90 e0       	ldi	r25, 0x00	; 0
    4a8c:	82 1b       	sub	r24, r18
    4a8e:	93 0b       	sbc	r25, r19
    4a90:	1d 96       	adiw	r26, 0x0d	; 13
    4a92:	9c 93       	st	X, r25
    4a94:	8e 93       	st	-X, r24
    4a96:	1c 97       	sbiw	r26, 0x0c	; 12

	return uxReturn;
    4a98:	89 81       	ldd	r24, Y+1	; 0x01
    4a9a:	9a 81       	ldd	r25, Y+2	; 0x02
}
    4a9c:	0f 90       	pop	r0
    4a9e:	0f 90       	pop	r0
    4aa0:	cf 91       	pop	r28
    4aa2:	df 91       	pop	r29
    4aa4:	08 95       	ret

00004aa6 <pvTaskIncrementMutexHeldCount>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void *pvTaskIncrementMutexHeldCount( void )
	{
    4aa6:	df 93       	push	r29
    4aa8:	cf 93       	push	r28
    4aaa:	cd b7       	in	r28, 0x3d	; 61
    4aac:	de b7       	in	r29, 0x3e	; 62
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
    4aae:	80 91 c9 06 	lds	r24, 0x06C9
    4ab2:	90 91 ca 06 	lds	r25, 0x06CA
    4ab6:	00 97       	sbiw	r24, 0x00	; 0
    4ab8:	39 f0       	breq	.+14     	; 0x4ac8 <pvTaskIncrementMutexHeldCount+0x22>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
    4aba:	e0 91 c9 06 	lds	r30, 0x06C9
    4abe:	f0 91 ca 06 	lds	r31, 0x06CA
    4ac2:	86 a5       	ldd	r24, Z+46	; 0x2e
    4ac4:	8f 5f       	subi	r24, 0xFF	; 255
    4ac6:	86 a7       	std	Z+46, r24	; 0x2e
		}

		return pxCurrentTCB;
    4ac8:	80 91 c9 06 	lds	r24, 0x06C9
    4acc:	90 91 ca 06 	lds	r25, 0x06CA
	}
    4ad0:	cf 91       	pop	r28
    4ad2:	df 91       	pop	r29
    4ad4:	08 95       	ret

00004ad6 <ADC_Init>:
 * Created: 7/11/2021 2:12:14 PM
 *  Author: MahmoudH
 */ 
#include "ADC.h"

void ADC_Init(void){
    4ad6:	df 93       	push	r29
    4ad8:	cf 93       	push	r28
    4ada:	cd b7       	in	r28, 0x3d	; 61
    4adc:	de b7       	in	r29, 0x3e	; 62
	ADC_SelectR->Vref = ADC_VREF_VCC_INT;
    4ade:	e7 e2       	ldi	r30, 0x27	; 39
    4ae0:	f0 e0       	ldi	r31, 0x00	; 0
    4ae2:	80 81       	ld	r24, Z
    4ae4:	8f 73       	andi	r24, 0x3F	; 63
    4ae6:	80 64       	ori	r24, 0x40	; 64
    4ae8:	80 83       	st	Z, r24
	ADC_CtrlStatusR->prescalar = ADC_PRESC_128;
    4aea:	e6 e2       	ldi	r30, 0x26	; 38
    4aec:	f0 e0       	ldi	r31, 0x00	; 0
    4aee:	80 81       	ld	r24, Z
    4af0:	87 60       	ori	r24, 0x07	; 7
    4af2:	80 83       	st	Z, r24
	ADC_CtrlStatusR->enable = 1;
    4af4:	e6 e2       	ldi	r30, 0x26	; 38
    4af6:	f0 e0       	ldi	r31, 0x00	; 0
    4af8:	80 81       	ld	r24, Z
    4afa:	80 68       	ori	r24, 0x80	; 128
    4afc:	80 83       	st	Z, r24
}
    4afe:	cf 91       	pop	r28
    4b00:	df 91       	pop	r29
    4b02:	08 95       	ret

00004b04 <ADC_Read>:
u16 ADC_Read(ADC_Channel channel){
    4b04:	df 93       	push	r29
    4b06:	cf 93       	push	r28
    4b08:	0f 92       	push	r0
    4b0a:	cd b7       	in	r28, 0x3d	; 61
    4b0c:	de b7       	in	r29, 0x3e	; 62
    4b0e:	89 83       	std	Y+1, r24	; 0x01
	ADC_SelectR->channel = channel;
    4b10:	e7 e2       	ldi	r30, 0x27	; 39
    4b12:	f0 e0       	ldi	r31, 0x00	; 0
    4b14:	89 81       	ldd	r24, Y+1	; 0x01
    4b16:	8f 71       	andi	r24, 0x1F	; 31
    4b18:	98 2f       	mov	r25, r24
    4b1a:	9f 71       	andi	r25, 0x1F	; 31
    4b1c:	80 81       	ld	r24, Z
    4b1e:	80 7e       	andi	r24, 0xE0	; 224
    4b20:	89 2b       	or	r24, r25
    4b22:	80 83       	st	Z, r24
	ADC_CtrlStatusR->start_conv = 1;
    4b24:	e6 e2       	ldi	r30, 0x26	; 38
    4b26:	f0 e0       	ldi	r31, 0x00	; 0
    4b28:	80 81       	ld	r24, Z
    4b2a:	80 64       	ori	r24, 0x40	; 64
    4b2c:	80 83       	st	Z, r24
	while(ADC_CtrlStatusR->start_conv);
    4b2e:	e6 e2       	ldi	r30, 0x26	; 38
    4b30:	f0 e0       	ldi	r31, 0x00	; 0
    4b32:	80 81       	ld	r24, Z
    4b34:	80 74       	andi	r24, 0x40	; 64
    4b36:	88 23       	and	r24, r24
    4b38:	d1 f7       	brne	.-12     	; 0x4b2e <ADC_Read+0x2a>
	return ADC_Data;
    4b3a:	e4 e2       	ldi	r30, 0x24	; 36
    4b3c:	f0 e0       	ldi	r31, 0x00	; 0
    4b3e:	80 81       	ld	r24, Z
    4b40:	91 81       	ldd	r25, Z+1	; 0x01
}
    4b42:	0f 90       	pop	r0
    4b44:	cf 91       	pop	r28
    4b46:	df 91       	pop	r29
    4b48:	08 95       	ret

00004b4a <Led_Init>:
 */ 
#include "BasicIO.h"
#include "bit_handle.h"

/* Leds */
void Led_Init(LED led){
    4b4a:	df 93       	push	r29
    4b4c:	cf 93       	push	r28
    4b4e:	0f 92       	push	r0
    4b50:	cd b7       	in	r28, 0x3d	; 61
    4b52:	de b7       	in	r29, 0x3e	; 62
    4b54:	89 83       	std	Y+1, r24	; 0x01
	setBit(LEDS_DDR,led);	/* Out */
    4b56:	aa e3       	ldi	r26, 0x3A	; 58
    4b58:	b0 e0       	ldi	r27, 0x00	; 0
    4b5a:	ea e3       	ldi	r30, 0x3A	; 58
    4b5c:	f0 e0       	ldi	r31, 0x00	; 0
    4b5e:	80 81       	ld	r24, Z
    4b60:	48 2f       	mov	r20, r24
    4b62:	89 81       	ldd	r24, Y+1	; 0x01
    4b64:	28 2f       	mov	r18, r24
    4b66:	30 e0       	ldi	r19, 0x00	; 0
    4b68:	81 e0       	ldi	r24, 0x01	; 1
    4b6a:	90 e0       	ldi	r25, 0x00	; 0
    4b6c:	02 c0       	rjmp	.+4      	; 0x4b72 <Led_Init+0x28>
    4b6e:	88 0f       	add	r24, r24
    4b70:	99 1f       	adc	r25, r25
    4b72:	2a 95       	dec	r18
    4b74:	e2 f7       	brpl	.-8      	; 0x4b6e <Led_Init+0x24>
    4b76:	84 2b       	or	r24, r20
    4b78:	8c 93       	st	X, r24
	Led_Off(led);			/* Default Off */
    4b7a:	89 81       	ldd	r24, Y+1	; 0x01
    4b7c:	0e 94 e1 25 	call	0x4bc2	; 0x4bc2 <Led_Off>
}
    4b80:	0f 90       	pop	r0
    4b82:	cf 91       	pop	r28
    4b84:	df 91       	pop	r29
    4b86:	08 95       	ret

00004b88 <Led_On>:
void Led_On(LED led){
    4b88:	df 93       	push	r29
    4b8a:	cf 93       	push	r28
    4b8c:	0f 92       	push	r0
    4b8e:	cd b7       	in	r28, 0x3d	; 61
    4b90:	de b7       	in	r29, 0x3e	; 62
    4b92:	89 83       	std	Y+1, r24	; 0x01
	setBit(LEDS_PORT,led);
    4b94:	ab e3       	ldi	r26, 0x3B	; 59
    4b96:	b0 e0       	ldi	r27, 0x00	; 0
    4b98:	eb e3       	ldi	r30, 0x3B	; 59
    4b9a:	f0 e0       	ldi	r31, 0x00	; 0
    4b9c:	80 81       	ld	r24, Z
    4b9e:	48 2f       	mov	r20, r24
    4ba0:	89 81       	ldd	r24, Y+1	; 0x01
    4ba2:	28 2f       	mov	r18, r24
    4ba4:	30 e0       	ldi	r19, 0x00	; 0
    4ba6:	81 e0       	ldi	r24, 0x01	; 1
    4ba8:	90 e0       	ldi	r25, 0x00	; 0
    4baa:	02 2e       	mov	r0, r18
    4bac:	02 c0       	rjmp	.+4      	; 0x4bb2 <Led_On+0x2a>
    4bae:	88 0f       	add	r24, r24
    4bb0:	99 1f       	adc	r25, r25
    4bb2:	0a 94       	dec	r0
    4bb4:	e2 f7       	brpl	.-8      	; 0x4bae <Led_On+0x26>
    4bb6:	84 2b       	or	r24, r20
    4bb8:	8c 93       	st	X, r24
}
    4bba:	0f 90       	pop	r0
    4bbc:	cf 91       	pop	r28
    4bbe:	df 91       	pop	r29
    4bc0:	08 95       	ret

00004bc2 <Led_Off>:
void Led_Off(LED led){
    4bc2:	df 93       	push	r29
    4bc4:	cf 93       	push	r28
    4bc6:	0f 92       	push	r0
    4bc8:	cd b7       	in	r28, 0x3d	; 61
    4bca:	de b7       	in	r29, 0x3e	; 62
    4bcc:	89 83       	std	Y+1, r24	; 0x01
	clearBit(LEDS_PORT,led);
    4bce:	ab e3       	ldi	r26, 0x3B	; 59
    4bd0:	b0 e0       	ldi	r27, 0x00	; 0
    4bd2:	eb e3       	ldi	r30, 0x3B	; 59
    4bd4:	f0 e0       	ldi	r31, 0x00	; 0
    4bd6:	80 81       	ld	r24, Z
    4bd8:	48 2f       	mov	r20, r24
    4bda:	89 81       	ldd	r24, Y+1	; 0x01
    4bdc:	28 2f       	mov	r18, r24
    4bde:	30 e0       	ldi	r19, 0x00	; 0
    4be0:	81 e0       	ldi	r24, 0x01	; 1
    4be2:	90 e0       	ldi	r25, 0x00	; 0
    4be4:	02 2e       	mov	r0, r18
    4be6:	02 c0       	rjmp	.+4      	; 0x4bec <Led_Off+0x2a>
    4be8:	88 0f       	add	r24, r24
    4bea:	99 1f       	adc	r25, r25
    4bec:	0a 94       	dec	r0
    4bee:	e2 f7       	brpl	.-8      	; 0x4be8 <Led_Off+0x26>
    4bf0:	80 95       	com	r24
    4bf2:	84 23       	and	r24, r20
    4bf4:	8c 93       	st	X, r24
}
    4bf6:	0f 90       	pop	r0
    4bf8:	cf 91       	pop	r28
    4bfa:	df 91       	pop	r29
    4bfc:	08 95       	ret

00004bfe <Led_Toggle>:
void Led_Toggle(LED led){
    4bfe:	df 93       	push	r29
    4c00:	cf 93       	push	r28
    4c02:	0f 92       	push	r0
    4c04:	cd b7       	in	r28, 0x3d	; 61
    4c06:	de b7       	in	r29, 0x3e	; 62
    4c08:	89 83       	std	Y+1, r24	; 0x01
	toggleBit(LEDS_PORT,led);
    4c0a:	ab e3       	ldi	r26, 0x3B	; 59
    4c0c:	b0 e0       	ldi	r27, 0x00	; 0
    4c0e:	eb e3       	ldi	r30, 0x3B	; 59
    4c10:	f0 e0       	ldi	r31, 0x00	; 0
    4c12:	80 81       	ld	r24, Z
    4c14:	48 2f       	mov	r20, r24
    4c16:	89 81       	ldd	r24, Y+1	; 0x01
    4c18:	28 2f       	mov	r18, r24
    4c1a:	30 e0       	ldi	r19, 0x00	; 0
    4c1c:	81 e0       	ldi	r24, 0x01	; 1
    4c1e:	90 e0       	ldi	r25, 0x00	; 0
    4c20:	02 2e       	mov	r0, r18
    4c22:	02 c0       	rjmp	.+4      	; 0x4c28 <Led_Toggle+0x2a>
    4c24:	88 0f       	add	r24, r24
    4c26:	99 1f       	adc	r25, r25
    4c28:	0a 94       	dec	r0
    4c2a:	e2 f7       	brpl	.-8      	; 0x4c24 <Led_Toggle+0x26>
    4c2c:	84 27       	eor	r24, r20
    4c2e:	8c 93       	st	X, r24
}
    4c30:	0f 90       	pop	r0
    4c32:	cf 91       	pop	r28
    4c34:	df 91       	pop	r29
    4c36:	08 95       	ret

00004c38 <Leds_Init>:

void Leds_Init(u8 ledMask){
    4c38:	df 93       	push	r29
    4c3a:	cf 93       	push	r28
    4c3c:	0f 92       	push	r0
    4c3e:	cd b7       	in	r28, 0x3d	; 61
    4c40:	de b7       	in	r29, 0x3e	; 62
    4c42:	89 83       	std	Y+1, r24	; 0x01
	LEDS_DDR |= ledMask;	/* Out */
    4c44:	aa e3       	ldi	r26, 0x3A	; 58
    4c46:	b0 e0       	ldi	r27, 0x00	; 0
    4c48:	ea e3       	ldi	r30, 0x3A	; 58
    4c4a:	f0 e0       	ldi	r31, 0x00	; 0
    4c4c:	90 81       	ld	r25, Z
    4c4e:	89 81       	ldd	r24, Y+1	; 0x01
    4c50:	89 2b       	or	r24, r25
    4c52:	8c 93       	st	X, r24
	Leds_Off(ledMask);			/* Default Off */	
    4c54:	89 81       	ldd	r24, Y+1	; 0x01
    4c56:	0e 94 43 26 	call	0x4c86	; 0x4c86 <Leds_Off>
}
    4c5a:	0f 90       	pop	r0
    4c5c:	cf 91       	pop	r28
    4c5e:	df 91       	pop	r29
    4c60:	08 95       	ret

00004c62 <Leds_On>:
void Leds_On(u8 ledMask){
    4c62:	df 93       	push	r29
    4c64:	cf 93       	push	r28
    4c66:	0f 92       	push	r0
    4c68:	cd b7       	in	r28, 0x3d	; 61
    4c6a:	de b7       	in	r29, 0x3e	; 62
    4c6c:	89 83       	std	Y+1, r24	; 0x01
	LEDS_PORT |= ledMask;
    4c6e:	ab e3       	ldi	r26, 0x3B	; 59
    4c70:	b0 e0       	ldi	r27, 0x00	; 0
    4c72:	eb e3       	ldi	r30, 0x3B	; 59
    4c74:	f0 e0       	ldi	r31, 0x00	; 0
    4c76:	90 81       	ld	r25, Z
    4c78:	89 81       	ldd	r24, Y+1	; 0x01
    4c7a:	89 2b       	or	r24, r25
    4c7c:	8c 93       	st	X, r24
}
    4c7e:	0f 90       	pop	r0
    4c80:	cf 91       	pop	r28
    4c82:	df 91       	pop	r29
    4c84:	08 95       	ret

00004c86 <Leds_Off>:
void Leds_Off(u8 ledMask){
    4c86:	df 93       	push	r29
    4c88:	cf 93       	push	r28
    4c8a:	0f 92       	push	r0
    4c8c:	cd b7       	in	r28, 0x3d	; 61
    4c8e:	de b7       	in	r29, 0x3e	; 62
    4c90:	89 83       	std	Y+1, r24	; 0x01
	LEDS_PORT &= ~ledMask;
    4c92:	ab e3       	ldi	r26, 0x3B	; 59
    4c94:	b0 e0       	ldi	r27, 0x00	; 0
    4c96:	eb e3       	ldi	r30, 0x3B	; 59
    4c98:	f0 e0       	ldi	r31, 0x00	; 0
    4c9a:	80 81       	ld	r24, Z
    4c9c:	98 2f       	mov	r25, r24
    4c9e:	89 81       	ldd	r24, Y+1	; 0x01
    4ca0:	80 95       	com	r24
    4ca2:	89 23       	and	r24, r25
    4ca4:	8c 93       	st	X, r24
}
    4ca6:	0f 90       	pop	r0
    4ca8:	cf 91       	pop	r28
    4caa:	df 91       	pop	r29
    4cac:	08 95       	ret

00004cae <Leds_Toggle>:
void Leds_Toggle(u8 ledMask){
    4cae:	df 93       	push	r29
    4cb0:	cf 93       	push	r28
    4cb2:	0f 92       	push	r0
    4cb4:	cd b7       	in	r28, 0x3d	; 61
    4cb6:	de b7       	in	r29, 0x3e	; 62
    4cb8:	89 83       	std	Y+1, r24	; 0x01
	LEDS_PORT ^= ledMask;
    4cba:	ab e3       	ldi	r26, 0x3B	; 59
    4cbc:	b0 e0       	ldi	r27, 0x00	; 0
    4cbe:	eb e3       	ldi	r30, 0x3B	; 59
    4cc0:	f0 e0       	ldi	r31, 0x00	; 0
    4cc2:	90 81       	ld	r25, Z
    4cc4:	89 81       	ldd	r24, Y+1	; 0x01
    4cc6:	89 27       	eor	r24, r25
    4cc8:	8c 93       	st	X, r24
}
    4cca:	0f 90       	pop	r0
    4ccc:	cf 91       	pop	r28
    4cce:	df 91       	pop	r29
    4cd0:	08 95       	ret

00004cd2 <Leds_AllInit>:

void Leds_AllInit(void){
    4cd2:	df 93       	push	r29
    4cd4:	cf 93       	push	r28
    4cd6:	0f 92       	push	r0
    4cd8:	cd b7       	in	r28, 0x3d	; 61
    4cda:	de b7       	in	r29, 0x3e	; 62
	LEDS_DDR |= LEDS_MSK; /* Out */
    4cdc:	ea e3       	ldi	r30, 0x3A	; 58
    4cde:	f0 e0       	ldi	r31, 0x00	; 0
    4ce0:	80 81       	ld	r24, Z
    4ce2:	ea e3       	ldi	r30, 0x3A	; 58
    4ce4:	f0 e0       	ldi	r31, 0x00	; 0
    4ce6:	8f ef       	ldi	r24, 0xFF	; 255
    4ce8:	80 83       	st	Z, r24
	Leds_AllOff();
    4cea:	0e 94 8b 26 	call	0x4d16	; 0x4d16 <Leds_AllOff>
}
    4cee:	0f 90       	pop	r0
    4cf0:	cf 91       	pop	r28
    4cf2:	df 91       	pop	r29
    4cf4:	08 95       	ret

00004cf6 <Leds_AllOn>:
void Leds_AllOn(void){
    4cf6:	df 93       	push	r29
    4cf8:	cf 93       	push	r28
    4cfa:	0f 92       	push	r0
    4cfc:	cd b7       	in	r28, 0x3d	; 61
    4cfe:	de b7       	in	r29, 0x3e	; 62
	LEDS_PORT |= LEDS_MSK;
    4d00:	eb e3       	ldi	r30, 0x3B	; 59
    4d02:	f0 e0       	ldi	r31, 0x00	; 0
    4d04:	80 81       	ld	r24, Z
    4d06:	eb e3       	ldi	r30, 0x3B	; 59
    4d08:	f0 e0       	ldi	r31, 0x00	; 0
    4d0a:	8f ef       	ldi	r24, 0xFF	; 255
    4d0c:	80 83       	st	Z, r24
}
    4d0e:	0f 90       	pop	r0
    4d10:	cf 91       	pop	r28
    4d12:	df 91       	pop	r29
    4d14:	08 95       	ret

00004d16 <Leds_AllOff>:
void Leds_AllOff(void){
    4d16:	df 93       	push	r29
    4d18:	cf 93       	push	r28
    4d1a:	0f 92       	push	r0
    4d1c:	cd b7       	in	r28, 0x3d	; 61
    4d1e:	de b7       	in	r29, 0x3e	; 62
	LEDS_PORT &= ~LEDS_MSK;
    4d20:	eb e3       	ldi	r30, 0x3B	; 59
    4d22:	f0 e0       	ldi	r31, 0x00	; 0
    4d24:	80 81       	ld	r24, Z
    4d26:	eb e3       	ldi	r30, 0x3B	; 59
    4d28:	f0 e0       	ldi	r31, 0x00	; 0
    4d2a:	10 82       	st	Z, r1
}
    4d2c:	0f 90       	pop	r0
    4d2e:	cf 91       	pop	r28
    4d30:	df 91       	pop	r29
    4d32:	08 95       	ret

00004d34 <Leds_AllToggle>:
void Leds_AllToggle(void){
    4d34:	df 93       	push	r29
    4d36:	cf 93       	push	r28
    4d38:	cd b7       	in	r28, 0x3d	; 61
    4d3a:	de b7       	in	r29, 0x3e	; 62
	LEDS_PORT ^= LEDS_MSK;
    4d3c:	ab e3       	ldi	r26, 0x3B	; 59
    4d3e:	b0 e0       	ldi	r27, 0x00	; 0
    4d40:	eb e3       	ldi	r30, 0x3B	; 59
    4d42:	f0 e0       	ldi	r31, 0x00	; 0
    4d44:	80 81       	ld	r24, Z
    4d46:	80 95       	com	r24
    4d48:	8c 93       	st	X, r24
}
    4d4a:	cf 91       	pop	r28
    4d4c:	df 91       	pop	r29
    4d4e:	08 95       	ret

00004d50 <Btn_Init>:

/* Buttons */
void Btn_Init(Button btn){
    4d50:	df 93       	push	r29
    4d52:	cf 93       	push	r28
    4d54:	0f 92       	push	r0
    4d56:	cd b7       	in	r28, 0x3d	; 61
    4d58:	de b7       	in	r29, 0x3e	; 62
    4d5a:	89 83       	std	Y+1, r24	; 0x01
	BUTTONS_DDR  &= ~(1<<btn);	/* in */
    4d5c:	a1 e3       	ldi	r26, 0x31	; 49
    4d5e:	b0 e0       	ldi	r27, 0x00	; 0
    4d60:	e1 e3       	ldi	r30, 0x31	; 49
    4d62:	f0 e0       	ldi	r31, 0x00	; 0
    4d64:	80 81       	ld	r24, Z
    4d66:	48 2f       	mov	r20, r24
    4d68:	89 81       	ldd	r24, Y+1	; 0x01
    4d6a:	28 2f       	mov	r18, r24
    4d6c:	30 e0       	ldi	r19, 0x00	; 0
    4d6e:	81 e0       	ldi	r24, 0x01	; 1
    4d70:	90 e0       	ldi	r25, 0x00	; 0
    4d72:	02 c0       	rjmp	.+4      	; 0x4d78 <Btn_Init+0x28>
    4d74:	88 0f       	add	r24, r24
    4d76:	99 1f       	adc	r25, r25
    4d78:	2a 95       	dec	r18
    4d7a:	e2 f7       	brpl	.-8      	; 0x4d74 <Btn_Init+0x24>
    4d7c:	80 95       	com	r24
    4d7e:	84 23       	and	r24, r20
    4d80:	8c 93       	st	X, r24
	BUTTONS_PORT |=  (1<<btn);  /* Pullup */
    4d82:	a2 e3       	ldi	r26, 0x32	; 50
    4d84:	b0 e0       	ldi	r27, 0x00	; 0
    4d86:	e2 e3       	ldi	r30, 0x32	; 50
    4d88:	f0 e0       	ldi	r31, 0x00	; 0
    4d8a:	80 81       	ld	r24, Z
    4d8c:	48 2f       	mov	r20, r24
    4d8e:	89 81       	ldd	r24, Y+1	; 0x01
    4d90:	28 2f       	mov	r18, r24
    4d92:	30 e0       	ldi	r19, 0x00	; 0
    4d94:	81 e0       	ldi	r24, 0x01	; 1
    4d96:	90 e0       	ldi	r25, 0x00	; 0
    4d98:	02 2e       	mov	r0, r18
    4d9a:	02 c0       	rjmp	.+4      	; 0x4da0 <Btn_Init+0x50>
    4d9c:	88 0f       	add	r24, r24
    4d9e:	99 1f       	adc	r25, r25
    4da0:	0a 94       	dec	r0
    4da2:	e2 f7       	brpl	.-8      	; 0x4d9c <Btn_Init+0x4c>
    4da4:	84 2b       	or	r24, r20
    4da6:	8c 93       	st	X, r24
}
    4da8:	0f 90       	pop	r0
    4daa:	cf 91       	pop	r28
    4dac:	df 91       	pop	r29
    4dae:	08 95       	ret

00004db0 <Btn_IsPressed>:
Bool Btn_IsPressed(Button btn){
    4db0:	df 93       	push	r29
    4db2:	cf 93       	push	r28
    4db4:	00 d0       	rcall	.+0      	; 0x4db6 <Btn_IsPressed+0x6>
    4db6:	cd b7       	in	r28, 0x3d	; 61
    4db8:	de b7       	in	r29, 0x3e	; 62
    4dba:	89 83       	std	Y+1, r24	; 0x01
	return ( (BUTTONS_PINR&(1<<btn)) == 0 );
    4dbc:	e0 e3       	ldi	r30, 0x30	; 48
    4dbe:	f0 e0       	ldi	r31, 0x00	; 0
    4dc0:	80 81       	ld	r24, Z
    4dc2:	28 2f       	mov	r18, r24
    4dc4:	30 e0       	ldi	r19, 0x00	; 0
    4dc6:	89 81       	ldd	r24, Y+1	; 0x01
    4dc8:	88 2f       	mov	r24, r24
    4dca:	90 e0       	ldi	r25, 0x00	; 0
    4dcc:	a9 01       	movw	r20, r18
    4dce:	02 c0       	rjmp	.+4      	; 0x4dd4 <Btn_IsPressed+0x24>
    4dd0:	55 95       	asr	r21
    4dd2:	47 95       	ror	r20
    4dd4:	8a 95       	dec	r24
    4dd6:	e2 f7       	brpl	.-8      	; 0x4dd0 <Btn_IsPressed+0x20>
    4dd8:	ca 01       	movw	r24, r20
    4dda:	81 70       	andi	r24, 0x01	; 1
    4ddc:	90 70       	andi	r25, 0x00	; 0
    4dde:	1a 82       	std	Y+2, r1	; 0x02
    4de0:	00 97       	sbiw	r24, 0x00	; 0
    4de2:	11 f4       	brne	.+4      	; 0x4de8 <Btn_IsPressed+0x38>
    4de4:	51 e0       	ldi	r21, 0x01	; 1
    4de6:	5a 83       	std	Y+2, r21	; 0x02
    4de8:	8a 81       	ldd	r24, Y+2	; 0x02
}
    4dea:	0f 90       	pop	r0
    4dec:	0f 90       	pop	r0
    4dee:	cf 91       	pop	r28
    4df0:	df 91       	pop	r29
    4df2:	08 95       	ret

00004df4 <Buz_Init>:

/* Buzzer */
void Buz_Init(void){
    4df4:	df 93       	push	r29
    4df6:	cf 93       	push	r28
    4df8:	cd b7       	in	r28, 0x3d	; 61
    4dfa:	de b7       	in	r29, 0x3e	; 62
	BUZZER_DDR |= (1<<BUZZER_PIN);	/* Out */
    4dfc:	a1 e3       	ldi	r26, 0x31	; 49
    4dfe:	b0 e0       	ldi	r27, 0x00	; 0
    4e00:	e1 e3       	ldi	r30, 0x31	; 49
    4e02:	f0 e0       	ldi	r31, 0x00	; 0
    4e04:	80 81       	ld	r24, Z
    4e06:	80 68       	ori	r24, 0x80	; 128
    4e08:	8c 93       	st	X, r24
	Buz_Off();						/* Default Off */	
    4e0a:	0e 94 18 27 	call	0x4e30	; 0x4e30 <Buz_Off>
}
    4e0e:	cf 91       	pop	r28
    4e10:	df 91       	pop	r29
    4e12:	08 95       	ret

00004e14 <Buz_On>:
void Buz_On(void){
    4e14:	df 93       	push	r29
    4e16:	cf 93       	push	r28
    4e18:	cd b7       	in	r28, 0x3d	; 61
    4e1a:	de b7       	in	r29, 0x3e	; 62
	BUZZER_PORT |= (1<<BUZZER_PIN);
    4e1c:	a2 e3       	ldi	r26, 0x32	; 50
    4e1e:	b0 e0       	ldi	r27, 0x00	; 0
    4e20:	e2 e3       	ldi	r30, 0x32	; 50
    4e22:	f0 e0       	ldi	r31, 0x00	; 0
    4e24:	80 81       	ld	r24, Z
    4e26:	80 68       	ori	r24, 0x80	; 128
    4e28:	8c 93       	st	X, r24
}
    4e2a:	cf 91       	pop	r28
    4e2c:	df 91       	pop	r29
    4e2e:	08 95       	ret

00004e30 <Buz_Off>:
void Buz_Off(void){
    4e30:	df 93       	push	r29
    4e32:	cf 93       	push	r28
    4e34:	cd b7       	in	r28, 0x3d	; 61
    4e36:	de b7       	in	r29, 0x3e	; 62
	BUZZER_PORT &= ~(1<<BUZZER_PIN);
    4e38:	a2 e3       	ldi	r26, 0x32	; 50
    4e3a:	b0 e0       	ldi	r27, 0x00	; 0
    4e3c:	e2 e3       	ldi	r30, 0x32	; 50
    4e3e:	f0 e0       	ldi	r31, 0x00	; 0
    4e40:	80 81       	ld	r24, Z
    4e42:	8f 77       	andi	r24, 0x7F	; 127
    4e44:	8c 93       	st	X, r24
}
    4e46:	cf 91       	pop	r28
    4e48:	df 91       	pop	r29
    4e4a:	08 95       	ret

00004e4c <Buz_Toggle>:
void Buz_Toggle(void){
    4e4c:	df 93       	push	r29
    4e4e:	cf 93       	push	r28
    4e50:	cd b7       	in	r28, 0x3d	; 61
    4e52:	de b7       	in	r29, 0x3e	; 62
	BUZZER_PORT ^= (1<<BUZZER_PIN);
    4e54:	a2 e3       	ldi	r26, 0x32	; 50
    4e56:	b0 e0       	ldi	r27, 0x00	; 0
    4e58:	e2 e3       	ldi	r30, 0x32	; 50
    4e5a:	f0 e0       	ldi	r31, 0x00	; 0
    4e5c:	90 81       	ld	r25, Z
    4e5e:	80 e8       	ldi	r24, 0x80	; 128
    4e60:	89 27       	eor	r24, r25
    4e62:	8c 93       	st	X, r24
    4e64:	cf 91       	pop	r28
    4e66:	df 91       	pop	r29
    4e68:	08 95       	ret

00004e6a <Ext_Int_Init>:
*/
#include "Ext_Int.h"

void (*callbacks[3])(void);

void Ext_Int_Init(EXT_INT ext_int, EDGE edge,void (*pfApp)(void)){
    4e6a:	df 93       	push	r29
    4e6c:	cf 93       	push	r28
    4e6e:	00 d0       	rcall	.+0      	; 0x4e70 <Ext_Int_Init+0x6>
    4e70:	00 d0       	rcall	.+0      	; 0x4e72 <Ext_Int_Init+0x8>
    4e72:	00 d0       	rcall	.+0      	; 0x4e74 <Ext_Int_Init+0xa>
    4e74:	cd b7       	in	r28, 0x3d	; 61
    4e76:	de b7       	in	r29, 0x3e	; 62
    4e78:	89 83       	std	Y+1, r24	; 0x01
    4e7a:	6a 83       	std	Y+2, r22	; 0x02
    4e7c:	5c 83       	std	Y+4, r21	; 0x04
    4e7e:	4b 83       	std	Y+3, r20	; 0x03
	/* Configure Ext Int */
	switch (ext_int)
    4e80:	89 81       	ldd	r24, Y+1	; 0x01
    4e82:	28 2f       	mov	r18, r24
    4e84:	30 e0       	ldi	r19, 0x00	; 0
    4e86:	3e 83       	std	Y+6, r19	; 0x06
    4e88:	2d 83       	std	Y+5, r18	; 0x05
    4e8a:	8d 81       	ldd	r24, Y+5	; 0x05
    4e8c:	9e 81       	ldd	r25, Y+6	; 0x06
    4e8e:	86 30       	cpi	r24, 0x06	; 6
    4e90:	91 05       	cpc	r25, r1
    4e92:	61 f0       	breq	.+24     	; 0x4eac <Ext_Int_Init+0x42>
    4e94:	2d 81       	ldd	r18, Y+5	; 0x05
    4e96:	3e 81       	ldd	r19, Y+6	; 0x06
    4e98:	27 30       	cpi	r18, 0x07	; 7
    4e9a:	31 05       	cpc	r19, r1
    4e9c:	21 f1       	breq	.+72     	; 0x4ee6 <Ext_Int_Init+0x7c>
    4e9e:	8d 81       	ldd	r24, Y+5	; 0x05
    4ea0:	9e 81       	ldd	r25, Y+6	; 0x06
    4ea2:	85 30       	cpi	r24, 0x05	; 5
    4ea4:	91 05       	cpc	r25, r1
    4ea6:	09 f4       	brne	.+2      	; 0x4eaa <Ext_Int_Init+0x40>
    4ea8:	42 c0       	rjmp	.+132    	; 0x4f2e <Ext_Int_Init+0xc4>
    4eaa:	63 c0       	rjmp	.+198    	; 0x4f72 <Ext_Int_Init+0x108>
	{
		case EXT_INT0:
		MCUCR	&= ~0b00000011;
    4eac:	a5 e5       	ldi	r26, 0x55	; 85
    4eae:	b0 e0       	ldi	r27, 0x00	; 0
    4eb0:	e5 e5       	ldi	r30, 0x55	; 85
    4eb2:	f0 e0       	ldi	r31, 0x00	; 0
    4eb4:	80 81       	ld	r24, Z
    4eb6:	8c 7f       	andi	r24, 0xFC	; 252
    4eb8:	8c 93       	st	X, r24
		MCUCR	|=  edge;
    4eba:	a5 e5       	ldi	r26, 0x55	; 85
    4ebc:	b0 e0       	ldi	r27, 0x00	; 0
    4ebe:	e5 e5       	ldi	r30, 0x55	; 85
    4ec0:	f0 e0       	ldi	r31, 0x00	; 0
    4ec2:	90 81       	ld	r25, Z
    4ec4:	8a 81       	ldd	r24, Y+2	; 0x02
    4ec6:	89 2b       	or	r24, r25
    4ec8:	8c 93       	st	X, r24
		callbacks[0] = pfApp;
    4eca:	8b 81       	ldd	r24, Y+3	; 0x03
    4ecc:	9c 81       	ldd	r25, Y+4	; 0x04
    4ece:	90 93 4e 07 	sts	0x074E, r25
    4ed2:	80 93 4d 07 	sts	0x074D, r24
		GICR	|= (1<<INT0);
    4ed6:	ab e5       	ldi	r26, 0x5B	; 91
    4ed8:	b0 e0       	ldi	r27, 0x00	; 0
    4eda:	eb e5       	ldi	r30, 0x5B	; 91
    4edc:	f0 e0       	ldi	r31, 0x00	; 0
    4ede:	80 81       	ld	r24, Z
    4ee0:	80 64       	ori	r24, 0x40	; 64
    4ee2:	8c 93       	st	X, r24
    4ee4:	46 c0       	rjmp	.+140    	; 0x4f72 <Ext_Int_Init+0x108>
		break;
		case EXT_INT1:
		MCUCR	&= ~0b00001100;
    4ee6:	a5 e5       	ldi	r26, 0x55	; 85
    4ee8:	b0 e0       	ldi	r27, 0x00	; 0
    4eea:	e5 e5       	ldi	r30, 0x55	; 85
    4eec:	f0 e0       	ldi	r31, 0x00	; 0
    4eee:	80 81       	ld	r24, Z
    4ef0:	83 7f       	andi	r24, 0xF3	; 243
    4ef2:	8c 93       	st	X, r24
		MCUCR	|=  (edge<<2);
    4ef4:	a5 e5       	ldi	r26, 0x55	; 85
    4ef6:	b0 e0       	ldi	r27, 0x00	; 0
    4ef8:	e5 e5       	ldi	r30, 0x55	; 85
    4efa:	f0 e0       	ldi	r31, 0x00	; 0
    4efc:	80 81       	ld	r24, Z
    4efe:	28 2f       	mov	r18, r24
    4f00:	8a 81       	ldd	r24, Y+2	; 0x02
    4f02:	88 2f       	mov	r24, r24
    4f04:	90 e0       	ldi	r25, 0x00	; 0
    4f06:	88 0f       	add	r24, r24
    4f08:	99 1f       	adc	r25, r25
    4f0a:	88 0f       	add	r24, r24
    4f0c:	99 1f       	adc	r25, r25
    4f0e:	82 2b       	or	r24, r18
    4f10:	8c 93       	st	X, r24
		callbacks[1] = pfApp;
    4f12:	8b 81       	ldd	r24, Y+3	; 0x03
    4f14:	9c 81       	ldd	r25, Y+4	; 0x04
    4f16:	90 93 50 07 	sts	0x0750, r25
    4f1a:	80 93 4f 07 	sts	0x074F, r24
		GICR	|= (1<<INT1);
    4f1e:	ab e5       	ldi	r26, 0x5B	; 91
    4f20:	b0 e0       	ldi	r27, 0x00	; 0
    4f22:	eb e5       	ldi	r30, 0x5B	; 91
    4f24:	f0 e0       	ldi	r31, 0x00	; 0
    4f26:	80 81       	ld	r24, Z
    4f28:	80 68       	ori	r24, 0x80	; 128
    4f2a:	8c 93       	st	X, r24
    4f2c:	22 c0       	rjmp	.+68     	; 0x4f72 <Ext_Int_Init+0x108>
		break;
		case EXT_INT2:
		if (edge == EDGE_RISING)
    4f2e:	8a 81       	ldd	r24, Y+2	; 0x02
    4f30:	83 30       	cpi	r24, 0x03	; 3
    4f32:	41 f4       	brne	.+16     	; 0x4f44 <Ext_Int_Init+0xda>
		{
			MCUCSR |= (1<<ISC2);
    4f34:	a4 e5       	ldi	r26, 0x54	; 84
    4f36:	b0 e0       	ldi	r27, 0x00	; 0
    4f38:	e4 e5       	ldi	r30, 0x54	; 84
    4f3a:	f0 e0       	ldi	r31, 0x00	; 0
    4f3c:	80 81       	ld	r24, Z
    4f3e:	80 64       	ori	r24, 0x40	; 64
    4f40:	8c 93       	st	X, r24
    4f42:	0a c0       	rjmp	.+20     	; 0x4f58 <Ext_Int_Init+0xee>
		}else if (edge == EDGE_FALLING){
    4f44:	8a 81       	ldd	r24, Y+2	; 0x02
    4f46:	82 30       	cpi	r24, 0x02	; 2
    4f48:	a9 f4       	brne	.+42     	; 0x4f74 <Ext_Int_Init+0x10a>
			MCUCSR &= ~(1<<ISC2);			
    4f4a:	a4 e5       	ldi	r26, 0x54	; 84
    4f4c:	b0 e0       	ldi	r27, 0x00	; 0
    4f4e:	e4 e5       	ldi	r30, 0x54	; 84
    4f50:	f0 e0       	ldi	r31, 0x00	; 0
    4f52:	80 81       	ld	r24, Z
    4f54:	8f 7b       	andi	r24, 0xBF	; 191
    4f56:	8c 93       	st	X, r24
		}
		else{
			return;
		}
		callbacks[2] = pfApp;
    4f58:	8b 81       	ldd	r24, Y+3	; 0x03
    4f5a:	9c 81       	ldd	r25, Y+4	; 0x04
    4f5c:	90 93 52 07 	sts	0x0752, r25
    4f60:	80 93 51 07 	sts	0x0751, r24
		GICR	|= (1<<INT2);
    4f64:	ab e5       	ldi	r26, 0x5B	; 91
    4f66:	b0 e0       	ldi	r27, 0x00	; 0
    4f68:	eb e5       	ldi	r30, 0x5B	; 91
    4f6a:	f0 e0       	ldi	r31, 0x00	; 0
    4f6c:	80 81       	ld	r24, Z
    4f6e:	80 62       	ori	r24, 0x20	; 32
    4f70:	8c 93       	st	X, r24
		break;
	}	
	sei();	
    4f72:	78 94       	sei
}
    4f74:	26 96       	adiw	r28, 0x06	; 6
    4f76:	0f b6       	in	r0, 0x3f	; 63
    4f78:	f8 94       	cli
    4f7a:	de bf       	out	0x3e, r29	; 62
    4f7c:	0f be       	out	0x3f, r0	; 63
    4f7e:	cd bf       	out	0x3d, r28	; 61
    4f80:	cf 91       	pop	r28
    4f82:	df 91       	pop	r29
    4f84:	08 95       	ret

00004f86 <__vector_1>:

ISR(INT0_vect){
    4f86:	1f 92       	push	r1
    4f88:	0f 92       	push	r0
    4f8a:	0f b6       	in	r0, 0x3f	; 63
    4f8c:	0f 92       	push	r0
    4f8e:	11 24       	eor	r1, r1
    4f90:	2f 93       	push	r18
    4f92:	3f 93       	push	r19
    4f94:	4f 93       	push	r20
    4f96:	5f 93       	push	r21
    4f98:	6f 93       	push	r22
    4f9a:	7f 93       	push	r23
    4f9c:	8f 93       	push	r24
    4f9e:	9f 93       	push	r25
    4fa0:	af 93       	push	r26
    4fa2:	bf 93       	push	r27
    4fa4:	ef 93       	push	r30
    4fa6:	ff 93       	push	r31
    4fa8:	df 93       	push	r29
    4faa:	cf 93       	push	r28
    4fac:	cd b7       	in	r28, 0x3d	; 61
    4fae:	de b7       	in	r29, 0x3e	; 62
	callbacks[0]();
    4fb0:	e0 91 4d 07 	lds	r30, 0x074D
    4fb4:	f0 91 4e 07 	lds	r31, 0x074E
    4fb8:	09 95       	icall
}
    4fba:	cf 91       	pop	r28
    4fbc:	df 91       	pop	r29
    4fbe:	ff 91       	pop	r31
    4fc0:	ef 91       	pop	r30
    4fc2:	bf 91       	pop	r27
    4fc4:	af 91       	pop	r26
    4fc6:	9f 91       	pop	r25
    4fc8:	8f 91       	pop	r24
    4fca:	7f 91       	pop	r23
    4fcc:	6f 91       	pop	r22
    4fce:	5f 91       	pop	r21
    4fd0:	4f 91       	pop	r20
    4fd2:	3f 91       	pop	r19
    4fd4:	2f 91       	pop	r18
    4fd6:	0f 90       	pop	r0
    4fd8:	0f be       	out	0x3f, r0	; 63
    4fda:	0f 90       	pop	r0
    4fdc:	1f 90       	pop	r1
    4fde:	18 95       	reti

00004fe0 <__vector_2>:
ISR(INT1_vect){
    4fe0:	1f 92       	push	r1
    4fe2:	0f 92       	push	r0
    4fe4:	0f b6       	in	r0, 0x3f	; 63
    4fe6:	0f 92       	push	r0
    4fe8:	11 24       	eor	r1, r1
    4fea:	2f 93       	push	r18
    4fec:	3f 93       	push	r19
    4fee:	4f 93       	push	r20
    4ff0:	5f 93       	push	r21
    4ff2:	6f 93       	push	r22
    4ff4:	7f 93       	push	r23
    4ff6:	8f 93       	push	r24
    4ff8:	9f 93       	push	r25
    4ffa:	af 93       	push	r26
    4ffc:	bf 93       	push	r27
    4ffe:	ef 93       	push	r30
    5000:	ff 93       	push	r31
    5002:	df 93       	push	r29
    5004:	cf 93       	push	r28
    5006:	cd b7       	in	r28, 0x3d	; 61
    5008:	de b7       	in	r29, 0x3e	; 62
	callbacks[1]();
    500a:	e0 91 4f 07 	lds	r30, 0x074F
    500e:	f0 91 50 07 	lds	r31, 0x0750
    5012:	09 95       	icall
}
    5014:	cf 91       	pop	r28
    5016:	df 91       	pop	r29
    5018:	ff 91       	pop	r31
    501a:	ef 91       	pop	r30
    501c:	bf 91       	pop	r27
    501e:	af 91       	pop	r26
    5020:	9f 91       	pop	r25
    5022:	8f 91       	pop	r24
    5024:	7f 91       	pop	r23
    5026:	6f 91       	pop	r22
    5028:	5f 91       	pop	r21
    502a:	4f 91       	pop	r20
    502c:	3f 91       	pop	r19
    502e:	2f 91       	pop	r18
    5030:	0f 90       	pop	r0
    5032:	0f be       	out	0x3f, r0	; 63
    5034:	0f 90       	pop	r0
    5036:	1f 90       	pop	r1
    5038:	18 95       	reti

0000503a <__vector_3>:
ISR(INT2_vect){
    503a:	1f 92       	push	r1
    503c:	0f 92       	push	r0
    503e:	0f b6       	in	r0, 0x3f	; 63
    5040:	0f 92       	push	r0
    5042:	11 24       	eor	r1, r1
    5044:	2f 93       	push	r18
    5046:	3f 93       	push	r19
    5048:	4f 93       	push	r20
    504a:	5f 93       	push	r21
    504c:	6f 93       	push	r22
    504e:	7f 93       	push	r23
    5050:	8f 93       	push	r24
    5052:	9f 93       	push	r25
    5054:	af 93       	push	r26
    5056:	bf 93       	push	r27
    5058:	ef 93       	push	r30
    505a:	ff 93       	push	r31
    505c:	df 93       	push	r29
    505e:	cf 93       	push	r28
    5060:	cd b7       	in	r28, 0x3d	; 61
    5062:	de b7       	in	r29, 0x3e	; 62
	callbacks[2]();
    5064:	e0 91 51 07 	lds	r30, 0x0751
    5068:	f0 91 52 07 	lds	r31, 0x0752
    506c:	09 95       	icall
    506e:	cf 91       	pop	r28
    5070:	df 91       	pop	r29
    5072:	ff 91       	pop	r31
    5074:	ef 91       	pop	r30
    5076:	bf 91       	pop	r27
    5078:	af 91       	pop	r26
    507a:	9f 91       	pop	r25
    507c:	8f 91       	pop	r24
    507e:	7f 91       	pop	r23
    5080:	6f 91       	pop	r22
    5082:	5f 91       	pop	r21
    5084:	4f 91       	pop	r20
    5086:	3f 91       	pop	r19
    5088:	2f 91       	pop	r18
    508a:	0f 90       	pop	r0
    508c:	0f be       	out	0x3f, r0	; 63
    508e:	0f 90       	pop	r0
    5090:	1f 90       	pop	r1
    5092:	18 95       	reti

00005094 <LCD_Init>:
static void LCD_SendData(u8 u8Data);
static void LCD_GoToXY(u8 row, u8 col);
static void LCD_Latch(void);

/* Functions */
void LCD_Init(void){
    5094:	df 93       	push	r29
    5096:	cf 93       	push	r28
    5098:	cd b7       	in	r28, 0x3d	; 61
    509a:	de b7       	in	r29, 0x3e	; 62
    509c:	2e 97       	sbiw	r28, 0x0e	; 14
    509e:	0f b6       	in	r0, 0x3f	; 63
    50a0:	f8 94       	cli
    50a2:	de bf       	out	0x3e, r29	; 62
    50a4:	0f be       	out	0x3f, r0	; 63
    50a6:	cd bf       	out	0x3d, r28	; 61
	/* Out */
	setBits(LCD_DATA_DDR, LCD_DATA_MSK);
    50a8:	a4 e3       	ldi	r26, 0x34	; 52
    50aa:	b0 e0       	ldi	r27, 0x00	; 0
    50ac:	e4 e3       	ldi	r30, 0x34	; 52
    50ae:	f0 e0       	ldi	r31, 0x00	; 0
    50b0:	80 81       	ld	r24, Z
    50b2:	80 6f       	ori	r24, 0xF0	; 240
    50b4:	8c 93       	st	X, r24
	setBit(LCD_CTRL_DDR, LCD_RS_PIN);
    50b6:	a7 e3       	ldi	r26, 0x37	; 55
    50b8:	b0 e0       	ldi	r27, 0x00	; 0
    50ba:	e7 e3       	ldi	r30, 0x37	; 55
    50bc:	f0 e0       	ldi	r31, 0x00	; 0
    50be:	80 81       	ld	r24, Z
    50c0:	82 60       	ori	r24, 0x02	; 2
    50c2:	8c 93       	st	X, r24
	setBit(LCD_CTRL_DDR, LCD_EN_PIN);
    50c4:	a7 e3       	ldi	r26, 0x37	; 55
    50c6:	b0 e0       	ldi	r27, 0x00	; 0
    50c8:	e7 e3       	ldi	r30, 0x37	; 55
    50ca:	f0 e0       	ldi	r31, 0x00	; 0
    50cc:	80 81       	ld	r24, Z
    50ce:	81 60       	ori	r24, 0x01	; 1
    50d0:	8c 93       	st	X, r24
    50d2:	80 e0       	ldi	r24, 0x00	; 0
    50d4:	90 e0       	ldi	r25, 0x00	; 0
    50d6:	a8 ec       	ldi	r26, 0xC8	; 200
    50d8:	b2 e4       	ldi	r27, 0x42	; 66
    50da:	8b 87       	std	Y+11, r24	; 0x0b
    50dc:	9c 87       	std	Y+12, r25	; 0x0c
    50de:	ad 87       	std	Y+13, r26	; 0x0d
    50e0:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    50e2:	6b 85       	ldd	r22, Y+11	; 0x0b
    50e4:	7c 85       	ldd	r23, Y+12	; 0x0c
    50e6:	8d 85       	ldd	r24, Y+13	; 0x0d
    50e8:	9e 85       	ldd	r25, Y+14	; 0x0e
    50ea:	20 e0       	ldi	r18, 0x00	; 0
    50ec:	30 e0       	ldi	r19, 0x00	; 0
    50ee:	4a ef       	ldi	r20, 0xFA	; 250
    50f0:	54 e4       	ldi	r21, 0x44	; 68
    50f2:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    50f6:	dc 01       	movw	r26, r24
    50f8:	cb 01       	movw	r24, r22
    50fa:	8f 83       	std	Y+7, r24	; 0x07
    50fc:	98 87       	std	Y+8, r25	; 0x08
    50fe:	a9 87       	std	Y+9, r26	; 0x09
    5100:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    5102:	6f 81       	ldd	r22, Y+7	; 0x07
    5104:	78 85       	ldd	r23, Y+8	; 0x08
    5106:	89 85       	ldd	r24, Y+9	; 0x09
    5108:	9a 85       	ldd	r25, Y+10	; 0x0a
    510a:	20 e0       	ldi	r18, 0x00	; 0
    510c:	30 e0       	ldi	r19, 0x00	; 0
    510e:	40 e8       	ldi	r20, 0x80	; 128
    5110:	5f e3       	ldi	r21, 0x3F	; 63
    5112:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    5116:	88 23       	and	r24, r24
    5118:	2c f4       	brge	.+10     	; 0x5124 <LCD_Init+0x90>
		__ticks = 1;
    511a:	81 e0       	ldi	r24, 0x01	; 1
    511c:	90 e0       	ldi	r25, 0x00	; 0
    511e:	9e 83       	std	Y+6, r25	; 0x06
    5120:	8d 83       	std	Y+5, r24	; 0x05
    5122:	3f c0       	rjmp	.+126    	; 0x51a2 <LCD_Init+0x10e>
	else if (__tmp > 65535)
    5124:	6f 81       	ldd	r22, Y+7	; 0x07
    5126:	78 85       	ldd	r23, Y+8	; 0x08
    5128:	89 85       	ldd	r24, Y+9	; 0x09
    512a:	9a 85       	ldd	r25, Y+10	; 0x0a
    512c:	20 e0       	ldi	r18, 0x00	; 0
    512e:	3f ef       	ldi	r19, 0xFF	; 255
    5130:	4f e7       	ldi	r20, 0x7F	; 127
    5132:	57 e4       	ldi	r21, 0x47	; 71
    5134:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    5138:	18 16       	cp	r1, r24
    513a:	4c f5       	brge	.+82     	; 0x518e <LCD_Init+0xfa>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    513c:	6b 85       	ldd	r22, Y+11	; 0x0b
    513e:	7c 85       	ldd	r23, Y+12	; 0x0c
    5140:	8d 85       	ldd	r24, Y+13	; 0x0d
    5142:	9e 85       	ldd	r25, Y+14	; 0x0e
    5144:	20 e0       	ldi	r18, 0x00	; 0
    5146:	30 e0       	ldi	r19, 0x00	; 0
    5148:	40 e2       	ldi	r20, 0x20	; 32
    514a:	51 e4       	ldi	r21, 0x41	; 65
    514c:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    5150:	dc 01       	movw	r26, r24
    5152:	cb 01       	movw	r24, r22
    5154:	bc 01       	movw	r22, r24
    5156:	cd 01       	movw	r24, r26
    5158:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    515c:	dc 01       	movw	r26, r24
    515e:	cb 01       	movw	r24, r22
    5160:	9e 83       	std	Y+6, r25	; 0x06
    5162:	8d 83       	std	Y+5, r24	; 0x05
    5164:	0f c0       	rjmp	.+30     	; 0x5184 <LCD_Init+0xf0>
    5166:	88 ec       	ldi	r24, 0xC8	; 200
    5168:	90 e0       	ldi	r25, 0x00	; 0
    516a:	9c 83       	std	Y+4, r25	; 0x04
    516c:	8b 83       	std	Y+3, r24	; 0x03
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    516e:	8b 81       	ldd	r24, Y+3	; 0x03
    5170:	9c 81       	ldd	r25, Y+4	; 0x04
    5172:	01 97       	sbiw	r24, 0x01	; 1
    5174:	f1 f7       	brne	.-4      	; 0x5172 <LCD_Init+0xde>
    5176:	9c 83       	std	Y+4, r25	; 0x04
    5178:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    517a:	8d 81       	ldd	r24, Y+5	; 0x05
    517c:	9e 81       	ldd	r25, Y+6	; 0x06
    517e:	01 97       	sbiw	r24, 0x01	; 1
    5180:	9e 83       	std	Y+6, r25	; 0x06
    5182:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    5184:	8d 81       	ldd	r24, Y+5	; 0x05
    5186:	9e 81       	ldd	r25, Y+6	; 0x06
    5188:	00 97       	sbiw	r24, 0x00	; 0
    518a:	69 f7       	brne	.-38     	; 0x5166 <LCD_Init+0xd2>
    518c:	14 c0       	rjmp	.+40     	; 0x51b6 <LCD_Init+0x122>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    518e:	6f 81       	ldd	r22, Y+7	; 0x07
    5190:	78 85       	ldd	r23, Y+8	; 0x08
    5192:	89 85       	ldd	r24, Y+9	; 0x09
    5194:	9a 85       	ldd	r25, Y+10	; 0x0a
    5196:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    519a:	dc 01       	movw	r26, r24
    519c:	cb 01       	movw	r24, r22
    519e:	9e 83       	std	Y+6, r25	; 0x06
    51a0:	8d 83       	std	Y+5, r24	; 0x05
    51a2:	8d 81       	ldd	r24, Y+5	; 0x05
    51a4:	9e 81       	ldd	r25, Y+6	; 0x06
    51a6:	9a 83       	std	Y+2, r25	; 0x02
    51a8:	89 83       	std	Y+1, r24	; 0x01
    51aa:	89 81       	ldd	r24, Y+1	; 0x01
    51ac:	9a 81       	ldd	r25, Y+2	; 0x02
    51ae:	01 97       	sbiw	r24, 0x01	; 1
    51b0:	f1 f7       	brne	.-4      	; 0x51ae <LCD_Init+0x11a>
    51b2:	9a 83       	std	Y+2, r25	; 0x02
    51b4:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(100);
	LCD_SendCMD(CMD_FUN_SET_4BIT);	/* Required: to set 4Bit operation */			
    51b6:	82 e0       	ldi	r24, 0x02	; 2
    51b8:	0e 94 df 29 	call	0x53be	; 0x53be <LCD_SendCMD>
	LCD_SendCMD(CMD_CFG);			/* Full CFG */		
    51bc:	88 e2       	ldi	r24, 0x28	; 40
    51be:	0e 94 df 29 	call	0x53be	; 0x53be <LCD_SendCMD>
	LCD_SendCMD(CMD_DISP_ON);
    51c2:	8c e0       	ldi	r24, 0x0C	; 12
    51c4:	0e 94 df 29 	call	0x53be	; 0x53be <LCD_SendCMD>
	LCD_SendCMD(CMD_ENTRY_MODE);
    51c8:	86 e0       	ldi	r24, 0x06	; 6
    51ca:	0e 94 df 29 	call	0x53be	; 0x53be <LCD_SendCMD>
	LCD_Clear();
    51ce:	0e 94 f2 28 	call	0x51e4	; 0x51e4 <LCD_Clear>
}
    51d2:	2e 96       	adiw	r28, 0x0e	; 14
    51d4:	0f b6       	in	r0, 0x3f	; 63
    51d6:	f8 94       	cli
    51d8:	de bf       	out	0x3e, r29	; 62
    51da:	0f be       	out	0x3f, r0	; 63
    51dc:	cd bf       	out	0x3d, r28	; 61
    51de:	cf 91       	pop	r28
    51e0:	df 91       	pop	r29
    51e2:	08 95       	ret

000051e4 <LCD_Clear>:
void LCD_Clear(void){
    51e4:	df 93       	push	r29
    51e6:	cf 93       	push	r28
    51e8:	cd b7       	in	r28, 0x3d	; 61
    51ea:	de b7       	in	r29, 0x3e	; 62
    51ec:	2e 97       	sbiw	r28, 0x0e	; 14
    51ee:	0f b6       	in	r0, 0x3f	; 63
    51f0:	f8 94       	cli
    51f2:	de bf       	out	0x3e, r29	; 62
    51f4:	0f be       	out	0x3f, r0	; 63
    51f6:	cd bf       	out	0x3d, r28	; 61
	LCD_SendCMD(CMD_CLEAR);
    51f8:	81 e0       	ldi	r24, 0x01	; 1
    51fa:	0e 94 df 29 	call	0x53be	; 0x53be <LCD_SendCMD>
    51fe:	80 e0       	ldi	r24, 0x00	; 0
    5200:	90 e0       	ldi	r25, 0x00	; 0
    5202:	a0 ea       	ldi	r26, 0xA0	; 160
    5204:	b0 e4       	ldi	r27, 0x40	; 64
    5206:	8b 87       	std	Y+11, r24	; 0x0b
    5208:	9c 87       	std	Y+12, r25	; 0x0c
    520a:	ad 87       	std	Y+13, r26	; 0x0d
    520c:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    520e:	6b 85       	ldd	r22, Y+11	; 0x0b
    5210:	7c 85       	ldd	r23, Y+12	; 0x0c
    5212:	8d 85       	ldd	r24, Y+13	; 0x0d
    5214:	9e 85       	ldd	r25, Y+14	; 0x0e
    5216:	20 e0       	ldi	r18, 0x00	; 0
    5218:	30 e0       	ldi	r19, 0x00	; 0
    521a:	4a ef       	ldi	r20, 0xFA	; 250
    521c:	54 e4       	ldi	r21, 0x44	; 68
    521e:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    5222:	dc 01       	movw	r26, r24
    5224:	cb 01       	movw	r24, r22
    5226:	8f 83       	std	Y+7, r24	; 0x07
    5228:	98 87       	std	Y+8, r25	; 0x08
    522a:	a9 87       	std	Y+9, r26	; 0x09
    522c:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    522e:	6f 81       	ldd	r22, Y+7	; 0x07
    5230:	78 85       	ldd	r23, Y+8	; 0x08
    5232:	89 85       	ldd	r24, Y+9	; 0x09
    5234:	9a 85       	ldd	r25, Y+10	; 0x0a
    5236:	20 e0       	ldi	r18, 0x00	; 0
    5238:	30 e0       	ldi	r19, 0x00	; 0
    523a:	40 e8       	ldi	r20, 0x80	; 128
    523c:	5f e3       	ldi	r21, 0x3F	; 63
    523e:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    5242:	88 23       	and	r24, r24
    5244:	2c f4       	brge	.+10     	; 0x5250 <LCD_Clear+0x6c>
		__ticks = 1;
    5246:	81 e0       	ldi	r24, 0x01	; 1
    5248:	90 e0       	ldi	r25, 0x00	; 0
    524a:	9e 83       	std	Y+6, r25	; 0x06
    524c:	8d 83       	std	Y+5, r24	; 0x05
    524e:	3f c0       	rjmp	.+126    	; 0x52ce <LCD_Clear+0xea>
	else if (__tmp > 65535)
    5250:	6f 81       	ldd	r22, Y+7	; 0x07
    5252:	78 85       	ldd	r23, Y+8	; 0x08
    5254:	89 85       	ldd	r24, Y+9	; 0x09
    5256:	9a 85       	ldd	r25, Y+10	; 0x0a
    5258:	20 e0       	ldi	r18, 0x00	; 0
    525a:	3f ef       	ldi	r19, 0xFF	; 255
    525c:	4f e7       	ldi	r20, 0x7F	; 127
    525e:	57 e4       	ldi	r21, 0x47	; 71
    5260:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    5264:	18 16       	cp	r1, r24
    5266:	4c f5       	brge	.+82     	; 0x52ba <LCD_Clear+0xd6>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    5268:	6b 85       	ldd	r22, Y+11	; 0x0b
    526a:	7c 85       	ldd	r23, Y+12	; 0x0c
    526c:	8d 85       	ldd	r24, Y+13	; 0x0d
    526e:	9e 85       	ldd	r25, Y+14	; 0x0e
    5270:	20 e0       	ldi	r18, 0x00	; 0
    5272:	30 e0       	ldi	r19, 0x00	; 0
    5274:	40 e2       	ldi	r20, 0x20	; 32
    5276:	51 e4       	ldi	r21, 0x41	; 65
    5278:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    527c:	dc 01       	movw	r26, r24
    527e:	cb 01       	movw	r24, r22
    5280:	bc 01       	movw	r22, r24
    5282:	cd 01       	movw	r24, r26
    5284:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    5288:	dc 01       	movw	r26, r24
    528a:	cb 01       	movw	r24, r22
    528c:	9e 83       	std	Y+6, r25	; 0x06
    528e:	8d 83       	std	Y+5, r24	; 0x05
    5290:	0f c0       	rjmp	.+30     	; 0x52b0 <LCD_Clear+0xcc>
    5292:	88 ec       	ldi	r24, 0xC8	; 200
    5294:	90 e0       	ldi	r25, 0x00	; 0
    5296:	9c 83       	std	Y+4, r25	; 0x04
    5298:	8b 83       	std	Y+3, r24	; 0x03
    529a:	8b 81       	ldd	r24, Y+3	; 0x03
    529c:	9c 81       	ldd	r25, Y+4	; 0x04
    529e:	01 97       	sbiw	r24, 0x01	; 1
    52a0:	f1 f7       	brne	.-4      	; 0x529e <LCD_Clear+0xba>
    52a2:	9c 83       	std	Y+4, r25	; 0x04
    52a4:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    52a6:	8d 81       	ldd	r24, Y+5	; 0x05
    52a8:	9e 81       	ldd	r25, Y+6	; 0x06
    52aa:	01 97       	sbiw	r24, 0x01	; 1
    52ac:	9e 83       	std	Y+6, r25	; 0x06
    52ae:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    52b0:	8d 81       	ldd	r24, Y+5	; 0x05
    52b2:	9e 81       	ldd	r25, Y+6	; 0x06
    52b4:	00 97       	sbiw	r24, 0x00	; 0
    52b6:	69 f7       	brne	.-38     	; 0x5292 <LCD_Clear+0xae>
    52b8:	14 c0       	rjmp	.+40     	; 0x52e2 <LCD_Clear+0xfe>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    52ba:	6f 81       	ldd	r22, Y+7	; 0x07
    52bc:	78 85       	ldd	r23, Y+8	; 0x08
    52be:	89 85       	ldd	r24, Y+9	; 0x09
    52c0:	9a 85       	ldd	r25, Y+10	; 0x0a
    52c2:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    52c6:	dc 01       	movw	r26, r24
    52c8:	cb 01       	movw	r24, r22
    52ca:	9e 83       	std	Y+6, r25	; 0x06
    52cc:	8d 83       	std	Y+5, r24	; 0x05
    52ce:	8d 81       	ldd	r24, Y+5	; 0x05
    52d0:	9e 81       	ldd	r25, Y+6	; 0x06
    52d2:	9a 83       	std	Y+2, r25	; 0x02
    52d4:	89 83       	std	Y+1, r24	; 0x01
    52d6:	89 81       	ldd	r24, Y+1	; 0x01
    52d8:	9a 81       	ldd	r25, Y+2	; 0x02
    52da:	01 97       	sbiw	r24, 0x01	; 1
    52dc:	f1 f7       	brne	.-4      	; 0x52da <LCD_Clear+0xf6>
    52de:	9a 83       	std	Y+2, r25	; 0x02
    52e0:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(5);
}
    52e2:	2e 96       	adiw	r28, 0x0e	; 14
    52e4:	0f b6       	in	r0, 0x3f	; 63
    52e6:	f8 94       	cli
    52e8:	de bf       	out	0x3e, r29	; 62
    52ea:	0f be       	out	0x3f, r0	; 63
    52ec:	cd bf       	out	0x3d, r28	; 61
    52ee:	cf 91       	pop	r28
    52f0:	df 91       	pop	r29
    52f2:	08 95       	ret

000052f4 <LCD_DispChar>:
void LCD_DispChar(u8 u8Char){
    52f4:	df 93       	push	r29
    52f6:	cf 93       	push	r28
    52f8:	0f 92       	push	r0
    52fa:	cd b7       	in	r28, 0x3d	; 61
    52fc:	de b7       	in	r29, 0x3e	; 62
    52fe:	89 83       	std	Y+1, r24	; 0x01
	LCD_SendData(u8Char);
    5300:	89 81       	ldd	r24, Y+1	; 0x01
    5302:	0e 94 d4 2a 	call	0x55a8	; 0x55a8 <LCD_SendData>
}
    5306:	0f 90       	pop	r0
    5308:	cf 91       	pop	r28
    530a:	df 91       	pop	r29
    530c:	08 95       	ret

0000530e <LCD_DispStr>:
void LCD_DispStr(u8* pu8Str){
    530e:	df 93       	push	r29
    5310:	cf 93       	push	r28
    5312:	00 d0       	rcall	.+0      	; 0x5314 <LCD_DispStr+0x6>
    5314:	0f 92       	push	r0
    5316:	cd b7       	in	r28, 0x3d	; 61
    5318:	de b7       	in	r29, 0x3e	; 62
    531a:	9b 83       	std	Y+3, r25	; 0x03
    531c:	8a 83       	std	Y+2, r24	; 0x02
	u8 ind = 0;
    531e:	19 82       	std	Y+1, r1	; 0x01
    5320:	0e c0       	rjmp	.+28     	; 0x533e <LCD_DispStr+0x30>
	while(pu8Str[ind]){
		LCD_SendData(pu8Str[ind]);
    5322:	89 81       	ldd	r24, Y+1	; 0x01
    5324:	28 2f       	mov	r18, r24
    5326:	30 e0       	ldi	r19, 0x00	; 0
    5328:	8a 81       	ldd	r24, Y+2	; 0x02
    532a:	9b 81       	ldd	r25, Y+3	; 0x03
    532c:	fc 01       	movw	r30, r24
    532e:	e2 0f       	add	r30, r18
    5330:	f3 1f       	adc	r31, r19
    5332:	80 81       	ld	r24, Z
    5334:	0e 94 d4 2a 	call	0x55a8	; 0x55a8 <LCD_SendData>
		ind++;
    5338:	89 81       	ldd	r24, Y+1	; 0x01
    533a:	8f 5f       	subi	r24, 0xFF	; 255
    533c:	89 83       	std	Y+1, r24	; 0x01
void LCD_DispChar(u8 u8Char){
	LCD_SendData(u8Char);
}
void LCD_DispStr(u8* pu8Str){
	u8 ind = 0;
	while(pu8Str[ind]){
    533e:	89 81       	ldd	r24, Y+1	; 0x01
    5340:	28 2f       	mov	r18, r24
    5342:	30 e0       	ldi	r19, 0x00	; 0
    5344:	8a 81       	ldd	r24, Y+2	; 0x02
    5346:	9b 81       	ldd	r25, Y+3	; 0x03
    5348:	fc 01       	movw	r30, r24
    534a:	e2 0f       	add	r30, r18
    534c:	f3 1f       	adc	r31, r19
    534e:	80 81       	ld	r24, Z
    5350:	88 23       	and	r24, r24
    5352:	39 f7       	brne	.-50     	; 0x5322 <LCD_DispStr+0x14>
		LCD_SendData(pu8Str[ind]);
		ind++;
	}
}
    5354:	0f 90       	pop	r0
    5356:	0f 90       	pop	r0
    5358:	0f 90       	pop	r0
    535a:	cf 91       	pop	r28
    535c:	df 91       	pop	r29
    535e:	08 95       	ret

00005360 <LCD_DispCharXY>:
/* row: 1-2  - col: 1-16 */
void LCD_DispCharXY(u8 row, u8 col, u8 u8Char){
    5360:	df 93       	push	r29
    5362:	cf 93       	push	r28
    5364:	00 d0       	rcall	.+0      	; 0x5366 <LCD_DispCharXY+0x6>
    5366:	0f 92       	push	r0
    5368:	cd b7       	in	r28, 0x3d	; 61
    536a:	de b7       	in	r29, 0x3e	; 62
    536c:	89 83       	std	Y+1, r24	; 0x01
    536e:	6a 83       	std	Y+2, r22	; 0x02
    5370:	4b 83       	std	Y+3, r20	; 0x03
	LCD_GoToXY(row,col);
    5372:	89 81       	ldd	r24, Y+1	; 0x01
    5374:	6a 81       	ldd	r22, Y+2	; 0x02
    5376:	0e 94 c9 2b 	call	0x5792	; 0x5792 <LCD_GoToXY>
	LCD_DispChar(u8Char);
    537a:	8b 81       	ldd	r24, Y+3	; 0x03
    537c:	0e 94 7a 29 	call	0x52f4	; 0x52f4 <LCD_DispChar>
}
    5380:	0f 90       	pop	r0
    5382:	0f 90       	pop	r0
    5384:	0f 90       	pop	r0
    5386:	cf 91       	pop	r28
    5388:	df 91       	pop	r29
    538a:	08 95       	ret

0000538c <LCD_DispStrXY>:
void LCD_DispStrXY(u8 row, u8 col, u8* pu8Str){
    538c:	df 93       	push	r29
    538e:	cf 93       	push	r28
    5390:	00 d0       	rcall	.+0      	; 0x5392 <LCD_DispStrXY+0x6>
    5392:	00 d0       	rcall	.+0      	; 0x5394 <LCD_DispStrXY+0x8>
    5394:	cd b7       	in	r28, 0x3d	; 61
    5396:	de b7       	in	r29, 0x3e	; 62
    5398:	89 83       	std	Y+1, r24	; 0x01
    539a:	6a 83       	std	Y+2, r22	; 0x02
    539c:	5c 83       	std	Y+4, r21	; 0x04
    539e:	4b 83       	std	Y+3, r20	; 0x03
	LCD_GoToXY(row,col);
    53a0:	89 81       	ldd	r24, Y+1	; 0x01
    53a2:	6a 81       	ldd	r22, Y+2	; 0x02
    53a4:	0e 94 c9 2b 	call	0x5792	; 0x5792 <LCD_GoToXY>
	LCD_DispStr(pu8Str);
    53a8:	8b 81       	ldd	r24, Y+3	; 0x03
    53aa:	9c 81       	ldd	r25, Y+4	; 0x04
    53ac:	0e 94 87 29 	call	0x530e	; 0x530e <LCD_DispStr>
}
    53b0:	0f 90       	pop	r0
    53b2:	0f 90       	pop	r0
    53b4:	0f 90       	pop	r0
    53b6:	0f 90       	pop	r0
    53b8:	cf 91       	pop	r28
    53ba:	df 91       	pop	r29
    53bc:	08 95       	ret

000053be <LCD_SendCMD>:

static void LCD_SendCMD(u8 u8CMD){
    53be:	df 93       	push	r29
    53c0:	cf 93       	push	r28
    53c2:	cd b7       	in	r28, 0x3d	; 61
    53c4:	de b7       	in	r29, 0x3e	; 62
    53c6:	69 97       	sbiw	r28, 0x19	; 25
    53c8:	0f b6       	in	r0, 0x3f	; 63
    53ca:	f8 94       	cli
    53cc:	de bf       	out	0x3e, r29	; 62
    53ce:	0f be       	out	0x3f, r0	; 63
    53d0:	cd bf       	out	0x3d, r28	; 61
    53d2:	89 8f       	std	Y+25, r24	; 0x19
	/* RS = 0 */
	clearBit(LCD_CTRL_PORT, LCD_RS_PIN);
    53d4:	a8 e3       	ldi	r26, 0x38	; 56
    53d6:	b0 e0       	ldi	r27, 0x00	; 0
    53d8:	e8 e3       	ldi	r30, 0x38	; 56
    53da:	f0 e0       	ldi	r31, 0x00	; 0
    53dc:	80 81       	ld	r24, Z
    53de:	8d 7f       	andi	r24, 0xFD	; 253
    53e0:	8c 93       	st	X, r24
	/* upload most 4 bits and then latch */
	LCD_DATA_REG.HN = (u8CMD>>4);
    53e2:	e5 e3       	ldi	r30, 0x35	; 53
    53e4:	f0 e0       	ldi	r31, 0x00	; 0
    53e6:	89 8d       	ldd	r24, Y+25	; 0x19
    53e8:	82 95       	swap	r24
    53ea:	8f 70       	andi	r24, 0x0F	; 15
    53ec:	8f 70       	andi	r24, 0x0F	; 15
    53ee:	98 2f       	mov	r25, r24
    53f0:	92 95       	swap	r25
    53f2:	90 7f       	andi	r25, 0xF0	; 240
    53f4:	80 81       	ld	r24, Z
    53f6:	8f 70       	andi	r24, 0x0F	; 15
    53f8:	89 2b       	or	r24, r25
    53fa:	80 83       	st	Z, r24
	LCD_Latch();
    53fc:	0e 94 e1 2b 	call	0x57c2	; 0x57c2 <LCD_Latch>
	/* upload least 4 bits and then latch */
	LCD_DATA_REG.HN = u8CMD;
    5400:	e5 e3       	ldi	r30, 0x35	; 53
    5402:	f0 e0       	ldi	r31, 0x00	; 0
    5404:	89 8d       	ldd	r24, Y+25	; 0x19
    5406:	8f 70       	andi	r24, 0x0F	; 15
    5408:	98 2f       	mov	r25, r24
    540a:	92 95       	swap	r25
    540c:	90 7f       	andi	r25, 0xF0	; 240
    540e:	80 81       	ld	r24, Z
    5410:	8f 70       	andi	r24, 0x0F	; 15
    5412:	89 2b       	or	r24, r25
    5414:	80 83       	st	Z, r24
	LCD_Latch();
    5416:	0e 94 e1 2b 	call	0x57c2	; 0x57c2 <LCD_Latch>
    541a:	80 e0       	ldi	r24, 0x00	; 0
    541c:	90 e0       	ldi	r25, 0x00	; 0
    541e:	a0 e2       	ldi	r26, 0x20	; 32
    5420:	b2 e4       	ldi	r27, 0x42	; 66
    5422:	8d 8b       	std	Y+21, r24	; 0x15
    5424:	9e 8b       	std	Y+22, r25	; 0x16
    5426:	af 8b       	std	Y+23, r26	; 0x17
    5428:	b8 8f       	std	Y+24, r27	; 0x18
 */
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
    542a:	6d 89       	ldd	r22, Y+21	; 0x15
    542c:	7e 89       	ldd	r23, Y+22	; 0x16
    542e:	8f 89       	ldd	r24, Y+23	; 0x17
    5430:	98 8d       	ldd	r25, Y+24	; 0x18
    5432:	2b ea       	ldi	r18, 0xAB	; 171
    5434:	3a ea       	ldi	r19, 0xAA	; 170
    5436:	4a e2       	ldi	r20, 0x2A	; 42
    5438:	50 e4       	ldi	r21, 0x40	; 64
    543a:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    543e:	dc 01       	movw	r26, r24
    5440:	cb 01       	movw	r24, r22
    5442:	89 8b       	std	Y+17, r24	; 0x11
    5444:	9a 8b       	std	Y+18, r25	; 0x12
    5446:	ab 8b       	std	Y+19, r26	; 0x13
    5448:	bc 8b       	std	Y+20, r27	; 0x14
	if (__tmp < 1.0)
    544a:	69 89       	ldd	r22, Y+17	; 0x11
    544c:	7a 89       	ldd	r23, Y+18	; 0x12
    544e:	8b 89       	ldd	r24, Y+19	; 0x13
    5450:	9c 89       	ldd	r25, Y+20	; 0x14
    5452:	20 e0       	ldi	r18, 0x00	; 0
    5454:	30 e0       	ldi	r19, 0x00	; 0
    5456:	40 e8       	ldi	r20, 0x80	; 128
    5458:	5f e3       	ldi	r21, 0x3F	; 63
    545a:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    545e:	88 23       	and	r24, r24
    5460:	1c f4       	brge	.+6      	; 0x5468 <LCD_SendCMD+0xaa>
		__ticks = 1;
    5462:	81 e0       	ldi	r24, 0x01	; 1
    5464:	88 8b       	std	Y+16, r24	; 0x10
    5466:	91 c0       	rjmp	.+290    	; 0x558a <LCD_SendCMD+0x1cc>
	else if (__tmp > 255)
    5468:	69 89       	ldd	r22, Y+17	; 0x11
    546a:	7a 89       	ldd	r23, Y+18	; 0x12
    546c:	8b 89       	ldd	r24, Y+19	; 0x13
    546e:	9c 89       	ldd	r25, Y+20	; 0x14
    5470:	20 e0       	ldi	r18, 0x00	; 0
    5472:	30 e0       	ldi	r19, 0x00	; 0
    5474:	4f e7       	ldi	r20, 0x7F	; 127
    5476:	53 e4       	ldi	r21, 0x43	; 67
    5478:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    547c:	18 16       	cp	r1, r24
    547e:	0c f0       	brlt	.+2      	; 0x5482 <LCD_SendCMD+0xc4>
    5480:	7b c0       	rjmp	.+246    	; 0x5578 <LCD_SendCMD+0x1ba>
	{
		_delay_ms(__us / 1000.0);
    5482:	6d 89       	ldd	r22, Y+21	; 0x15
    5484:	7e 89       	ldd	r23, Y+22	; 0x16
    5486:	8f 89       	ldd	r24, Y+23	; 0x17
    5488:	98 8d       	ldd	r25, Y+24	; 0x18
    548a:	20 e0       	ldi	r18, 0x00	; 0
    548c:	30 e0       	ldi	r19, 0x00	; 0
    548e:	4a e7       	ldi	r20, 0x7A	; 122
    5490:	54 e4       	ldi	r21, 0x44	; 68
    5492:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    5496:	dc 01       	movw	r26, r24
    5498:	cb 01       	movw	r24, r22
    549a:	8c 87       	std	Y+12, r24	; 0x0c
    549c:	9d 87       	std	Y+13, r25	; 0x0d
    549e:	ae 87       	std	Y+14, r26	; 0x0e
    54a0:	bf 87       	std	Y+15, r27	; 0x0f
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    54a2:	6c 85       	ldd	r22, Y+12	; 0x0c
    54a4:	7d 85       	ldd	r23, Y+13	; 0x0d
    54a6:	8e 85       	ldd	r24, Y+14	; 0x0e
    54a8:	9f 85       	ldd	r25, Y+15	; 0x0f
    54aa:	20 e0       	ldi	r18, 0x00	; 0
    54ac:	30 e0       	ldi	r19, 0x00	; 0
    54ae:	4a ef       	ldi	r20, 0xFA	; 250
    54b0:	54 e4       	ldi	r21, 0x44	; 68
    54b2:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    54b6:	dc 01       	movw	r26, r24
    54b8:	cb 01       	movw	r24, r22
    54ba:	88 87       	std	Y+8, r24	; 0x08
    54bc:	99 87       	std	Y+9, r25	; 0x09
    54be:	aa 87       	std	Y+10, r26	; 0x0a
    54c0:	bb 87       	std	Y+11, r27	; 0x0b
	if (__tmp < 1.0)
    54c2:	68 85       	ldd	r22, Y+8	; 0x08
    54c4:	79 85       	ldd	r23, Y+9	; 0x09
    54c6:	8a 85       	ldd	r24, Y+10	; 0x0a
    54c8:	9b 85       	ldd	r25, Y+11	; 0x0b
    54ca:	20 e0       	ldi	r18, 0x00	; 0
    54cc:	30 e0       	ldi	r19, 0x00	; 0
    54ce:	40 e8       	ldi	r20, 0x80	; 128
    54d0:	5f e3       	ldi	r21, 0x3F	; 63
    54d2:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    54d6:	88 23       	and	r24, r24
    54d8:	2c f4       	brge	.+10     	; 0x54e4 <LCD_SendCMD+0x126>
		__ticks = 1;
    54da:	81 e0       	ldi	r24, 0x01	; 1
    54dc:	90 e0       	ldi	r25, 0x00	; 0
    54de:	9f 83       	std	Y+7, r25	; 0x07
    54e0:	8e 83       	std	Y+6, r24	; 0x06
    54e2:	3f c0       	rjmp	.+126    	; 0x5562 <LCD_SendCMD+0x1a4>
	else if (__tmp > 65535)
    54e4:	68 85       	ldd	r22, Y+8	; 0x08
    54e6:	79 85       	ldd	r23, Y+9	; 0x09
    54e8:	8a 85       	ldd	r24, Y+10	; 0x0a
    54ea:	9b 85       	ldd	r25, Y+11	; 0x0b
    54ec:	20 e0       	ldi	r18, 0x00	; 0
    54ee:	3f ef       	ldi	r19, 0xFF	; 255
    54f0:	4f e7       	ldi	r20, 0x7F	; 127
    54f2:	57 e4       	ldi	r21, 0x47	; 71
    54f4:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    54f8:	18 16       	cp	r1, r24
    54fa:	4c f5       	brge	.+82     	; 0x554e <LCD_SendCMD+0x190>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    54fc:	6c 85       	ldd	r22, Y+12	; 0x0c
    54fe:	7d 85       	ldd	r23, Y+13	; 0x0d
    5500:	8e 85       	ldd	r24, Y+14	; 0x0e
    5502:	9f 85       	ldd	r25, Y+15	; 0x0f
    5504:	20 e0       	ldi	r18, 0x00	; 0
    5506:	30 e0       	ldi	r19, 0x00	; 0
    5508:	40 e2       	ldi	r20, 0x20	; 32
    550a:	51 e4       	ldi	r21, 0x41	; 65
    550c:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    5510:	dc 01       	movw	r26, r24
    5512:	cb 01       	movw	r24, r22
    5514:	bc 01       	movw	r22, r24
    5516:	cd 01       	movw	r24, r26
    5518:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    551c:	dc 01       	movw	r26, r24
    551e:	cb 01       	movw	r24, r22
    5520:	9f 83       	std	Y+7, r25	; 0x07
    5522:	8e 83       	std	Y+6, r24	; 0x06
    5524:	0f c0       	rjmp	.+30     	; 0x5544 <LCD_SendCMD+0x186>
    5526:	88 ec       	ldi	r24, 0xC8	; 200
    5528:	90 e0       	ldi	r25, 0x00	; 0
    552a:	9d 83       	std	Y+5, r25	; 0x05
    552c:	8c 83       	std	Y+4, r24	; 0x04
    552e:	8c 81       	ldd	r24, Y+4	; 0x04
    5530:	9d 81       	ldd	r25, Y+5	; 0x05
    5532:	01 97       	sbiw	r24, 0x01	; 1
    5534:	f1 f7       	brne	.-4      	; 0x5532 <LCD_SendCMD+0x174>
    5536:	9d 83       	std	Y+5, r25	; 0x05
    5538:	8c 83       	std	Y+4, r24	; 0x04
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    553a:	8e 81       	ldd	r24, Y+6	; 0x06
    553c:	9f 81       	ldd	r25, Y+7	; 0x07
    553e:	01 97       	sbiw	r24, 0x01	; 1
    5540:	9f 83       	std	Y+7, r25	; 0x07
    5542:	8e 83       	std	Y+6, r24	; 0x06
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    5544:	8e 81       	ldd	r24, Y+6	; 0x06
    5546:	9f 81       	ldd	r25, Y+7	; 0x07
    5548:	00 97       	sbiw	r24, 0x00	; 0
    554a:	69 f7       	brne	.-38     	; 0x5526 <LCD_SendCMD+0x168>
    554c:	24 c0       	rjmp	.+72     	; 0x5596 <LCD_SendCMD+0x1d8>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    554e:	68 85       	ldd	r22, Y+8	; 0x08
    5550:	79 85       	ldd	r23, Y+9	; 0x09
    5552:	8a 85       	ldd	r24, Y+10	; 0x0a
    5554:	9b 85       	ldd	r25, Y+11	; 0x0b
    5556:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    555a:	dc 01       	movw	r26, r24
    555c:	cb 01       	movw	r24, r22
    555e:	9f 83       	std	Y+7, r25	; 0x07
    5560:	8e 83       	std	Y+6, r24	; 0x06
    5562:	8e 81       	ldd	r24, Y+6	; 0x06
    5564:	9f 81       	ldd	r25, Y+7	; 0x07
    5566:	9b 83       	std	Y+3, r25	; 0x03
    5568:	8a 83       	std	Y+2, r24	; 0x02
    556a:	8a 81       	ldd	r24, Y+2	; 0x02
    556c:	9b 81       	ldd	r25, Y+3	; 0x03
    556e:	01 97       	sbiw	r24, 0x01	; 1
    5570:	f1 f7       	brne	.-4      	; 0x556e <LCD_SendCMD+0x1b0>
    5572:	9b 83       	std	Y+3, r25	; 0x03
    5574:	8a 83       	std	Y+2, r24	; 0x02
    5576:	0f c0       	rjmp	.+30     	; 0x5596 <LCD_SendCMD+0x1d8>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    5578:	69 89       	ldd	r22, Y+17	; 0x11
    557a:	7a 89       	ldd	r23, Y+18	; 0x12
    557c:	8b 89       	ldd	r24, Y+19	; 0x13
    557e:	9c 89       	ldd	r25, Y+20	; 0x14
    5580:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    5584:	dc 01       	movw	r26, r24
    5586:	cb 01       	movw	r24, r22
    5588:	88 8b       	std	Y+16, r24	; 0x10
    558a:	88 89       	ldd	r24, Y+16	; 0x10
    558c:	89 83       	std	Y+1, r24	; 0x01
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    558e:	89 81       	ldd	r24, Y+1	; 0x01
    5590:	8a 95       	dec	r24
    5592:	f1 f7       	brne	.-4      	; 0x5590 <LCD_SendCMD+0x1d2>
    5594:	89 83       	std	Y+1, r24	; 0x01
	/* delay 40 us */
	_delay_us(40);
}
    5596:	69 96       	adiw	r28, 0x19	; 25
    5598:	0f b6       	in	r0, 0x3f	; 63
    559a:	f8 94       	cli
    559c:	de bf       	out	0x3e, r29	; 62
    559e:	0f be       	out	0x3f, r0	; 63
    55a0:	cd bf       	out	0x3d, r28	; 61
    55a2:	cf 91       	pop	r28
    55a4:	df 91       	pop	r29
    55a6:	08 95       	ret

000055a8 <LCD_SendData>:
static void LCD_SendData(u8 u8Data){
    55a8:	df 93       	push	r29
    55aa:	cf 93       	push	r28
    55ac:	cd b7       	in	r28, 0x3d	; 61
    55ae:	de b7       	in	r29, 0x3e	; 62
    55b0:	69 97       	sbiw	r28, 0x19	; 25
    55b2:	0f b6       	in	r0, 0x3f	; 63
    55b4:	f8 94       	cli
    55b6:	de bf       	out	0x3e, r29	; 62
    55b8:	0f be       	out	0x3f, r0	; 63
    55ba:	cd bf       	out	0x3d, r28	; 61
    55bc:	89 8f       	std	Y+25, r24	; 0x19
	/* RS = 1 */
	setBit(LCD_CTRL_PORT, LCD_RS_PIN);
    55be:	a8 e3       	ldi	r26, 0x38	; 56
    55c0:	b0 e0       	ldi	r27, 0x00	; 0
    55c2:	e8 e3       	ldi	r30, 0x38	; 56
    55c4:	f0 e0       	ldi	r31, 0x00	; 0
    55c6:	80 81       	ld	r24, Z
    55c8:	82 60       	ori	r24, 0x02	; 2
    55ca:	8c 93       	st	X, r24
	/* upload most 4 bits and then latch */
	LCD_DATA_REG.HN = (u8Data>>4);
    55cc:	e5 e3       	ldi	r30, 0x35	; 53
    55ce:	f0 e0       	ldi	r31, 0x00	; 0
    55d0:	89 8d       	ldd	r24, Y+25	; 0x19
    55d2:	82 95       	swap	r24
    55d4:	8f 70       	andi	r24, 0x0F	; 15
    55d6:	8f 70       	andi	r24, 0x0F	; 15
    55d8:	98 2f       	mov	r25, r24
    55da:	92 95       	swap	r25
    55dc:	90 7f       	andi	r25, 0xF0	; 240
    55de:	80 81       	ld	r24, Z
    55e0:	8f 70       	andi	r24, 0x0F	; 15
    55e2:	89 2b       	or	r24, r25
    55e4:	80 83       	st	Z, r24
	LCD_Latch();
    55e6:	0e 94 e1 2b 	call	0x57c2	; 0x57c2 <LCD_Latch>
	/* upload least 4 bits and then latch */
	LCD_DATA_REG.HN = u8Data;
    55ea:	e5 e3       	ldi	r30, 0x35	; 53
    55ec:	f0 e0       	ldi	r31, 0x00	; 0
    55ee:	89 8d       	ldd	r24, Y+25	; 0x19
    55f0:	8f 70       	andi	r24, 0x0F	; 15
    55f2:	98 2f       	mov	r25, r24
    55f4:	92 95       	swap	r25
    55f6:	90 7f       	andi	r25, 0xF0	; 240
    55f8:	80 81       	ld	r24, Z
    55fa:	8f 70       	andi	r24, 0x0F	; 15
    55fc:	89 2b       	or	r24, r25
    55fe:	80 83       	st	Z, r24
	LCD_Latch();
    5600:	0e 94 e1 2b 	call	0x57c2	; 0x57c2 <LCD_Latch>
    5604:	80 e0       	ldi	r24, 0x00	; 0
    5606:	90 e0       	ldi	r25, 0x00	; 0
    5608:	a0 e2       	ldi	r26, 0x20	; 32
    560a:	b2 e4       	ldi	r27, 0x42	; 66
    560c:	8d 8b       	std	Y+21, r24	; 0x15
    560e:	9e 8b       	std	Y+22, r25	; 0x16
    5610:	af 8b       	std	Y+23, r26	; 0x17
    5612:	b8 8f       	std	Y+24, r27	; 0x18
 */
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
    5614:	6d 89       	ldd	r22, Y+21	; 0x15
    5616:	7e 89       	ldd	r23, Y+22	; 0x16
    5618:	8f 89       	ldd	r24, Y+23	; 0x17
    561a:	98 8d       	ldd	r25, Y+24	; 0x18
    561c:	2b ea       	ldi	r18, 0xAB	; 171
    561e:	3a ea       	ldi	r19, 0xAA	; 170
    5620:	4a e2       	ldi	r20, 0x2A	; 42
    5622:	50 e4       	ldi	r21, 0x40	; 64
    5624:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    5628:	dc 01       	movw	r26, r24
    562a:	cb 01       	movw	r24, r22
    562c:	89 8b       	std	Y+17, r24	; 0x11
    562e:	9a 8b       	std	Y+18, r25	; 0x12
    5630:	ab 8b       	std	Y+19, r26	; 0x13
    5632:	bc 8b       	std	Y+20, r27	; 0x14
	if (__tmp < 1.0)
    5634:	69 89       	ldd	r22, Y+17	; 0x11
    5636:	7a 89       	ldd	r23, Y+18	; 0x12
    5638:	8b 89       	ldd	r24, Y+19	; 0x13
    563a:	9c 89       	ldd	r25, Y+20	; 0x14
    563c:	20 e0       	ldi	r18, 0x00	; 0
    563e:	30 e0       	ldi	r19, 0x00	; 0
    5640:	40 e8       	ldi	r20, 0x80	; 128
    5642:	5f e3       	ldi	r21, 0x3F	; 63
    5644:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    5648:	88 23       	and	r24, r24
    564a:	1c f4       	brge	.+6      	; 0x5652 <LCD_SendData+0xaa>
		__ticks = 1;
    564c:	81 e0       	ldi	r24, 0x01	; 1
    564e:	88 8b       	std	Y+16, r24	; 0x10
    5650:	91 c0       	rjmp	.+290    	; 0x5774 <LCD_SendData+0x1cc>
	else if (__tmp > 255)
    5652:	69 89       	ldd	r22, Y+17	; 0x11
    5654:	7a 89       	ldd	r23, Y+18	; 0x12
    5656:	8b 89       	ldd	r24, Y+19	; 0x13
    5658:	9c 89       	ldd	r25, Y+20	; 0x14
    565a:	20 e0       	ldi	r18, 0x00	; 0
    565c:	30 e0       	ldi	r19, 0x00	; 0
    565e:	4f e7       	ldi	r20, 0x7F	; 127
    5660:	53 e4       	ldi	r21, 0x43	; 67
    5662:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    5666:	18 16       	cp	r1, r24
    5668:	0c f0       	brlt	.+2      	; 0x566c <LCD_SendData+0xc4>
    566a:	7b c0       	rjmp	.+246    	; 0x5762 <LCD_SendData+0x1ba>
	{
		_delay_ms(__us / 1000.0);
    566c:	6d 89       	ldd	r22, Y+21	; 0x15
    566e:	7e 89       	ldd	r23, Y+22	; 0x16
    5670:	8f 89       	ldd	r24, Y+23	; 0x17
    5672:	98 8d       	ldd	r25, Y+24	; 0x18
    5674:	20 e0       	ldi	r18, 0x00	; 0
    5676:	30 e0       	ldi	r19, 0x00	; 0
    5678:	4a e7       	ldi	r20, 0x7A	; 122
    567a:	54 e4       	ldi	r21, 0x44	; 68
    567c:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    5680:	dc 01       	movw	r26, r24
    5682:	cb 01       	movw	r24, r22
    5684:	8c 87       	std	Y+12, r24	; 0x0c
    5686:	9d 87       	std	Y+13, r25	; 0x0d
    5688:	ae 87       	std	Y+14, r26	; 0x0e
    568a:	bf 87       	std	Y+15, r27	; 0x0f
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    568c:	6c 85       	ldd	r22, Y+12	; 0x0c
    568e:	7d 85       	ldd	r23, Y+13	; 0x0d
    5690:	8e 85       	ldd	r24, Y+14	; 0x0e
    5692:	9f 85       	ldd	r25, Y+15	; 0x0f
    5694:	20 e0       	ldi	r18, 0x00	; 0
    5696:	30 e0       	ldi	r19, 0x00	; 0
    5698:	4a ef       	ldi	r20, 0xFA	; 250
    569a:	54 e4       	ldi	r21, 0x44	; 68
    569c:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    56a0:	dc 01       	movw	r26, r24
    56a2:	cb 01       	movw	r24, r22
    56a4:	88 87       	std	Y+8, r24	; 0x08
    56a6:	99 87       	std	Y+9, r25	; 0x09
    56a8:	aa 87       	std	Y+10, r26	; 0x0a
    56aa:	bb 87       	std	Y+11, r27	; 0x0b
	if (__tmp < 1.0)
    56ac:	68 85       	ldd	r22, Y+8	; 0x08
    56ae:	79 85       	ldd	r23, Y+9	; 0x09
    56b0:	8a 85       	ldd	r24, Y+10	; 0x0a
    56b2:	9b 85       	ldd	r25, Y+11	; 0x0b
    56b4:	20 e0       	ldi	r18, 0x00	; 0
    56b6:	30 e0       	ldi	r19, 0x00	; 0
    56b8:	40 e8       	ldi	r20, 0x80	; 128
    56ba:	5f e3       	ldi	r21, 0x3F	; 63
    56bc:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    56c0:	88 23       	and	r24, r24
    56c2:	2c f4       	brge	.+10     	; 0x56ce <LCD_SendData+0x126>
		__ticks = 1;
    56c4:	81 e0       	ldi	r24, 0x01	; 1
    56c6:	90 e0       	ldi	r25, 0x00	; 0
    56c8:	9f 83       	std	Y+7, r25	; 0x07
    56ca:	8e 83       	std	Y+6, r24	; 0x06
    56cc:	3f c0       	rjmp	.+126    	; 0x574c <LCD_SendData+0x1a4>
	else if (__tmp > 65535)
    56ce:	68 85       	ldd	r22, Y+8	; 0x08
    56d0:	79 85       	ldd	r23, Y+9	; 0x09
    56d2:	8a 85       	ldd	r24, Y+10	; 0x0a
    56d4:	9b 85       	ldd	r25, Y+11	; 0x0b
    56d6:	20 e0       	ldi	r18, 0x00	; 0
    56d8:	3f ef       	ldi	r19, 0xFF	; 255
    56da:	4f e7       	ldi	r20, 0x7F	; 127
    56dc:	57 e4       	ldi	r21, 0x47	; 71
    56de:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    56e2:	18 16       	cp	r1, r24
    56e4:	4c f5       	brge	.+82     	; 0x5738 <LCD_SendData+0x190>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    56e6:	6c 85       	ldd	r22, Y+12	; 0x0c
    56e8:	7d 85       	ldd	r23, Y+13	; 0x0d
    56ea:	8e 85       	ldd	r24, Y+14	; 0x0e
    56ec:	9f 85       	ldd	r25, Y+15	; 0x0f
    56ee:	20 e0       	ldi	r18, 0x00	; 0
    56f0:	30 e0       	ldi	r19, 0x00	; 0
    56f2:	40 e2       	ldi	r20, 0x20	; 32
    56f4:	51 e4       	ldi	r21, 0x41	; 65
    56f6:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    56fa:	dc 01       	movw	r26, r24
    56fc:	cb 01       	movw	r24, r22
    56fe:	bc 01       	movw	r22, r24
    5700:	cd 01       	movw	r24, r26
    5702:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    5706:	dc 01       	movw	r26, r24
    5708:	cb 01       	movw	r24, r22
    570a:	9f 83       	std	Y+7, r25	; 0x07
    570c:	8e 83       	std	Y+6, r24	; 0x06
    570e:	0f c0       	rjmp	.+30     	; 0x572e <LCD_SendData+0x186>
    5710:	88 ec       	ldi	r24, 0xC8	; 200
    5712:	90 e0       	ldi	r25, 0x00	; 0
    5714:	9d 83       	std	Y+5, r25	; 0x05
    5716:	8c 83       	std	Y+4, r24	; 0x04
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    5718:	8c 81       	ldd	r24, Y+4	; 0x04
    571a:	9d 81       	ldd	r25, Y+5	; 0x05
    571c:	01 97       	sbiw	r24, 0x01	; 1
    571e:	f1 f7       	brne	.-4      	; 0x571c <LCD_SendData+0x174>
    5720:	9d 83       	std	Y+5, r25	; 0x05
    5722:	8c 83       	std	Y+4, r24	; 0x04
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    5724:	8e 81       	ldd	r24, Y+6	; 0x06
    5726:	9f 81       	ldd	r25, Y+7	; 0x07
    5728:	01 97       	sbiw	r24, 0x01	; 1
    572a:	9f 83       	std	Y+7, r25	; 0x07
    572c:	8e 83       	std	Y+6, r24	; 0x06
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    572e:	8e 81       	ldd	r24, Y+6	; 0x06
    5730:	9f 81       	ldd	r25, Y+7	; 0x07
    5732:	00 97       	sbiw	r24, 0x00	; 0
    5734:	69 f7       	brne	.-38     	; 0x5710 <LCD_SendData+0x168>
    5736:	24 c0       	rjmp	.+72     	; 0x5780 <LCD_SendData+0x1d8>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    5738:	68 85       	ldd	r22, Y+8	; 0x08
    573a:	79 85       	ldd	r23, Y+9	; 0x09
    573c:	8a 85       	ldd	r24, Y+10	; 0x0a
    573e:	9b 85       	ldd	r25, Y+11	; 0x0b
    5740:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    5744:	dc 01       	movw	r26, r24
    5746:	cb 01       	movw	r24, r22
    5748:	9f 83       	std	Y+7, r25	; 0x07
    574a:	8e 83       	std	Y+6, r24	; 0x06
    574c:	8e 81       	ldd	r24, Y+6	; 0x06
    574e:	9f 81       	ldd	r25, Y+7	; 0x07
    5750:	9b 83       	std	Y+3, r25	; 0x03
    5752:	8a 83       	std	Y+2, r24	; 0x02
    5754:	8a 81       	ldd	r24, Y+2	; 0x02
    5756:	9b 81       	ldd	r25, Y+3	; 0x03
    5758:	01 97       	sbiw	r24, 0x01	; 1
    575a:	f1 f7       	brne	.-4      	; 0x5758 <LCD_SendData+0x1b0>
    575c:	9b 83       	std	Y+3, r25	; 0x03
    575e:	8a 83       	std	Y+2, r24	; 0x02
    5760:	0f c0       	rjmp	.+30     	; 0x5780 <LCD_SendData+0x1d8>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    5762:	69 89       	ldd	r22, Y+17	; 0x11
    5764:	7a 89       	ldd	r23, Y+18	; 0x12
    5766:	8b 89       	ldd	r24, Y+19	; 0x13
    5768:	9c 89       	ldd	r25, Y+20	; 0x14
    576a:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    576e:	dc 01       	movw	r26, r24
    5770:	cb 01       	movw	r24, r22
    5772:	88 8b       	std	Y+16, r24	; 0x10
    5774:	88 89       	ldd	r24, Y+16	; 0x10
    5776:	89 83       	std	Y+1, r24	; 0x01
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    5778:	89 81       	ldd	r24, Y+1	; 0x01
    577a:	8a 95       	dec	r24
    577c:	f1 f7       	brne	.-4      	; 0x577a <LCD_SendData+0x1d2>
    577e:	89 83       	std	Y+1, r24	; 0x01
	/* delay 40 us */
	_delay_us(40);
}
    5780:	69 96       	adiw	r28, 0x19	; 25
    5782:	0f b6       	in	r0, 0x3f	; 63
    5784:	f8 94       	cli
    5786:	de bf       	out	0x3e, r29	; 62
    5788:	0f be       	out	0x3f, r0	; 63
    578a:	cd bf       	out	0x3d, r28	; 61
    578c:	cf 91       	pop	r28
    578e:	df 91       	pop	r29
    5790:	08 95       	ret

00005792 <LCD_GoToXY>:
static void LCD_GoToXY(u8 row, u8 col){
    5792:	df 93       	push	r29
    5794:	cf 93       	push	r28
    5796:	00 d0       	rcall	.+0      	; 0x5798 <LCD_GoToXY+0x6>
    5798:	cd b7       	in	r28, 0x3d	; 61
    579a:	de b7       	in	r29, 0x3e	; 62
    579c:	89 83       	std	Y+1, r24	; 0x01
    579e:	6a 83       	std	Y+2, r22	; 0x02
	if (row == 1)
    57a0:	89 81       	ldd	r24, Y+1	; 0x01
    57a2:	81 30       	cpi	r24, 0x01	; 1
    57a4:	29 f4       	brne	.+10     	; 0x57b0 <LCD_GoToXY+0x1e>
	{
		LCD_SendCMD((0x00|0x80) + col -1);
    57a6:	8a 81       	ldd	r24, Y+2	; 0x02
    57a8:	81 58       	subi	r24, 0x81	; 129
    57aa:	0e 94 df 29 	call	0x53be	; 0x53be <LCD_SendCMD>
    57ae:	04 c0       	rjmp	.+8      	; 0x57b8 <LCD_GoToXY+0x26>
	}
	else
	{
		LCD_SendCMD((0x40|0x80) + col -1);
    57b0:	8a 81       	ldd	r24, Y+2	; 0x02
    57b2:	81 54       	subi	r24, 0x41	; 65
    57b4:	0e 94 df 29 	call	0x53be	; 0x53be <LCD_SendCMD>
	}
}
    57b8:	0f 90       	pop	r0
    57ba:	0f 90       	pop	r0
    57bc:	cf 91       	pop	r28
    57be:	df 91       	pop	r29
    57c0:	08 95       	ret

000057c2 <LCD_Latch>:
static void LCD_Latch(void){
    57c2:	df 93       	push	r29
    57c4:	cf 93       	push	r28
    57c6:	cd b7       	in	r28, 0x3d	; 61
    57c8:	de b7       	in	r29, 0x3e	; 62
	setBit(LCD_CTRL_PORT, LCD_EN_PIN);
    57ca:	a8 e3       	ldi	r26, 0x38	; 56
    57cc:	b0 e0       	ldi	r27, 0x00	; 0
    57ce:	e8 e3       	ldi	r30, 0x38	; 56
    57d0:	f0 e0       	ldi	r31, 0x00	; 0
    57d2:	80 81       	ld	r24, Z
    57d4:	81 60       	ori	r24, 0x01	; 1
    57d6:	8c 93       	st	X, r24
	clearBit(LCD_CTRL_PORT, LCD_EN_PIN);
    57d8:	a8 e3       	ldi	r26, 0x38	; 56
    57da:	b0 e0       	ldi	r27, 0x00	; 0
    57dc:	e8 e3       	ldi	r30, 0x38	; 56
    57de:	f0 e0       	ldi	r31, 0x00	; 0
    57e0:	80 81       	ld	r24, Z
    57e2:	8e 7f       	andi	r24, 0xFE	; 254
    57e4:	8c 93       	st	X, r24
}
    57e6:	cf 91       	pop	r28
    57e8:	df 91       	pop	r29
    57ea:	08 95       	ret

000057ec <LCD_DispInt>:
void LCD_DispInt(u32 data){
    57ec:	df 93       	push	r29
    57ee:	cf 93       	push	r28
    57f0:	cd b7       	in	r28, 0x3d	; 61
    57f2:	de b7       	in	r29, 0x3e	; 62
    57f4:	2f 97       	sbiw	r28, 0x0f	; 15
    57f6:	0f b6       	in	r0, 0x3f	; 63
    57f8:	f8 94       	cli
    57fa:	de bf       	out	0x3e, r29	; 62
    57fc:	0f be       	out	0x3f, r0	; 63
    57fe:	cd bf       	out	0x3d, r28	; 61
    5800:	6c 87       	std	Y+12, r22	; 0x0c
    5802:	7d 87       	std	Y+13, r23	; 0x0d
    5804:	8e 87       	std	Y+14, r24	; 0x0e
    5806:	9f 87       	std	Y+15, r25	; 0x0f
	u8 dataStr[11] = {0};
    5808:	8b e0       	ldi	r24, 0x0B	; 11
    580a:	fe 01       	movw	r30, r28
    580c:	31 96       	adiw	r30, 0x01	; 1
    580e:	df 01       	movw	r26, r30
    5810:	98 2f       	mov	r25, r24
    5812:	1d 92       	st	X+, r1
    5814:	9a 95       	dec	r25
    5816:	e9 f7       	brne	.-6      	; 0x5812 <LCD_DispInt+0x26>
	itoa(data,dataStr,10);
    5818:	8c 85       	ldd	r24, Y+12	; 0x0c
    581a:	9d 85       	ldd	r25, Y+13	; 0x0d
    581c:	9e 01       	movw	r18, r28
    581e:	2f 5f       	subi	r18, 0xFF	; 255
    5820:	3f 4f       	sbci	r19, 0xFF	; 255
    5822:	b9 01       	movw	r22, r18
    5824:	4a e0       	ldi	r20, 0x0A	; 10
    5826:	50 e0       	ldi	r21, 0x00	; 0
    5828:	0e 94 ec 36 	call	0x6dd8	; 0x6dd8 <itoa>
	LCD_DispStr(dataStr);
    582c:	ce 01       	movw	r24, r28
    582e:	01 96       	adiw	r24, 0x01	; 1
    5830:	0e 94 87 29 	call	0x530e	; 0x530e <LCD_DispStr>
}
    5834:	2f 96       	adiw	r28, 0x0f	; 15
    5836:	0f b6       	in	r0, 0x3f	; 63
    5838:	f8 94       	cli
    583a:	de bf       	out	0x3e, r29	; 62
    583c:	0f be       	out	0x3f, r0	; 63
    583e:	cd bf       	out	0x3d, r28	; 61
    5840:	cf 91       	pop	r28
    5842:	df 91       	pop	r29
    5844:	08 95       	ret

00005846 <LCD_DispIntXY>:
void LCD_DispIntXY(u8 row, u8 col, u32 data){
    5846:	df 93       	push	r29
    5848:	cf 93       	push	r28
    584a:	00 d0       	rcall	.+0      	; 0x584c <LCD_DispIntXY+0x6>
    584c:	00 d0       	rcall	.+0      	; 0x584e <LCD_DispIntXY+0x8>
    584e:	00 d0       	rcall	.+0      	; 0x5850 <LCD_DispIntXY+0xa>
    5850:	cd b7       	in	r28, 0x3d	; 61
    5852:	de b7       	in	r29, 0x3e	; 62
    5854:	89 83       	std	Y+1, r24	; 0x01
    5856:	6a 83       	std	Y+2, r22	; 0x02
    5858:	2b 83       	std	Y+3, r18	; 0x03
    585a:	3c 83       	std	Y+4, r19	; 0x04
    585c:	4d 83       	std	Y+5, r20	; 0x05
    585e:	5e 83       	std	Y+6, r21	; 0x06
	LCD_GoToXY(row,col);
    5860:	89 81       	ldd	r24, Y+1	; 0x01
    5862:	6a 81       	ldd	r22, Y+2	; 0x02
    5864:	0e 94 c9 2b 	call	0x5792	; 0x5792 <LCD_GoToXY>
	LCD_DispInt(data);
    5868:	8b 81       	ldd	r24, Y+3	; 0x03
    586a:	9c 81       	ldd	r25, Y+4	; 0x04
    586c:	ad 81       	ldd	r26, Y+5	; 0x05
    586e:	be 81       	ldd	r27, Y+6	; 0x06
    5870:	bc 01       	movw	r22, r24
    5872:	cd 01       	movw	r24, r26
    5874:	0e 94 f6 2b 	call	0x57ec	; 0x57ec <LCD_DispInt>
}
    5878:	26 96       	adiw	r28, 0x06	; 6
    587a:	0f b6       	in	r0, 0x3f	; 63
    587c:	f8 94       	cli
    587e:	de bf       	out	0x3e, r29	; 62
    5880:	0f be       	out	0x3f, r0	; 63
    5882:	cd bf       	out	0x3d, r28	; 61
    5884:	cf 91       	pop	r28
    5886:	df 91       	pop	r29
    5888:	08 95       	ret

0000588a <SPI_Init>:
*
* Created: 7/15/2021 10:43:40 AM
*  Author: MahmoudH
*/
#include "SPI.h"
void	SPI_Init(SPI_Mode mode){
    588a:	df 93       	push	r29
    588c:	cf 93       	push	r28
    588e:	00 d0       	rcall	.+0      	; 0x5890 <SPI_Init+0x6>
    5890:	0f 92       	push	r0
    5892:	cd b7       	in	r28, 0x3d	; 61
    5894:	de b7       	in	r29, 0x3e	; 62
    5896:	89 83       	std	Y+1, r24	; 0x01
	/*
	1- if Master -> set MOSI, SCK, SS outpus and set MSTR
	2- if Slave ->  set MISO outpus and Clear MSTR
	3- Enable SPI
	*/
	switch (mode)
    5898:	89 81       	ldd	r24, Y+1	; 0x01
    589a:	28 2f       	mov	r18, r24
    589c:	30 e0       	ldi	r19, 0x00	; 0
    589e:	3b 83       	std	Y+3, r19	; 0x03
    58a0:	2a 83       	std	Y+2, r18	; 0x02
    58a2:	8a 81       	ldd	r24, Y+2	; 0x02
    58a4:	9b 81       	ldd	r25, Y+3	; 0x03
    58a6:	00 97       	sbiw	r24, 0x00	; 0
    58a8:	d9 f0       	breq	.+54     	; 0x58e0 <SPI_Init+0x56>
    58aa:	2a 81       	ldd	r18, Y+2	; 0x02
    58ac:	3b 81       	ldd	r19, Y+3	; 0x03
    58ae:	21 30       	cpi	r18, 0x01	; 1
    58b0:	31 05       	cpc	r19, r1
    58b2:	59 f5       	brne	.+86     	; 0x590a <SPI_Init+0x80>
	{
		case SPI_MASTER:
		setBits(SPI_DDR, ((1<<SPI_MOSI)|(1<<SPI_SCK)|(1<<SPI_SS)));
    58b4:	a7 e3       	ldi	r26, 0x37	; 55
    58b6:	b0 e0       	ldi	r27, 0x00	; 0
    58b8:	e7 e3       	ldi	r30, 0x37	; 55
    58ba:	f0 e0       	ldi	r31, 0x00	; 0
    58bc:	80 81       	ld	r24, Z
    58be:	80 6b       	ori	r24, 0xB0	; 176
    58c0:	8c 93       	st	X, r24
		clearBit(SPI_DDR, SPI_MISO);		
    58c2:	a7 e3       	ldi	r26, 0x37	; 55
    58c4:	b0 e0       	ldi	r27, 0x00	; 0
    58c6:	e7 e3       	ldi	r30, 0x37	; 55
    58c8:	f0 e0       	ldi	r31, 0x00	; 0
    58ca:	80 81       	ld	r24, Z
    58cc:	8f 7b       	andi	r24, 0xBF	; 191
    58ce:	8c 93       	st	X, r24
		setBit(SPCR, MSTR);
    58d0:	ad e2       	ldi	r26, 0x2D	; 45
    58d2:	b0 e0       	ldi	r27, 0x00	; 0
    58d4:	ed e2       	ldi	r30, 0x2D	; 45
    58d6:	f0 e0       	ldi	r31, 0x00	; 0
    58d8:	80 81       	ld	r24, Z
    58da:	80 61       	ori	r24, 0x10	; 16
    58dc:	8c 93       	st	X, r24
    58de:	15 c0       	rjmp	.+42     	; 0x590a <SPI_Init+0x80>
		break;
		case SPI_SLAVE:
		clearBits(SPI_DDR, ((1<<SPI_MOSI)|(1<<SPI_SCK)|(1<<SPI_SS)));
    58e0:	a7 e3       	ldi	r26, 0x37	; 55
    58e2:	b0 e0       	ldi	r27, 0x00	; 0
    58e4:	e7 e3       	ldi	r30, 0x37	; 55
    58e6:	f0 e0       	ldi	r31, 0x00	; 0
    58e8:	80 81       	ld	r24, Z
    58ea:	8f 74       	andi	r24, 0x4F	; 79
    58ec:	8c 93       	st	X, r24
		setBit(SPI_DDR, SPI_MISO);
    58ee:	a7 e3       	ldi	r26, 0x37	; 55
    58f0:	b0 e0       	ldi	r27, 0x00	; 0
    58f2:	e7 e3       	ldi	r30, 0x37	; 55
    58f4:	f0 e0       	ldi	r31, 0x00	; 0
    58f6:	80 81       	ld	r24, Z
    58f8:	80 64       	ori	r24, 0x40	; 64
    58fa:	8c 93       	st	X, r24
		clearBit(SPCR, MSTR);
    58fc:	ad e2       	ldi	r26, 0x2D	; 45
    58fe:	b0 e0       	ldi	r27, 0x00	; 0
    5900:	ed e2       	ldi	r30, 0x2D	; 45
    5902:	f0 e0       	ldi	r31, 0x00	; 0
    5904:	80 81       	ld	r24, Z
    5906:	8f 7e       	andi	r24, 0xEF	; 239
    5908:	8c 93       	st	X, r24
		break;
	}
	setBit(SPCR, SPE);
    590a:	ad e2       	ldi	r26, 0x2D	; 45
    590c:	b0 e0       	ldi	r27, 0x00	; 0
    590e:	ed e2       	ldi	r30, 0x2D	; 45
    5910:	f0 e0       	ldi	r31, 0x00	; 0
    5912:	80 81       	ld	r24, Z
    5914:	80 64       	ori	r24, 0x40	; 64
    5916:	8c 93       	st	X, r24
}
    5918:	0f 90       	pop	r0
    591a:	0f 90       	pop	r0
    591c:	0f 90       	pop	r0
    591e:	cf 91       	pop	r28
    5920:	df 91       	pop	r29
    5922:	08 95       	ret

00005924 <SPI_Transceve>:
u8		SPI_Transceve(u8 data){
    5924:	df 93       	push	r29
    5926:	cf 93       	push	r28
    5928:	0f 92       	push	r0
    592a:	cd b7       	in	r28, 0x3d	; 61
    592c:	de b7       	in	r29, 0x3e	; 62
    592e:	89 83       	std	Y+1, r24	; 0x01
	/*
	1- Write DR
	2- Wait shift complete flag
	3- Return DR
	*/
	SPDR = data;
    5930:	ef e2       	ldi	r30, 0x2F	; 47
    5932:	f0 e0       	ldi	r31, 0x00	; 0
    5934:	89 81       	ldd	r24, Y+1	; 0x01
    5936:	80 83       	st	Z, r24
	while(!(SPSR&(1<<SPIF)));
    5938:	ee e2       	ldi	r30, 0x2E	; 46
    593a:	f0 e0       	ldi	r31, 0x00	; 0
    593c:	80 81       	ld	r24, Z
    593e:	88 23       	and	r24, r24
    5940:	dc f7       	brge	.-10     	; 0x5938 <SPI_Transceve+0x14>
	return SPDR;
    5942:	ef e2       	ldi	r30, 0x2F	; 47
    5944:	f0 e0       	ldi	r31, 0x00	; 0
    5946:	80 81       	ld	r24, Z
    5948:	0f 90       	pop	r0
    594a:	cf 91       	pop	r28
    594c:	df 91       	pop	r29
    594e:	08 95       	ret

00005950 <TWI_Init>:
#include "TWI.h"

static void TWI_Wait(void);


void TWI_Init(u32 scl){
    5950:	0f 93       	push	r16
    5952:	1f 93       	push	r17
    5954:	df 93       	push	r29
    5956:	cf 93       	push	r28
    5958:	00 d0       	rcall	.+0      	; 0x595a <TWI_Init+0xa>
    595a:	00 d0       	rcall	.+0      	; 0x595c <TWI_Init+0xc>
    595c:	cd b7       	in	r28, 0x3d	; 61
    595e:	de b7       	in	r29, 0x3e	; 62
    5960:	69 83       	std	Y+1, r22	; 0x01
    5962:	7a 83       	std	Y+2, r23	; 0x02
    5964:	8b 83       	std	Y+3, r24	; 0x03
    5966:	9c 83       	std	Y+4, r25	; 0x04
	TWBR = ((F_CPU/scl) - 16)/2;
    5968:	00 e2       	ldi	r16, 0x20	; 32
    596a:	10 e0       	ldi	r17, 0x00	; 0
    596c:	80 e0       	ldi	r24, 0x00	; 0
    596e:	92 e1       	ldi	r25, 0x12	; 18
    5970:	aa e7       	ldi	r26, 0x7A	; 122
    5972:	b0 e0       	ldi	r27, 0x00	; 0
    5974:	29 81       	ldd	r18, Y+1	; 0x01
    5976:	3a 81       	ldd	r19, Y+2	; 0x02
    5978:	4b 81       	ldd	r20, Y+3	; 0x03
    597a:	5c 81       	ldd	r21, Y+4	; 0x04
    597c:	bc 01       	movw	r22, r24
    597e:	cd 01       	movw	r24, r26
    5980:	0e 94 6f 36 	call	0x6cde	; 0x6cde <__udivmodsi4>
    5984:	da 01       	movw	r26, r20
    5986:	c9 01       	movw	r24, r18
    5988:	40 97       	sbiw	r24, 0x10	; 16
    598a:	a1 09       	sbc	r26, r1
    598c:	b1 09       	sbc	r27, r1
    598e:	b6 95       	lsr	r27
    5990:	a7 95       	ror	r26
    5992:	97 95       	ror	r25
    5994:	87 95       	ror	r24
    5996:	f8 01       	movw	r30, r16
    5998:	80 83       	st	Z, r24
	TWCR |= (1<<TWEN);
    599a:	a6 e5       	ldi	r26, 0x56	; 86
    599c:	b0 e0       	ldi	r27, 0x00	; 0
    599e:	e6 e5       	ldi	r30, 0x56	; 86
    59a0:	f0 e0       	ldi	r31, 0x00	; 0
    59a2:	80 81       	ld	r24, Z
    59a4:	84 60       	ori	r24, 0x04	; 4
    59a6:	8c 93       	st	X, r24
}
    59a8:	0f 90       	pop	r0
    59aa:	0f 90       	pop	r0
    59ac:	0f 90       	pop	r0
    59ae:	0f 90       	pop	r0
    59b0:	cf 91       	pop	r28
    59b2:	df 91       	pop	r29
    59b4:	1f 91       	pop	r17
    59b6:	0f 91       	pop	r16
    59b8:	08 95       	ret

000059ba <TWI_Start>:
Bool TWI_Start(void){
    59ba:	df 93       	push	r29
    59bc:	cf 93       	push	r28
    59be:	0f 92       	push	r0
    59c0:	cd b7       	in	r28, 0x3d	; 61
    59c2:	de b7       	in	r29, 0x3e	; 62
	Bool result = FALSE;
    59c4:	19 82       	std	Y+1, r1	; 0x01
	TWCR = (1<<TWINT)|(1<<TWSTA)|(1<<TWEN);
    59c6:	e6 e5       	ldi	r30, 0x56	; 86
    59c8:	f0 e0       	ldi	r31, 0x00	; 0
    59ca:	84 ea       	ldi	r24, 0xA4	; 164
    59cc:	80 83       	st	Z, r24
	TWI_Wait();
    59ce:	0e 94 22 2d 	call	0x5a44	; 0x5a44 <TWI_Wait>
	if((TWSR&0xF8) == SC_START){
    59d2:	e1 e2       	ldi	r30, 0x21	; 33
    59d4:	f0 e0       	ldi	r31, 0x00	; 0
    59d6:	80 81       	ld	r24, Z
    59d8:	88 2f       	mov	r24, r24
    59da:	90 e0       	ldi	r25, 0x00	; 0
    59dc:	88 7f       	andi	r24, 0xF8	; 248
    59de:	90 70       	andi	r25, 0x00	; 0
    59e0:	88 30       	cpi	r24, 0x08	; 8
    59e2:	91 05       	cpc	r25, r1
    59e4:	11 f4       	brne	.+4      	; 0x59ea <TWI_Start+0x30>
		result = TRUE;
    59e6:	81 e0       	ldi	r24, 0x01	; 1
    59e8:	89 83       	std	Y+1, r24	; 0x01
	}
	return result;
    59ea:	89 81       	ldd	r24, Y+1	; 0x01
}
    59ec:	0f 90       	pop	r0
    59ee:	cf 91       	pop	r28
    59f0:	df 91       	pop	r29
    59f2:	08 95       	ret

000059f4 <TWI_Restart>:
Bool TWI_Restart(void){
    59f4:	df 93       	push	r29
    59f6:	cf 93       	push	r28
    59f8:	0f 92       	push	r0
    59fa:	cd b7       	in	r28, 0x3d	; 61
    59fc:	de b7       	in	r29, 0x3e	; 62
	Bool result = FALSE;
    59fe:	19 82       	std	Y+1, r1	; 0x01
	TWCR = (1<<TWINT)|(1<<TWSTA)|(1<<TWEN);
    5a00:	e6 e5       	ldi	r30, 0x56	; 86
    5a02:	f0 e0       	ldi	r31, 0x00	; 0
    5a04:	84 ea       	ldi	r24, 0xA4	; 164
    5a06:	80 83       	st	Z, r24
	TWI_Wait();
    5a08:	0e 94 22 2d 	call	0x5a44	; 0x5a44 <TWI_Wait>
	if((TWSR&0xF8) == SC_RESTART){
    5a0c:	e1 e2       	ldi	r30, 0x21	; 33
    5a0e:	f0 e0       	ldi	r31, 0x00	; 0
    5a10:	80 81       	ld	r24, Z
    5a12:	88 2f       	mov	r24, r24
    5a14:	90 e0       	ldi	r25, 0x00	; 0
    5a16:	88 7f       	andi	r24, 0xF8	; 248
    5a18:	90 70       	andi	r25, 0x00	; 0
    5a1a:	80 31       	cpi	r24, 0x10	; 16
    5a1c:	91 05       	cpc	r25, r1
    5a1e:	11 f4       	brne	.+4      	; 0x5a24 <TWI_Restart+0x30>
		result = TRUE;
    5a20:	81 e0       	ldi	r24, 0x01	; 1
    5a22:	89 83       	std	Y+1, r24	; 0x01
	}
	return result;	
    5a24:	89 81       	ldd	r24, Y+1	; 0x01
}
    5a26:	0f 90       	pop	r0
    5a28:	cf 91       	pop	r28
    5a2a:	df 91       	pop	r29
    5a2c:	08 95       	ret

00005a2e <TWI_Stop>:
void TWI_Stop(void){
    5a2e:	df 93       	push	r29
    5a30:	cf 93       	push	r28
    5a32:	cd b7       	in	r28, 0x3d	; 61
    5a34:	de b7       	in	r29, 0x3e	; 62
	TWCR = (1<<TWINT)|(1<<TWEN)|(1<<TWSTO);
    5a36:	e6 e5       	ldi	r30, 0x56	; 86
    5a38:	f0 e0       	ldi	r31, 0x00	; 0
    5a3a:	84 e9       	ldi	r24, 0x94	; 148
    5a3c:	80 83       	st	Z, r24
}
    5a3e:	cf 91       	pop	r28
    5a40:	df 91       	pop	r29
    5a42:	08 95       	ret

00005a44 <TWI_Wait>:
static void TWI_Wait(void){
    5a44:	df 93       	push	r29
    5a46:	cf 93       	push	r28
    5a48:	cd b7       	in	r28, 0x3d	; 61
    5a4a:	de b7       	in	r29, 0x3e	; 62
	while( !(TWCR&(1<<TWINT)) );
    5a4c:	e6 e5       	ldi	r30, 0x56	; 86
    5a4e:	f0 e0       	ldi	r31, 0x00	; 0
    5a50:	80 81       	ld	r24, Z
    5a52:	88 23       	and	r24, r24
    5a54:	dc f7       	brge	.-10     	; 0x5a4c <TWI_Wait+0x8>
}
    5a56:	cf 91       	pop	r28
    5a58:	df 91       	pop	r29
    5a5a:	08 95       	ret

00005a5c <TWI_Write>:

Bool TWI_Write(u8 u8Byte, u8 sCode){
    5a5c:	df 93       	push	r29
    5a5e:	cf 93       	push	r28
    5a60:	00 d0       	rcall	.+0      	; 0x5a62 <TWI_Write+0x6>
    5a62:	0f 92       	push	r0
    5a64:	cd b7       	in	r28, 0x3d	; 61
    5a66:	de b7       	in	r29, 0x3e	; 62
    5a68:	8a 83       	std	Y+2, r24	; 0x02
    5a6a:	6b 83       	std	Y+3, r22	; 0x03
	Bool result = FALSE;
    5a6c:	19 82       	std	Y+1, r1	; 0x01
	TWDR = u8Byte;
    5a6e:	e3 e2       	ldi	r30, 0x23	; 35
    5a70:	f0 e0       	ldi	r31, 0x00	; 0
    5a72:	8a 81       	ldd	r24, Y+2	; 0x02
    5a74:	80 83       	st	Z, r24
	TWCR = (1<<TWINT) | (1<<TWEN);
    5a76:	e6 e5       	ldi	r30, 0x56	; 86
    5a78:	f0 e0       	ldi	r31, 0x00	; 0
    5a7a:	84 e8       	ldi	r24, 0x84	; 132
    5a7c:	80 83       	st	Z, r24
	TWI_Wait();
    5a7e:	0e 94 22 2d 	call	0x5a44	; 0x5a44 <TWI_Wait>
	if((TWSR&0xF8) == sCode){
    5a82:	e1 e2       	ldi	r30, 0x21	; 33
    5a84:	f0 e0       	ldi	r31, 0x00	; 0
    5a86:	80 81       	ld	r24, Z
    5a88:	88 2f       	mov	r24, r24
    5a8a:	90 e0       	ldi	r25, 0x00	; 0
    5a8c:	9c 01       	movw	r18, r24
    5a8e:	28 7f       	andi	r18, 0xF8	; 248
    5a90:	30 70       	andi	r19, 0x00	; 0
    5a92:	8b 81       	ldd	r24, Y+3	; 0x03
    5a94:	88 2f       	mov	r24, r24
    5a96:	90 e0       	ldi	r25, 0x00	; 0
    5a98:	28 17       	cp	r18, r24
    5a9a:	39 07       	cpc	r19, r25
    5a9c:	11 f4       	brne	.+4      	; 0x5aa2 <TWI_Write+0x46>
		result = TRUE;
    5a9e:	81 e0       	ldi	r24, 0x01	; 1
    5aa0:	89 83       	std	Y+1, r24	; 0x01
	}
	return result;
    5aa2:	89 81       	ldd	r24, Y+1	; 0x01
}
    5aa4:	0f 90       	pop	r0
    5aa6:	0f 90       	pop	r0
    5aa8:	0f 90       	pop	r0
    5aaa:	cf 91       	pop	r28
    5aac:	df 91       	pop	r29
    5aae:	08 95       	ret

00005ab0 <TWI_Read>:
Bool TWI_Read(u8* pu8Byte, u8 sCode){
    5ab0:	df 93       	push	r29
    5ab2:	cf 93       	push	r28
    5ab4:	00 d0       	rcall	.+0      	; 0x5ab6 <TWI_Read+0x6>
    5ab6:	00 d0       	rcall	.+0      	; 0x5ab8 <TWI_Read+0x8>
    5ab8:	cd b7       	in	r28, 0x3d	; 61
    5aba:	de b7       	in	r29, 0x3e	; 62
    5abc:	9b 83       	std	Y+3, r25	; 0x03
    5abe:	8a 83       	std	Y+2, r24	; 0x02
    5ac0:	6c 83       	std	Y+4, r22	; 0x04
	Bool result = FALSE;
    5ac2:	19 82       	std	Y+1, r1	; 0x01
	TWCR = (1<<TWINT) | (1<<TWEN);
    5ac4:	e6 e5       	ldi	r30, 0x56	; 86
    5ac6:	f0 e0       	ldi	r31, 0x00	; 0
    5ac8:	84 e8       	ldi	r24, 0x84	; 132
    5aca:	80 83       	st	Z, r24
	if((TWSR&0xF8) == SC_MR_DATA_ACK){
    5acc:	e1 e2       	ldi	r30, 0x21	; 33
    5ace:	f0 e0       	ldi	r31, 0x00	; 0
    5ad0:	80 81       	ld	r24, Z
    5ad2:	88 2f       	mov	r24, r24
    5ad4:	90 e0       	ldi	r25, 0x00	; 0
    5ad6:	88 7f       	andi	r24, 0xF8	; 248
    5ad8:	90 70       	andi	r25, 0x00	; 0
    5ada:	80 35       	cpi	r24, 0x50	; 80
    5adc:	91 05       	cpc	r25, r1
    5ade:	39 f4       	brne	.+14     	; 0x5aee <TWI_Read+0x3e>
		TWCR |= (1<<TWEA);
    5ae0:	a6 e5       	ldi	r26, 0x56	; 86
    5ae2:	b0 e0       	ldi	r27, 0x00	; 0
    5ae4:	e6 e5       	ldi	r30, 0x56	; 86
    5ae6:	f0 e0       	ldi	r31, 0x00	; 0
    5ae8:	80 81       	ld	r24, Z
    5aea:	80 64       	ori	r24, 0x40	; 64
    5aec:	8c 93       	st	X, r24
	}
	TWI_Wait();
    5aee:	0e 94 22 2d 	call	0x5a44	; 0x5a44 <TWI_Wait>
	if((TWSR&0xF8) == sCode){
    5af2:	e1 e2       	ldi	r30, 0x21	; 33
    5af4:	f0 e0       	ldi	r31, 0x00	; 0
    5af6:	80 81       	ld	r24, Z
    5af8:	88 2f       	mov	r24, r24
    5afa:	90 e0       	ldi	r25, 0x00	; 0
    5afc:	9c 01       	movw	r18, r24
    5afe:	28 7f       	andi	r18, 0xF8	; 248
    5b00:	30 70       	andi	r19, 0x00	; 0
    5b02:	8c 81       	ldd	r24, Y+4	; 0x04
    5b04:	88 2f       	mov	r24, r24
    5b06:	90 e0       	ldi	r25, 0x00	; 0
    5b08:	28 17       	cp	r18, r24
    5b0a:	39 07       	cpc	r19, r25
    5b0c:	41 f4       	brne	.+16     	; 0x5b1e <TWI_Read+0x6e>
		(*pu8Byte) = TWDR;
    5b0e:	e3 e2       	ldi	r30, 0x23	; 35
    5b10:	f0 e0       	ldi	r31, 0x00	; 0
    5b12:	80 81       	ld	r24, Z
    5b14:	ea 81       	ldd	r30, Y+2	; 0x02
    5b16:	fb 81       	ldd	r31, Y+3	; 0x03
    5b18:	80 83       	st	Z, r24
		result = TRUE;
    5b1a:	81 e0       	ldi	r24, 0x01	; 1
    5b1c:	89 83       	std	Y+1, r24	; 0x01
	}
	return result;
    5b1e:	89 81       	ldd	r24, Y+1	; 0x01
    5b20:	0f 90       	pop	r0
    5b22:	0f 90       	pop	r0
    5b24:	0f 90       	pop	r0
    5b26:	0f 90       	pop	r0
    5b28:	cf 91       	pop	r28
    5b2a:	df 91       	pop	r29
    5b2c:	08 95       	ret

00005b2e <Key_Init>:
	{'1','2','3','-'},
	{'c','0','=','+'}
};


void	Key_Init(void){
    5b2e:	df 93       	push	r29
    5b30:	cf 93       	push	r28
    5b32:	cd b7       	in	r28, 0x3d	; 61
    5b34:	de b7       	in	r29, 0x3e	; 62
	/* Rows Out */
	setBits(KEY_ROWS_DDR,KEY_ROWS_MSK);
    5b36:	a4 e3       	ldi	r26, 0x34	; 52
    5b38:	b0 e0       	ldi	r27, 0x00	; 0
    5b3a:	e4 e3       	ldi	r30, 0x34	; 52
    5b3c:	f0 e0       	ldi	r31, 0x00	; 0
    5b3e:	80 81       	ld	r24, Z
    5b40:	8f 60       	ori	r24, 0x0F	; 15
    5b42:	8c 93       	st	X, r24
	/* Default deactivated */
	setBits(KEY_ROWS_PORT,KEY_ROWS_MSK);
    5b44:	a5 e3       	ldi	r26, 0x35	; 53
    5b46:	b0 e0       	ldi	r27, 0x00	; 0
    5b48:	e5 e3       	ldi	r30, 0x35	; 53
    5b4a:	f0 e0       	ldi	r31, 0x00	; 0
    5b4c:	80 81       	ld	r24, Z
    5b4e:	8f 60       	ori	r24, 0x0F	; 15
    5b50:	8c 93       	st	X, r24
	/* Cols In */
	clearBits(KEY_COLS_DDR,KEY_COLS_MSK);
    5b52:	a7 e3       	ldi	r26, 0x37	; 55
    5b54:	b0 e0       	ldi	r27, 0x00	; 0
    5b56:	e7 e3       	ldi	r30, 0x37	; 55
    5b58:	f0 e0       	ldi	r31, 0x00	; 0
    5b5a:	80 81       	ld	r24, Z
    5b5c:	8f 70       	andi	r24, 0x0F	; 15
    5b5e:	8c 93       	st	X, r24
	/* Cols Pullup */
	setBits(KEY_COLS_PORT,KEY_COLS_MSK);
    5b60:	a8 e3       	ldi	r26, 0x38	; 56
    5b62:	b0 e0       	ldi	r27, 0x00	; 0
    5b64:	e8 e3       	ldi	r30, 0x38	; 56
    5b66:	f0 e0       	ldi	r31, 0x00	; 0
    5b68:	80 81       	ld	r24, Z
    5b6a:	80 6f       	ori	r24, 0xF0	; 240
    5b6c:	8c 93       	st	X, r24
}
    5b6e:	cf 91       	pop	r28
    5b70:	df 91       	pop	r29
    5b72:	08 95       	ret

00005b74 <Key_GetKey>:
			 end 
			end
			deactivate this row
	end
*/
u8		Key_GetKey(void){
    5b74:	df 93       	push	r29
    5b76:	cf 93       	push	r28
    5b78:	cd b7       	in	r28, 0x3d	; 61
    5b7a:	de b7       	in	r29, 0x3e	; 62
    5b7c:	61 97       	sbiw	r28, 0x11	; 17
    5b7e:	0f b6       	in	r0, 0x3f	; 63
    5b80:	f8 94       	cli
    5b82:	de bf       	out	0x3e, r29	; 62
    5b84:	0f be       	out	0x3f, r0	; 63
    5b86:	cd bf       	out	0x3d, r28	; 61
	u8 row = 0;
    5b88:	18 8a       	std	Y+16, r1	; 0x10
	u8 col = 0;
    5b8a:	1f 86       	std	Y+15, r1	; 0x0f
	for (row = 0; row < 4; row++)
    5b8c:	18 8a       	std	Y+16, r1	; 0x10
    5b8e:	df c0       	rjmp	.+446    	; 0x5d4e <Key_GetKey+0x1da>
	{
		clearBit(KEY_ROWS_PORT, row);
    5b90:	a5 e3       	ldi	r26, 0x35	; 53
    5b92:	b0 e0       	ldi	r27, 0x00	; 0
    5b94:	e5 e3       	ldi	r30, 0x35	; 53
    5b96:	f0 e0       	ldi	r31, 0x00	; 0
    5b98:	80 81       	ld	r24, Z
    5b9a:	48 2f       	mov	r20, r24
    5b9c:	88 89       	ldd	r24, Y+16	; 0x10
    5b9e:	28 2f       	mov	r18, r24
    5ba0:	30 e0       	ldi	r19, 0x00	; 0
    5ba2:	81 e0       	ldi	r24, 0x01	; 1
    5ba4:	90 e0       	ldi	r25, 0x00	; 0
    5ba6:	02 c0       	rjmp	.+4      	; 0x5bac <Key_GetKey+0x38>
    5ba8:	88 0f       	add	r24, r24
    5baa:	99 1f       	adc	r25, r25
    5bac:	2a 95       	dec	r18
    5bae:	e2 f7       	brpl	.-8      	; 0x5ba8 <Key_GetKey+0x34>
    5bb0:	80 95       	com	r24
    5bb2:	84 23       	and	r24, r20
    5bb4:	8c 93       	st	X, r24
    5bb6:	80 e0       	ldi	r24, 0x00	; 0
    5bb8:	90 e0       	ldi	r25, 0x00	; 0
    5bba:	a0 e8       	ldi	r26, 0x80	; 128
    5bbc:	bf e3       	ldi	r27, 0x3F	; 63
    5bbe:	8b 87       	std	Y+11, r24	; 0x0b
    5bc0:	9c 87       	std	Y+12, r25	; 0x0c
    5bc2:	ad 87       	std	Y+13, r26	; 0x0d
    5bc4:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    5bc6:	6b 85       	ldd	r22, Y+11	; 0x0b
    5bc8:	7c 85       	ldd	r23, Y+12	; 0x0c
    5bca:	8d 85       	ldd	r24, Y+13	; 0x0d
    5bcc:	9e 85       	ldd	r25, Y+14	; 0x0e
    5bce:	20 e0       	ldi	r18, 0x00	; 0
    5bd0:	30 e0       	ldi	r19, 0x00	; 0
    5bd2:	4a ef       	ldi	r20, 0xFA	; 250
    5bd4:	54 e4       	ldi	r21, 0x44	; 68
    5bd6:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    5bda:	dc 01       	movw	r26, r24
    5bdc:	cb 01       	movw	r24, r22
    5bde:	8f 83       	std	Y+7, r24	; 0x07
    5be0:	98 87       	std	Y+8, r25	; 0x08
    5be2:	a9 87       	std	Y+9, r26	; 0x09
    5be4:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    5be6:	6f 81       	ldd	r22, Y+7	; 0x07
    5be8:	78 85       	ldd	r23, Y+8	; 0x08
    5bea:	89 85       	ldd	r24, Y+9	; 0x09
    5bec:	9a 85       	ldd	r25, Y+10	; 0x0a
    5bee:	20 e0       	ldi	r18, 0x00	; 0
    5bf0:	30 e0       	ldi	r19, 0x00	; 0
    5bf2:	40 e8       	ldi	r20, 0x80	; 128
    5bf4:	5f e3       	ldi	r21, 0x3F	; 63
    5bf6:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    5bfa:	88 23       	and	r24, r24
    5bfc:	2c f4       	brge	.+10     	; 0x5c08 <Key_GetKey+0x94>
		__ticks = 1;
    5bfe:	81 e0       	ldi	r24, 0x01	; 1
    5c00:	90 e0       	ldi	r25, 0x00	; 0
    5c02:	9e 83       	std	Y+6, r25	; 0x06
    5c04:	8d 83       	std	Y+5, r24	; 0x05
    5c06:	3f c0       	rjmp	.+126    	; 0x5c86 <Key_GetKey+0x112>
	else if (__tmp > 65535)
    5c08:	6f 81       	ldd	r22, Y+7	; 0x07
    5c0a:	78 85       	ldd	r23, Y+8	; 0x08
    5c0c:	89 85       	ldd	r24, Y+9	; 0x09
    5c0e:	9a 85       	ldd	r25, Y+10	; 0x0a
    5c10:	20 e0       	ldi	r18, 0x00	; 0
    5c12:	3f ef       	ldi	r19, 0xFF	; 255
    5c14:	4f e7       	ldi	r20, 0x7F	; 127
    5c16:	57 e4       	ldi	r21, 0x47	; 71
    5c18:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    5c1c:	18 16       	cp	r1, r24
    5c1e:	4c f5       	brge	.+82     	; 0x5c72 <Key_GetKey+0xfe>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    5c20:	6b 85       	ldd	r22, Y+11	; 0x0b
    5c22:	7c 85       	ldd	r23, Y+12	; 0x0c
    5c24:	8d 85       	ldd	r24, Y+13	; 0x0d
    5c26:	9e 85       	ldd	r25, Y+14	; 0x0e
    5c28:	20 e0       	ldi	r18, 0x00	; 0
    5c2a:	30 e0       	ldi	r19, 0x00	; 0
    5c2c:	40 e2       	ldi	r20, 0x20	; 32
    5c2e:	51 e4       	ldi	r21, 0x41	; 65
    5c30:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    5c34:	dc 01       	movw	r26, r24
    5c36:	cb 01       	movw	r24, r22
    5c38:	bc 01       	movw	r22, r24
    5c3a:	cd 01       	movw	r24, r26
    5c3c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    5c40:	dc 01       	movw	r26, r24
    5c42:	cb 01       	movw	r24, r22
    5c44:	9e 83       	std	Y+6, r25	; 0x06
    5c46:	8d 83       	std	Y+5, r24	; 0x05
    5c48:	0f c0       	rjmp	.+30     	; 0x5c68 <Key_GetKey+0xf4>
    5c4a:	88 ec       	ldi	r24, 0xC8	; 200
    5c4c:	90 e0       	ldi	r25, 0x00	; 0
    5c4e:	9c 83       	std	Y+4, r25	; 0x04
    5c50:	8b 83       	std	Y+3, r24	; 0x03
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    5c52:	8b 81       	ldd	r24, Y+3	; 0x03
    5c54:	9c 81       	ldd	r25, Y+4	; 0x04
    5c56:	01 97       	sbiw	r24, 0x01	; 1
    5c58:	f1 f7       	brne	.-4      	; 0x5c56 <Key_GetKey+0xe2>
    5c5a:	9c 83       	std	Y+4, r25	; 0x04
    5c5c:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    5c5e:	8d 81       	ldd	r24, Y+5	; 0x05
    5c60:	9e 81       	ldd	r25, Y+6	; 0x06
    5c62:	01 97       	sbiw	r24, 0x01	; 1
    5c64:	9e 83       	std	Y+6, r25	; 0x06
    5c66:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    5c68:	8d 81       	ldd	r24, Y+5	; 0x05
    5c6a:	9e 81       	ldd	r25, Y+6	; 0x06
    5c6c:	00 97       	sbiw	r24, 0x00	; 0
    5c6e:	69 f7       	brne	.-38     	; 0x5c4a <Key_GetKey+0xd6>
    5c70:	14 c0       	rjmp	.+40     	; 0x5c9a <Key_GetKey+0x126>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    5c72:	6f 81       	ldd	r22, Y+7	; 0x07
    5c74:	78 85       	ldd	r23, Y+8	; 0x08
    5c76:	89 85       	ldd	r24, Y+9	; 0x09
    5c78:	9a 85       	ldd	r25, Y+10	; 0x0a
    5c7a:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    5c7e:	dc 01       	movw	r26, r24
    5c80:	cb 01       	movw	r24, r22
    5c82:	9e 83       	std	Y+6, r25	; 0x06
    5c84:	8d 83       	std	Y+5, r24	; 0x05
    5c86:	8d 81       	ldd	r24, Y+5	; 0x05
    5c88:	9e 81       	ldd	r25, Y+6	; 0x06
    5c8a:	9a 83       	std	Y+2, r25	; 0x02
    5c8c:	89 83       	std	Y+1, r24	; 0x01
    5c8e:	89 81       	ldd	r24, Y+1	; 0x01
    5c90:	9a 81       	ldd	r25, Y+2	; 0x02
    5c92:	01 97       	sbiw	r24, 0x01	; 1
    5c94:	f1 f7       	brne	.-4      	; 0x5c92 <Key_GetKey+0x11e>
    5c96:	9a 83       	std	Y+2, r25	; 0x02
    5c98:	89 83       	std	Y+1, r24	; 0x01
		_delay_ms(1);
		for (col = 0; col < 4; col++)
    5c9a:	1f 86       	std	Y+15, r1	; 0x0f
    5c9c:	3e c0       	rjmp	.+124    	; 0x5d1a <Key_GetKey+0x1a6>
		{
			if(readBit(KEY_COLS_PINR,(col+KEY_COLS_START)) == 0){
    5c9e:	e6 e3       	ldi	r30, 0x36	; 54
    5ca0:	f0 e0       	ldi	r31, 0x00	; 0
    5ca2:	80 81       	ld	r24, Z
    5ca4:	28 2f       	mov	r18, r24
    5ca6:	30 e0       	ldi	r19, 0x00	; 0
    5ca8:	8f 85       	ldd	r24, Y+15	; 0x0f
    5caa:	88 2f       	mov	r24, r24
    5cac:	90 e0       	ldi	r25, 0x00	; 0
    5cae:	04 96       	adiw	r24, 0x04	; 4
    5cb0:	a9 01       	movw	r20, r18
    5cb2:	02 c0       	rjmp	.+4      	; 0x5cb8 <Key_GetKey+0x144>
    5cb4:	55 95       	asr	r21
    5cb6:	47 95       	ror	r20
    5cb8:	8a 95       	dec	r24
    5cba:	e2 f7       	brpl	.-8      	; 0x5cb4 <Key_GetKey+0x140>
    5cbc:	ca 01       	movw	r24, r20
    5cbe:	81 70       	andi	r24, 0x01	; 1
    5cc0:	90 70       	andi	r25, 0x00	; 0
    5cc2:	00 97       	sbiw	r24, 0x00	; 0
    5cc4:	39 f5       	brne	.+78     	; 0x5d14 <Key_GetKey+0x1a0>
				while(readBit(KEY_COLS_PINR,(col+KEY_COLS_START)) == 0);
    5cc6:	e6 e3       	ldi	r30, 0x36	; 54
    5cc8:	f0 e0       	ldi	r31, 0x00	; 0
    5cca:	80 81       	ld	r24, Z
    5ccc:	28 2f       	mov	r18, r24
    5cce:	30 e0       	ldi	r19, 0x00	; 0
    5cd0:	8f 85       	ldd	r24, Y+15	; 0x0f
    5cd2:	88 2f       	mov	r24, r24
    5cd4:	90 e0       	ldi	r25, 0x00	; 0
    5cd6:	04 96       	adiw	r24, 0x04	; 4
    5cd8:	a9 01       	movw	r20, r18
    5cda:	02 c0       	rjmp	.+4      	; 0x5ce0 <Key_GetKey+0x16c>
    5cdc:	55 95       	asr	r21
    5cde:	47 95       	ror	r20
    5ce0:	8a 95       	dec	r24
    5ce2:	e2 f7       	brpl	.-8      	; 0x5cdc <Key_GetKey+0x168>
    5ce4:	ca 01       	movw	r24, r20
    5ce6:	81 70       	andi	r24, 0x01	; 1
    5ce8:	90 70       	andi	r25, 0x00	; 0
    5cea:	00 97       	sbiw	r24, 0x00	; 0
    5cec:	61 f3       	breq	.-40     	; 0x5cc6 <Key_GetKey+0x152>
				return keys[row][col];
    5cee:	88 89       	ldd	r24, Y+16	; 0x10
    5cf0:	48 2f       	mov	r20, r24
    5cf2:	50 e0       	ldi	r21, 0x00	; 0
    5cf4:	8f 85       	ldd	r24, Y+15	; 0x0f
    5cf6:	28 2f       	mov	r18, r24
    5cf8:	30 e0       	ldi	r19, 0x00	; 0
    5cfa:	ca 01       	movw	r24, r20
    5cfc:	88 0f       	add	r24, r24
    5cfe:	99 1f       	adc	r25, r25
    5d00:	88 0f       	add	r24, r24
    5d02:	99 1f       	adc	r25, r25
    5d04:	82 0f       	add	r24, r18
    5d06:	93 1f       	adc	r25, r19
    5d08:	fc 01       	movw	r30, r24
    5d0a:	e3 51       	subi	r30, 0x13	; 19
    5d0c:	fe 4f       	sbci	r31, 0xFE	; 254
    5d0e:	50 81       	ld	r21, Z
    5d10:	59 8b       	std	Y+17, r21	; 0x11
    5d12:	22 c0       	rjmp	.+68     	; 0x5d58 <Key_GetKey+0x1e4>
	u8 col = 0;
	for (row = 0; row < 4; row++)
	{
		clearBit(KEY_ROWS_PORT, row);
		_delay_ms(1);
		for (col = 0; col < 4; col++)
    5d14:	8f 85       	ldd	r24, Y+15	; 0x0f
    5d16:	8f 5f       	subi	r24, 0xFF	; 255
    5d18:	8f 87       	std	Y+15, r24	; 0x0f
    5d1a:	8f 85       	ldd	r24, Y+15	; 0x0f
    5d1c:	84 30       	cpi	r24, 0x04	; 4
    5d1e:	08 f4       	brcc	.+2      	; 0x5d22 <Key_GetKey+0x1ae>
    5d20:	be cf       	rjmp	.-132    	; 0x5c9e <Key_GetKey+0x12a>
			if(readBit(KEY_COLS_PINR,(col+KEY_COLS_START)) == 0){
				while(readBit(KEY_COLS_PINR,(col+KEY_COLS_START)) == 0);
				return keys[row][col];
			}
		}
		setBit(KEY_ROWS_PORT, row);
    5d22:	a5 e3       	ldi	r26, 0x35	; 53
    5d24:	b0 e0       	ldi	r27, 0x00	; 0
    5d26:	e5 e3       	ldi	r30, 0x35	; 53
    5d28:	f0 e0       	ldi	r31, 0x00	; 0
    5d2a:	80 81       	ld	r24, Z
    5d2c:	48 2f       	mov	r20, r24
    5d2e:	88 89       	ldd	r24, Y+16	; 0x10
    5d30:	28 2f       	mov	r18, r24
    5d32:	30 e0       	ldi	r19, 0x00	; 0
    5d34:	81 e0       	ldi	r24, 0x01	; 1
    5d36:	90 e0       	ldi	r25, 0x00	; 0
    5d38:	02 2e       	mov	r0, r18
    5d3a:	02 c0       	rjmp	.+4      	; 0x5d40 <Key_GetKey+0x1cc>
    5d3c:	88 0f       	add	r24, r24
    5d3e:	99 1f       	adc	r25, r25
    5d40:	0a 94       	dec	r0
    5d42:	e2 f7       	brpl	.-8      	; 0x5d3c <Key_GetKey+0x1c8>
    5d44:	84 2b       	or	r24, r20
    5d46:	8c 93       	st	X, r24
	end
*/
u8		Key_GetKey(void){
	u8 row = 0;
	u8 col = 0;
	for (row = 0; row < 4; row++)
    5d48:	88 89       	ldd	r24, Y+16	; 0x10
    5d4a:	8f 5f       	subi	r24, 0xFF	; 255
    5d4c:	88 8b       	std	Y+16, r24	; 0x10
    5d4e:	88 89       	ldd	r24, Y+16	; 0x10
    5d50:	84 30       	cpi	r24, 0x04	; 4
    5d52:	08 f4       	brcc	.+2      	; 0x5d56 <Key_GetKey+0x1e2>
    5d54:	1d cf       	rjmp	.-454    	; 0x5b90 <Key_GetKey+0x1c>
				return keys[row][col];
			}
		}
		setBit(KEY_ROWS_PORT, row);
	}
	return 0;
    5d56:	19 8a       	std	Y+17, r1	; 0x11
    5d58:	89 89       	ldd	r24, Y+17	; 0x11
}
    5d5a:	61 96       	adiw	r28, 0x11	; 17
    5d5c:	0f b6       	in	r0, 0x3f	; 63
    5d5e:	f8 94       	cli
    5d60:	de bf       	out	0x3e, r29	; 62
    5d62:	0f be       	out	0x3f, r0	; 63
    5d64:	cd bf       	out	0x3d, r28	; 61
    5d66:	cf 91       	pop	r28
    5d68:	df 91       	pop	r29
    5d6a:	08 95       	ret

00005d6c <Seg_Init>:
	NUM_0, NUM_1, NUM_2, NUM_3,
	NUM_4, NUM_5, NUM_6, NUM_7,
	NUM_8, NUM_9, NUM_DOT
};

void Seg_Init(void){
    5d6c:	df 93       	push	r29
    5d6e:	cf 93       	push	r28
    5d70:	cd b7       	in	r28, 0x3d	; 61
    5d72:	de b7       	in	r29, 0x3e	; 62
	/* Out */
	setAllBits(SEG_DATA_DDR);
    5d74:	e7 e3       	ldi	r30, 0x37	; 55
    5d76:	f0 e0       	ldi	r31, 0x00	; 0
    5d78:	8f ef       	ldi	r24, 0xFF	; 255
    5d7a:	80 83       	st	Z, r24
	setBits(SEG_DIG_DDR,SEG_DIG_MSK);
    5d7c:	a4 e3       	ldi	r26, 0x34	; 52
    5d7e:	b0 e0       	ldi	r27, 0x00	; 0
    5d80:	e4 e3       	ldi	r30, 0x34	; 52
    5d82:	f0 e0       	ldi	r31, 0x00	; 0
    5d84:	80 81       	ld	r24, Z
    5d86:	80 6f       	ori	r24, 0xF0	; 240
    5d88:	8c 93       	st	X, r24
	/* Default */
	setAllBits(SEG_DATA_PORT);
    5d8a:	e8 e3       	ldi	r30, 0x38	; 56
    5d8c:	f0 e0       	ldi	r31, 0x00	; 0
    5d8e:	8f ef       	ldi	r24, 0xFF	; 255
    5d90:	80 83       	st	Z, r24
	clearBits(SEG_DIG_PORT,SEG_DIG_MSK);
    5d92:	a5 e3       	ldi	r26, 0x35	; 53
    5d94:	b0 e0       	ldi	r27, 0x00	; 0
    5d96:	e5 e3       	ldi	r30, 0x35	; 53
    5d98:	f0 e0       	ldi	r31, 0x00	; 0
    5d9a:	80 81       	ld	r24, Z
    5d9c:	8f 70       	andi	r24, 0x0F	; 15
    5d9e:	8c 93       	st	X, r24
}
    5da0:	cf 91       	pop	r28
    5da2:	df 91       	pop	r29
    5da4:	08 95       	ret

00005da6 <Seg_Display>:
/* 
	Dig:		1-4
	Value:		0-9 and '.'
 */
void Seg_Display(u8 segDIG, u8 segValue){
    5da6:	df 93       	push	r29
    5da8:	cf 93       	push	r28
    5daa:	cd b7       	in	r28, 0x3d	; 61
    5dac:	de b7       	in	r29, 0x3e	; 62
    5dae:	60 97       	sbiw	r28, 0x10	; 16
    5db0:	0f b6       	in	r0, 0x3f	; 63
    5db2:	f8 94       	cli
    5db4:	de bf       	out	0x3e, r29	; 62
    5db6:	0f be       	out	0x3f, r0	; 63
    5db8:	cd bf       	out	0x3d, r28	; 61
    5dba:	8f 87       	std	Y+15, r24	; 0x0f
    5dbc:	68 8b       	std	Y+16, r22	; 0x10
	/* Select Digit to write */
	setBit(SEG_DIG_PORT, SEG_DIG_START_NUM + segDIG - 1);
    5dbe:	a5 e3       	ldi	r26, 0x35	; 53
    5dc0:	b0 e0       	ldi	r27, 0x00	; 0
    5dc2:	e5 e3       	ldi	r30, 0x35	; 53
    5dc4:	f0 e0       	ldi	r31, 0x00	; 0
    5dc6:	80 81       	ld	r24, Z
    5dc8:	48 2f       	mov	r20, r24
    5dca:	8f 85       	ldd	r24, Y+15	; 0x0f
    5dcc:	88 2f       	mov	r24, r24
    5dce:	90 e0       	ldi	r25, 0x00	; 0
    5dd0:	9c 01       	movw	r18, r24
    5dd2:	2d 5f       	subi	r18, 0xFD	; 253
    5dd4:	3f 4f       	sbci	r19, 0xFF	; 255
    5dd6:	81 e0       	ldi	r24, 0x01	; 1
    5dd8:	90 e0       	ldi	r25, 0x00	; 0
    5dda:	02 2e       	mov	r0, r18
    5ddc:	02 c0       	rjmp	.+4      	; 0x5de2 <Seg_Display+0x3c>
    5dde:	88 0f       	add	r24, r24
    5de0:	99 1f       	adc	r25, r25
    5de2:	0a 94       	dec	r0
    5de4:	e2 f7       	brpl	.-8      	; 0x5dde <Seg_Display+0x38>
    5de6:	84 2b       	or	r24, r20
    5de8:	8c 93       	st	X, r24
	/* apply data value */
	if (segValue == '.')
    5dea:	88 89       	ldd	r24, Y+16	; 0x10
    5dec:	8e 32       	cpi	r24, 0x2E	; 46
    5dee:	31 f4       	brne	.+12     	; 0x5dfc <Seg_Display+0x56>
	{
		SEG_DATA_PORT = numbers[10];
    5df0:	e8 e3       	ldi	r30, 0x38	; 56
    5df2:	f0 e0       	ldi	r31, 0x00	; 0
    5df4:	80 91 07 02 	lds	r24, 0x0207
    5df8:	80 83       	st	Z, r24
    5dfa:	0a c0       	rjmp	.+20     	; 0x5e10 <Seg_Display+0x6a>
	}
	else{
		SEG_DATA_PORT = numbers[segValue];
    5dfc:	a8 e3       	ldi	r26, 0x38	; 56
    5dfe:	b0 e0       	ldi	r27, 0x00	; 0
    5e00:	88 89       	ldd	r24, Y+16	; 0x10
    5e02:	88 2f       	mov	r24, r24
    5e04:	90 e0       	ldi	r25, 0x00	; 0
    5e06:	fc 01       	movw	r30, r24
    5e08:	e3 50       	subi	r30, 0x03	; 3
    5e0a:	fe 4f       	sbci	r31, 0xFE	; 254
    5e0c:	80 81       	ld	r24, Z
    5e0e:	8c 93       	st	X, r24
    5e10:	80 e0       	ldi	r24, 0x00	; 0
    5e12:	90 e0       	ldi	r25, 0x00	; 0
    5e14:	a0 e8       	ldi	r26, 0x80	; 128
    5e16:	bf e3       	ldi	r27, 0x3F	; 63
    5e18:	8b 87       	std	Y+11, r24	; 0x0b
    5e1a:	9c 87       	std	Y+12, r25	; 0x0c
    5e1c:	ad 87       	std	Y+13, r26	; 0x0d
    5e1e:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    5e20:	6b 85       	ldd	r22, Y+11	; 0x0b
    5e22:	7c 85       	ldd	r23, Y+12	; 0x0c
    5e24:	8d 85       	ldd	r24, Y+13	; 0x0d
    5e26:	9e 85       	ldd	r25, Y+14	; 0x0e
    5e28:	20 e0       	ldi	r18, 0x00	; 0
    5e2a:	30 e0       	ldi	r19, 0x00	; 0
    5e2c:	4a ef       	ldi	r20, 0xFA	; 250
    5e2e:	54 e4       	ldi	r21, 0x44	; 68
    5e30:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    5e34:	dc 01       	movw	r26, r24
    5e36:	cb 01       	movw	r24, r22
    5e38:	8f 83       	std	Y+7, r24	; 0x07
    5e3a:	98 87       	std	Y+8, r25	; 0x08
    5e3c:	a9 87       	std	Y+9, r26	; 0x09
    5e3e:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    5e40:	6f 81       	ldd	r22, Y+7	; 0x07
    5e42:	78 85       	ldd	r23, Y+8	; 0x08
    5e44:	89 85       	ldd	r24, Y+9	; 0x09
    5e46:	9a 85       	ldd	r25, Y+10	; 0x0a
    5e48:	20 e0       	ldi	r18, 0x00	; 0
    5e4a:	30 e0       	ldi	r19, 0x00	; 0
    5e4c:	40 e8       	ldi	r20, 0x80	; 128
    5e4e:	5f e3       	ldi	r21, 0x3F	; 63
    5e50:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    5e54:	88 23       	and	r24, r24
    5e56:	2c f4       	brge	.+10     	; 0x5e62 <Seg_Display+0xbc>
		__ticks = 1;
    5e58:	81 e0       	ldi	r24, 0x01	; 1
    5e5a:	90 e0       	ldi	r25, 0x00	; 0
    5e5c:	9e 83       	std	Y+6, r25	; 0x06
    5e5e:	8d 83       	std	Y+5, r24	; 0x05
    5e60:	3f c0       	rjmp	.+126    	; 0x5ee0 <Seg_Display+0x13a>
	else if (__tmp > 65535)
    5e62:	6f 81       	ldd	r22, Y+7	; 0x07
    5e64:	78 85       	ldd	r23, Y+8	; 0x08
    5e66:	89 85       	ldd	r24, Y+9	; 0x09
    5e68:	9a 85       	ldd	r25, Y+10	; 0x0a
    5e6a:	20 e0       	ldi	r18, 0x00	; 0
    5e6c:	3f ef       	ldi	r19, 0xFF	; 255
    5e6e:	4f e7       	ldi	r20, 0x7F	; 127
    5e70:	57 e4       	ldi	r21, 0x47	; 71
    5e72:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    5e76:	18 16       	cp	r1, r24
    5e78:	4c f5       	brge	.+82     	; 0x5ecc <Seg_Display+0x126>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    5e7a:	6b 85       	ldd	r22, Y+11	; 0x0b
    5e7c:	7c 85       	ldd	r23, Y+12	; 0x0c
    5e7e:	8d 85       	ldd	r24, Y+13	; 0x0d
    5e80:	9e 85       	ldd	r25, Y+14	; 0x0e
    5e82:	20 e0       	ldi	r18, 0x00	; 0
    5e84:	30 e0       	ldi	r19, 0x00	; 0
    5e86:	40 e2       	ldi	r20, 0x20	; 32
    5e88:	51 e4       	ldi	r21, 0x41	; 65
    5e8a:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    5e8e:	dc 01       	movw	r26, r24
    5e90:	cb 01       	movw	r24, r22
    5e92:	bc 01       	movw	r22, r24
    5e94:	cd 01       	movw	r24, r26
    5e96:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    5e9a:	dc 01       	movw	r26, r24
    5e9c:	cb 01       	movw	r24, r22
    5e9e:	9e 83       	std	Y+6, r25	; 0x06
    5ea0:	8d 83       	std	Y+5, r24	; 0x05
    5ea2:	0f c0       	rjmp	.+30     	; 0x5ec2 <Seg_Display+0x11c>
    5ea4:	88 ec       	ldi	r24, 0xC8	; 200
    5ea6:	90 e0       	ldi	r25, 0x00	; 0
    5ea8:	9c 83       	std	Y+4, r25	; 0x04
    5eaa:	8b 83       	std	Y+3, r24	; 0x03
    5eac:	8b 81       	ldd	r24, Y+3	; 0x03
    5eae:	9c 81       	ldd	r25, Y+4	; 0x04
    5eb0:	01 97       	sbiw	r24, 0x01	; 1
    5eb2:	f1 f7       	brne	.-4      	; 0x5eb0 <Seg_Display+0x10a>
    5eb4:	9c 83       	std	Y+4, r25	; 0x04
    5eb6:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    5eb8:	8d 81       	ldd	r24, Y+5	; 0x05
    5eba:	9e 81       	ldd	r25, Y+6	; 0x06
    5ebc:	01 97       	sbiw	r24, 0x01	; 1
    5ebe:	9e 83       	std	Y+6, r25	; 0x06
    5ec0:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    5ec2:	8d 81       	ldd	r24, Y+5	; 0x05
    5ec4:	9e 81       	ldd	r25, Y+6	; 0x06
    5ec6:	00 97       	sbiw	r24, 0x00	; 0
    5ec8:	69 f7       	brne	.-38     	; 0x5ea4 <Seg_Display+0xfe>
    5eca:	14 c0       	rjmp	.+40     	; 0x5ef4 <Seg_Display+0x14e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    5ecc:	6f 81       	ldd	r22, Y+7	; 0x07
    5ece:	78 85       	ldd	r23, Y+8	; 0x08
    5ed0:	89 85       	ldd	r24, Y+9	; 0x09
    5ed2:	9a 85       	ldd	r25, Y+10	; 0x0a
    5ed4:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    5ed8:	dc 01       	movw	r26, r24
    5eda:	cb 01       	movw	r24, r22
    5edc:	9e 83       	std	Y+6, r25	; 0x06
    5ede:	8d 83       	std	Y+5, r24	; 0x05
    5ee0:	8d 81       	ldd	r24, Y+5	; 0x05
    5ee2:	9e 81       	ldd	r25, Y+6	; 0x06
    5ee4:	9a 83       	std	Y+2, r25	; 0x02
    5ee6:	89 83       	std	Y+1, r24	; 0x01
    5ee8:	89 81       	ldd	r24, Y+1	; 0x01
    5eea:	9a 81       	ldd	r25, Y+2	; 0x02
    5eec:	01 97       	sbiw	r24, 0x01	; 1
    5eee:	f1 f7       	brne	.-4      	; 0x5eec <Seg_Display+0x146>
    5ef0:	9a 83       	std	Y+2, r25	; 0x02
    5ef2:	89 83       	std	Y+1, r24	; 0x01
	}
	/* wait for 1 ms */
	_delay_ms(1);
	/* UnSelect the Digit */	
	clearBit(SEG_DIG_PORT, SEG_DIG_START_NUM + segDIG - 1);	
    5ef4:	a5 e3       	ldi	r26, 0x35	; 53
    5ef6:	b0 e0       	ldi	r27, 0x00	; 0
    5ef8:	e5 e3       	ldi	r30, 0x35	; 53
    5efa:	f0 e0       	ldi	r31, 0x00	; 0
    5efc:	80 81       	ld	r24, Z
    5efe:	48 2f       	mov	r20, r24
    5f00:	8f 85       	ldd	r24, Y+15	; 0x0f
    5f02:	88 2f       	mov	r24, r24
    5f04:	90 e0       	ldi	r25, 0x00	; 0
    5f06:	9c 01       	movw	r18, r24
    5f08:	2d 5f       	subi	r18, 0xFD	; 253
    5f0a:	3f 4f       	sbci	r19, 0xFF	; 255
    5f0c:	81 e0       	ldi	r24, 0x01	; 1
    5f0e:	90 e0       	ldi	r25, 0x00	; 0
    5f10:	02 2e       	mov	r0, r18
    5f12:	02 c0       	rjmp	.+4      	; 0x5f18 <Seg_Display+0x172>
    5f14:	88 0f       	add	r24, r24
    5f16:	99 1f       	adc	r25, r25
    5f18:	0a 94       	dec	r0
    5f1a:	e2 f7       	brpl	.-8      	; 0x5f14 <Seg_Display+0x16e>
    5f1c:	80 95       	com	r24
    5f1e:	84 23       	and	r24, r20
    5f20:	8c 93       	st	X, r24
    5f22:	60 96       	adiw	r28, 0x10	; 16
    5f24:	0f b6       	in	r0, 0x3f	; 63
    5f26:	f8 94       	cli
    5f28:	de bf       	out	0x3e, r29	; 62
    5f2a:	0f be       	out	0x3f, r0	; 63
    5f2c:	cd bf       	out	0x3d, r28	; 61
    5f2e:	cf 91       	pop	r28
    5f30:	df 91       	pop	r29
    5f32:	08 95       	ret

00005f34 <Timer_Init>:
volatile static u32 overflows = 0;
volatile static u32 calcOverflows = 0;
void (*volatile notifier)(void);

/* Tick in 1us */
void Timer_Init(Timer_Mode mode){
    5f34:	df 93       	push	r29
    5f36:	cf 93       	push	r28
    5f38:	00 d0       	rcall	.+0      	; 0x5f3a <Timer_Init+0x6>
    5f3a:	0f 92       	push	r0
    5f3c:	cd b7       	in	r28, 0x3d	; 61
    5f3e:	de b7       	in	r29, 0x3e	; 62
    5f40:	89 83       	std	Y+1, r24	; 0x01
	Timer_Stop();
    5f42:	0e 94 73 30 	call	0x60e6	; 0x60e6 <Timer_Stop>
	switch(mode){
    5f46:	89 81       	ldd	r24, Y+1	; 0x01
    5f48:	28 2f       	mov	r18, r24
    5f4a:	30 e0       	ldi	r19, 0x00	; 0
    5f4c:	3b 83       	std	Y+3, r19	; 0x03
    5f4e:	2a 83       	std	Y+2, r18	; 0x02
    5f50:	8a 81       	ldd	r24, Y+2	; 0x02
    5f52:	9b 81       	ldd	r25, Y+3	; 0x03
    5f54:	81 30       	cpi	r24, 0x01	; 1
    5f56:	91 05       	cpc	r25, r1
    5f58:	71 f1       	breq	.+92     	; 0x5fb6 <Timer_Init+0x82>
    5f5a:	2a 81       	ldd	r18, Y+2	; 0x02
    5f5c:	3b 81       	ldd	r19, Y+3	; 0x03
    5f5e:	22 30       	cpi	r18, 0x02	; 2
    5f60:	31 05       	cpc	r19, r1
    5f62:	2c f4       	brge	.+10     	; 0x5f6e <Timer_Init+0x3a>
    5f64:	8a 81       	ldd	r24, Y+2	; 0x02
    5f66:	9b 81       	ldd	r25, Y+3	; 0x03
    5f68:	00 97       	sbiw	r24, 0x00	; 0
    5f6a:	71 f0       	breq	.+28     	; 0x5f88 <Timer_Init+0x54>
    5f6c:	a1 c0       	rjmp	.+322    	; 0x60b0 <Timer_Init+0x17c>
    5f6e:	2a 81       	ldd	r18, Y+2	; 0x02
    5f70:	3b 81       	ldd	r19, Y+3	; 0x03
    5f72:	22 30       	cpi	r18, 0x02	; 2
    5f74:	31 05       	cpc	r19, r1
    5f76:	09 f4       	brne	.+2      	; 0x5f7a <Timer_Init+0x46>
    5f78:	48 c0       	rjmp	.+144    	; 0x600a <Timer_Init+0xd6>
    5f7a:	8a 81       	ldd	r24, Y+2	; 0x02
    5f7c:	9b 81       	ldd	r25, Y+3	; 0x03
    5f7e:	83 30       	cpi	r24, 0x03	; 3
    5f80:	91 05       	cpc	r25, r1
    5f82:	09 f4       	brne	.+2      	; 0x5f86 <Timer_Init+0x52>
    5f84:	6c c0       	rjmp	.+216    	; 0x605e <Timer_Init+0x12a>
    5f86:	94 c0       	rjmp	.+296    	; 0x60b0 <Timer_Init+0x17c>
		case TM_NORMAL:
		clearBit(TCCR0,WGM00);
    5f88:	a3 e5       	ldi	r26, 0x53	; 83
    5f8a:	b0 e0       	ldi	r27, 0x00	; 0
    5f8c:	e3 e5       	ldi	r30, 0x53	; 83
    5f8e:	f0 e0       	ldi	r31, 0x00	; 0
    5f90:	80 81       	ld	r24, Z
    5f92:	8f 7b       	andi	r24, 0xBF	; 191
    5f94:	8c 93       	st	X, r24
		clearBit(TCCR0,WGM01);
    5f96:	a3 e5       	ldi	r26, 0x53	; 83
    5f98:	b0 e0       	ldi	r27, 0x00	; 0
    5f9a:	e3 e5       	ldi	r30, 0x53	; 83
    5f9c:	f0 e0       	ldi	r31, 0x00	; 0
    5f9e:	80 81       	ld	r24, Z
    5fa0:	87 7f       	andi	r24, 0xF7	; 247
    5fa2:	8c 93       	st	X, r24
		setBit(TIMSK,TOIE0); /* enable timer0 overflow int */
    5fa4:	a9 e5       	ldi	r26, 0x59	; 89
    5fa6:	b0 e0       	ldi	r27, 0x00	; 0
    5fa8:	e9 e5       	ldi	r30, 0x59	; 89
    5faa:	f0 e0       	ldi	r31, 0x00	; 0
    5fac:	80 81       	ld	r24, Z
    5fae:	81 60       	ori	r24, 0x01	; 1
    5fb0:	8c 93       	st	X, r24
		sei();
    5fb2:	78 94       	sei
    5fb4:	7d c0       	rjmp	.+250    	; 0x60b0 <Timer_Init+0x17c>
		break;
		case TM_CTC:
		clearBit(TCCR0,WGM00);
    5fb6:	a3 e5       	ldi	r26, 0x53	; 83
    5fb8:	b0 e0       	ldi	r27, 0x00	; 0
    5fba:	e3 e5       	ldi	r30, 0x53	; 83
    5fbc:	f0 e0       	ldi	r31, 0x00	; 0
    5fbe:	80 81       	ld	r24, Z
    5fc0:	8f 7b       	andi	r24, 0xBF	; 191
    5fc2:	8c 93       	st	X, r24
		setBit(TCCR0,WGM01);
    5fc4:	a3 e5       	ldi	r26, 0x53	; 83
    5fc6:	b0 e0       	ldi	r27, 0x00	; 0
    5fc8:	e3 e5       	ldi	r30, 0x53	; 83
    5fca:	f0 e0       	ldi	r31, 0x00	; 0
    5fcc:	80 81       	ld	r24, Z
    5fce:	88 60       	ori	r24, 0x08	; 8
    5fd0:	8c 93       	st	X, r24
		/* Toggle OC0 pin */
		setBit(TCCR0,COM00);
    5fd2:	a3 e5       	ldi	r26, 0x53	; 83
    5fd4:	b0 e0       	ldi	r27, 0x00	; 0
    5fd6:	e3 e5       	ldi	r30, 0x53	; 83
    5fd8:	f0 e0       	ldi	r31, 0x00	; 0
    5fda:	80 81       	ld	r24, Z
    5fdc:	80 61       	ori	r24, 0x10	; 16
    5fde:	8c 93       	st	X, r24
		clearBit(TCCR0,COM01);
    5fe0:	a3 e5       	ldi	r26, 0x53	; 83
    5fe2:	b0 e0       	ldi	r27, 0x00	; 0
    5fe4:	e3 e5       	ldi	r30, 0x53	; 83
    5fe6:	f0 e0       	ldi	r31, 0x00	; 0
    5fe8:	80 81       	ld	r24, Z
    5fea:	8f 7d       	andi	r24, 0xDF	; 223
    5fec:	8c 93       	st	X, r24
		/* OC0 Pin Out */
		setBit(DDRB,PB3);
    5fee:	a7 e3       	ldi	r26, 0x37	; 55
    5ff0:	b0 e0       	ldi	r27, 0x00	; 0
    5ff2:	e7 e3       	ldi	r30, 0x37	; 55
    5ff4:	f0 e0       	ldi	r31, 0x00	; 0
    5ff6:	80 81       	ld	r24, Z
    5ff8:	88 60       	ori	r24, 0x08	; 8
    5ffa:	8c 93       	st	X, r24
		/* Set OCR */
		OCR0 = 127;
    5ffc:	ec e5       	ldi	r30, 0x5C	; 92
    5ffe:	f0 e0       	ldi	r31, 0x00	; 0
    6000:	8f e7       	ldi	r24, 0x7F	; 127
    6002:	80 83       	st	Z, r24
		Timer_Start();
    6004:	0e 94 5e 30 	call	0x60bc	; 0x60bc <Timer_Start>
    6008:	53 c0       	rjmp	.+166    	; 0x60b0 <Timer_Init+0x17c>
		break;
		case TM_PHASE_PWM:
		setBit(TCCR0,WGM00);
    600a:	a3 e5       	ldi	r26, 0x53	; 83
    600c:	b0 e0       	ldi	r27, 0x00	; 0
    600e:	e3 e5       	ldi	r30, 0x53	; 83
    6010:	f0 e0       	ldi	r31, 0x00	; 0
    6012:	80 81       	ld	r24, Z
    6014:	80 64       	ori	r24, 0x40	; 64
    6016:	8c 93       	st	X, r24
		clearBit(TCCR0,WGM01);
    6018:	a3 e5       	ldi	r26, 0x53	; 83
    601a:	b0 e0       	ldi	r27, 0x00	; 0
    601c:	e3 e5       	ldi	r30, 0x53	; 83
    601e:	f0 e0       	ldi	r31, 0x00	; 0
    6020:	80 81       	ld	r24, Z
    6022:	87 7f       	andi	r24, 0xF7	; 247
    6024:	8c 93       	st	X, r24
		/* clear OC0 pin at upcount  match and set on downcount match*/
		clearBit(TCCR0,COM00);
    6026:	a3 e5       	ldi	r26, 0x53	; 83
    6028:	b0 e0       	ldi	r27, 0x00	; 0
    602a:	e3 e5       	ldi	r30, 0x53	; 83
    602c:	f0 e0       	ldi	r31, 0x00	; 0
    602e:	80 81       	ld	r24, Z
    6030:	8f 7e       	andi	r24, 0xEF	; 239
    6032:	8c 93       	st	X, r24
		setBit(TCCR0,COM01);
    6034:	a3 e5       	ldi	r26, 0x53	; 83
    6036:	b0 e0       	ldi	r27, 0x00	; 0
    6038:	e3 e5       	ldi	r30, 0x53	; 83
    603a:	f0 e0       	ldi	r31, 0x00	; 0
    603c:	80 81       	ld	r24, Z
    603e:	80 62       	ori	r24, 0x20	; 32
    6040:	8c 93       	st	X, r24
		/* OC0 Pin Out */
		setBit(DDRB,PB3);
    6042:	a7 e3       	ldi	r26, 0x37	; 55
    6044:	b0 e0       	ldi	r27, 0x00	; 0
    6046:	e7 e3       	ldi	r30, 0x37	; 55
    6048:	f0 e0       	ldi	r31, 0x00	; 0
    604a:	80 81       	ld	r24, Z
    604c:	88 60       	ori	r24, 0x08	; 8
    604e:	8c 93       	st	X, r24
		/* Set OCR */
		OCR0 = 127;
    6050:	ec e5       	ldi	r30, 0x5C	; 92
    6052:	f0 e0       	ldi	r31, 0x00	; 0
    6054:	8f e7       	ldi	r24, 0x7F	; 127
    6056:	80 83       	st	Z, r24
		Timer_Start();
    6058:	0e 94 5e 30 	call	0x60bc	; 0x60bc <Timer_Start>
    605c:	29 c0       	rjmp	.+82     	; 0x60b0 <Timer_Init+0x17c>
		break;
		case TM_FAST_PWM:
		setBit(TCCR0,WGM00);
    605e:	a3 e5       	ldi	r26, 0x53	; 83
    6060:	b0 e0       	ldi	r27, 0x00	; 0
    6062:	e3 e5       	ldi	r30, 0x53	; 83
    6064:	f0 e0       	ldi	r31, 0x00	; 0
    6066:	80 81       	ld	r24, Z
    6068:	80 64       	ori	r24, 0x40	; 64
    606a:	8c 93       	st	X, r24
		setBit(TCCR0,WGM01);
    606c:	a3 e5       	ldi	r26, 0x53	; 83
    606e:	b0 e0       	ldi	r27, 0x00	; 0
    6070:	e3 e5       	ldi	r30, 0x53	; 83
    6072:	f0 e0       	ldi	r31, 0x00	; 0
    6074:	80 81       	ld	r24, Z
    6076:	88 60       	ori	r24, 0x08	; 8
    6078:	8c 93       	st	X, r24
		/* set OC0 pin at bot and clear on match*/
		clearBit(TCCR0,COM00);
    607a:	a3 e5       	ldi	r26, 0x53	; 83
    607c:	b0 e0       	ldi	r27, 0x00	; 0
    607e:	e3 e5       	ldi	r30, 0x53	; 83
    6080:	f0 e0       	ldi	r31, 0x00	; 0
    6082:	80 81       	ld	r24, Z
    6084:	8f 7e       	andi	r24, 0xEF	; 239
    6086:	8c 93       	st	X, r24
		setBit(TCCR0,COM01);
    6088:	a3 e5       	ldi	r26, 0x53	; 83
    608a:	b0 e0       	ldi	r27, 0x00	; 0
    608c:	e3 e5       	ldi	r30, 0x53	; 83
    608e:	f0 e0       	ldi	r31, 0x00	; 0
    6090:	80 81       	ld	r24, Z
    6092:	80 62       	ori	r24, 0x20	; 32
    6094:	8c 93       	st	X, r24
		/* OC0 Pin Out */
		setBit(DDRB,PB3);
    6096:	a7 e3       	ldi	r26, 0x37	; 55
    6098:	b0 e0       	ldi	r27, 0x00	; 0
    609a:	e7 e3       	ldi	r30, 0x37	; 55
    609c:	f0 e0       	ldi	r31, 0x00	; 0
    609e:	80 81       	ld	r24, Z
    60a0:	88 60       	ori	r24, 0x08	; 8
    60a2:	8c 93       	st	X, r24
		/* Set OCR */
		OCR0 = 127;
    60a4:	ec e5       	ldi	r30, 0x5C	; 92
    60a6:	f0 e0       	ldi	r31, 0x00	; 0
    60a8:	8f e7       	ldi	r24, 0x7F	; 127
    60aa:	80 83       	st	Z, r24
		Timer_Start();
    60ac:	0e 94 5e 30 	call	0x60bc	; 0x60bc <Timer_Start>
		break;
		default:
		break;
	}
}
    60b0:	0f 90       	pop	r0
    60b2:	0f 90       	pop	r0
    60b4:	0f 90       	pop	r0
    60b6:	cf 91       	pop	r28
    60b8:	df 91       	pop	r29
    60ba:	08 95       	ret

000060bc <Timer_Start>:
void Timer_Start(void){
    60bc:	df 93       	push	r29
    60be:	cf 93       	push	r28
    60c0:	cd b7       	in	r28, 0x3d	; 61
    60c2:	de b7       	in	r29, 0x3e	; 62
	clearBits(TCCR0,((1<<CS00)|(1<<CS02)));
    60c4:	a3 e5       	ldi	r26, 0x53	; 83
    60c6:	b0 e0       	ldi	r27, 0x00	; 0
    60c8:	e3 e5       	ldi	r30, 0x53	; 83
    60ca:	f0 e0       	ldi	r31, 0x00	; 0
    60cc:	80 81       	ld	r24, Z
    60ce:	8a 7f       	andi	r24, 0xFA	; 250
    60d0:	8c 93       	st	X, r24
	setBit(TCCR0,CS01);
    60d2:	a3 e5       	ldi	r26, 0x53	; 83
    60d4:	b0 e0       	ldi	r27, 0x00	; 0
    60d6:	e3 e5       	ldi	r30, 0x53	; 83
    60d8:	f0 e0       	ldi	r31, 0x00	; 0
    60da:	80 81       	ld	r24, Z
    60dc:	82 60       	ori	r24, 0x02	; 2
    60de:	8c 93       	st	X, r24
}
    60e0:	cf 91       	pop	r28
    60e2:	df 91       	pop	r29
    60e4:	08 95       	ret

000060e6 <Timer_Stop>:
void Timer_Stop(void){
    60e6:	df 93       	push	r29
    60e8:	cf 93       	push	r28
    60ea:	cd b7       	in	r28, 0x3d	; 61
    60ec:	de b7       	in	r29, 0x3e	; 62
	clearBits(TCCR0,((1<<CS00)|(1<<CS01)|(1<<CS02)));
    60ee:	a3 e5       	ldi	r26, 0x53	; 83
    60f0:	b0 e0       	ldi	r27, 0x00	; 0
    60f2:	e3 e5       	ldi	r30, 0x53	; 83
    60f4:	f0 e0       	ldi	r31, 0x00	; 0
    60f6:	80 81       	ld	r24, Z
    60f8:	88 7f       	andi	r24, 0xF8	; 248
    60fa:	8c 93       	st	X, r24
}
    60fc:	cf 91       	pop	r28
    60fe:	df 91       	pop	r29
    6100:	08 95       	ret

00006102 <Timer_ResetCounters>:
void Timer_ResetCounters(void){
    6102:	df 93       	push	r29
    6104:	cf 93       	push	r28
    6106:	cd b7       	in	r28, 0x3d	; 61
    6108:	de b7       	in	r29, 0x3e	; 62
	overflows	= 0;
    610a:	10 92 3d 07 	sts	0x073D, r1
    610e:	10 92 3e 07 	sts	0x073E, r1
    6112:	10 92 3f 07 	sts	0x073F, r1
    6116:	10 92 40 07 	sts	0x0740, r1
	TCNT0		= 0;
    611a:	e2 e5       	ldi	r30, 0x52	; 82
    611c:	f0 e0       	ldi	r31, 0x00	; 0
    611e:	10 82       	st	Z, r1
}
    6120:	cf 91       	pop	r28
    6122:	df 91       	pop	r29
    6124:	08 95       	ret

00006126 <Timer_DelayUS>:

void Timer_DelayUS(u32 delay){
    6126:	df 93       	push	r29
    6128:	cf 93       	push	r28
    612a:	00 d0       	rcall	.+0      	; 0x612c <Timer_DelayUS+0x6>
    612c:	00 d0       	rcall	.+0      	; 0x612e <Timer_DelayUS+0x8>
    612e:	cd b7       	in	r28, 0x3d	; 61
    6130:	de b7       	in	r29, 0x3e	; 62
    6132:	69 83       	std	Y+1, r22	; 0x01
    6134:	7a 83       	std	Y+2, r23	; 0x02
    6136:	8b 83       	std	Y+3, r24	; 0x03
    6138:	9c 83       	std	Y+4, r25	; 0x04
	Timer_Stop();
    613a:	0e 94 73 30 	call	0x60e6	; 0x60e6 <Timer_Stop>
	Timer_ResetCounters();
    613e:	0e 94 81 30 	call	0x6102	; 0x6102 <Timer_ResetCounters>
	Timer_Start();
    6142:	0e 94 5e 30 	call	0x60bc	; 0x60bc <Timer_Start>
	while( (overflows*256UL+ TCNT0 + 1) < (delay) );
    6146:	80 91 3d 07 	lds	r24, 0x073D
    614a:	90 91 3e 07 	lds	r25, 0x073E
    614e:	a0 91 3f 07 	lds	r26, 0x073F
    6152:	b0 91 40 07 	lds	r27, 0x0740
    6156:	22 27       	eor	r18, r18
    6158:	38 2f       	mov	r19, r24
    615a:	49 2f       	mov	r20, r25
    615c:	5a 2f       	mov	r21, r26
    615e:	e2 e5       	ldi	r30, 0x52	; 82
    6160:	f0 e0       	ldi	r31, 0x00	; 0
    6162:	80 81       	ld	r24, Z
    6164:	88 2f       	mov	r24, r24
    6166:	90 e0       	ldi	r25, 0x00	; 0
    6168:	a0 e0       	ldi	r26, 0x00	; 0
    616a:	b0 e0       	ldi	r27, 0x00	; 0
    616c:	82 0f       	add	r24, r18
    616e:	93 1f       	adc	r25, r19
    6170:	a4 1f       	adc	r26, r20
    6172:	b5 1f       	adc	r27, r21
    6174:	9c 01       	movw	r18, r24
    6176:	ad 01       	movw	r20, r26
    6178:	2f 5f       	subi	r18, 0xFF	; 255
    617a:	3f 4f       	sbci	r19, 0xFF	; 255
    617c:	4f 4f       	sbci	r20, 0xFF	; 255
    617e:	5f 4f       	sbci	r21, 0xFF	; 255
    6180:	89 81       	ldd	r24, Y+1	; 0x01
    6182:	9a 81       	ldd	r25, Y+2	; 0x02
    6184:	ab 81       	ldd	r26, Y+3	; 0x03
    6186:	bc 81       	ldd	r27, Y+4	; 0x04
    6188:	28 17       	cp	r18, r24
    618a:	39 07       	cpc	r19, r25
    618c:	4a 07       	cpc	r20, r26
    618e:	5b 07       	cpc	r21, r27
    6190:	d0 f2       	brcs	.-76     	; 0x6146 <Timer_DelayUS+0x20>
}
    6192:	0f 90       	pop	r0
    6194:	0f 90       	pop	r0
    6196:	0f 90       	pop	r0
    6198:	0f 90       	pop	r0
    619a:	cf 91       	pop	r28
    619c:	df 91       	pop	r29
    619e:	08 95       	ret

000061a0 <Timer_DelayMS>:
void Timer_DelayMS(u32 delay){
    61a0:	ef 92       	push	r14
    61a2:	ff 92       	push	r15
    61a4:	0f 93       	push	r16
    61a6:	1f 93       	push	r17
    61a8:	df 93       	push	r29
    61aa:	cf 93       	push	r28
    61ac:	00 d0       	rcall	.+0      	; 0x61ae <Timer_DelayMS+0xe>
    61ae:	00 d0       	rcall	.+0      	; 0x61b0 <Timer_DelayMS+0x10>
    61b0:	cd b7       	in	r28, 0x3d	; 61
    61b2:	de b7       	in	r29, 0x3e	; 62
    61b4:	69 83       	std	Y+1, r22	; 0x01
    61b6:	7a 83       	std	Y+2, r23	; 0x02
    61b8:	8b 83       	std	Y+3, r24	; 0x03
    61ba:	9c 83       	std	Y+4, r25	; 0x04
	Timer_Stop();
    61bc:	0e 94 73 30 	call	0x60e6	; 0x60e6 <Timer_Stop>
	Timer_ResetCounters();
    61c0:	0e 94 81 30 	call	0x6102	; 0x6102 <Timer_ResetCounters>
	Timer_Start();
    61c4:	0e 94 5e 30 	call	0x60bc	; 0x60bc <Timer_Start>
	while( (overflows*256UL+ TCNT0 + 1) < (delay*1000UL) );
    61c8:	80 91 3d 07 	lds	r24, 0x073D
    61cc:	90 91 3e 07 	lds	r25, 0x073E
    61d0:	a0 91 3f 07 	lds	r26, 0x073F
    61d4:	b0 91 40 07 	lds	r27, 0x0740
    61d8:	22 27       	eor	r18, r18
    61da:	38 2f       	mov	r19, r24
    61dc:	49 2f       	mov	r20, r25
    61de:	5a 2f       	mov	r21, r26
    61e0:	e2 e5       	ldi	r30, 0x52	; 82
    61e2:	f0 e0       	ldi	r31, 0x00	; 0
    61e4:	80 81       	ld	r24, Z
    61e6:	88 2f       	mov	r24, r24
    61e8:	90 e0       	ldi	r25, 0x00	; 0
    61ea:	a0 e0       	ldi	r26, 0x00	; 0
    61ec:	b0 e0       	ldi	r27, 0x00	; 0
    61ee:	82 0f       	add	r24, r18
    61f0:	93 1f       	adc	r25, r19
    61f2:	a4 1f       	adc	r26, r20
    61f4:	b5 1f       	adc	r27, r21
    61f6:	7c 01       	movw	r14, r24
    61f8:	8d 01       	movw	r16, r26
    61fa:	08 94       	sec
    61fc:	e1 1c       	adc	r14, r1
    61fe:	f1 1c       	adc	r15, r1
    6200:	01 1d       	adc	r16, r1
    6202:	11 1d       	adc	r17, r1
    6204:	89 81       	ldd	r24, Y+1	; 0x01
    6206:	9a 81       	ldd	r25, Y+2	; 0x02
    6208:	ab 81       	ldd	r26, Y+3	; 0x03
    620a:	bc 81       	ldd	r27, Y+4	; 0x04
    620c:	28 ee       	ldi	r18, 0xE8	; 232
    620e:	33 e0       	ldi	r19, 0x03	; 3
    6210:	40 e0       	ldi	r20, 0x00	; 0
    6212:	50 e0       	ldi	r21, 0x00	; 0
    6214:	bc 01       	movw	r22, r24
    6216:	cd 01       	movw	r24, r26
    6218:	0e 94 50 36 	call	0x6ca0	; 0x6ca0 <__mulsi3>
    621c:	dc 01       	movw	r26, r24
    621e:	cb 01       	movw	r24, r22
    6220:	e8 16       	cp	r14, r24
    6222:	f9 06       	cpc	r15, r25
    6224:	0a 07       	cpc	r16, r26
    6226:	1b 07       	cpc	r17, r27
    6228:	78 f2       	brcs	.-98     	; 0x61c8 <Timer_DelayMS+0x28>
}
    622a:	0f 90       	pop	r0
    622c:	0f 90       	pop	r0
    622e:	0f 90       	pop	r0
    6230:	0f 90       	pop	r0
    6232:	cf 91       	pop	r28
    6234:	df 91       	pop	r29
    6236:	1f 91       	pop	r17
    6238:	0f 91       	pop	r16
    623a:	ff 90       	pop	r15
    623c:	ef 90       	pop	r14
    623e:	08 95       	ret

00006240 <Timer_SetDuty>:
void Timer_SetDuty(u8 duty){
    6240:	0f 93       	push	r16
    6242:	1f 93       	push	r17
    6244:	df 93       	push	r29
    6246:	cf 93       	push	r28
    6248:	0f 92       	push	r0
    624a:	cd b7       	in	r28, 0x3d	; 61
    624c:	de b7       	in	r29, 0x3e	; 62
    624e:	89 83       	std	Y+1, r24	; 0x01
	if (duty >= 100)
    6250:	89 81       	ldd	r24, Y+1	; 0x01
    6252:	84 36       	cpi	r24, 0x64	; 100
    6254:	28 f0       	brcs	.+10     	; 0x6260 <Timer_SetDuty+0x20>
	{
		OCR0 = 0xFF;
    6256:	ec e5       	ldi	r30, 0x5C	; 92
    6258:	f0 e0       	ldi	r31, 0x00	; 0
    625a:	8f ef       	ldi	r24, 0xFF	; 255
    625c:	80 83       	st	Z, r24
    625e:	1d c0       	rjmp	.+58     	; 0x629a <Timer_SetDuty+0x5a>
	}
	else{
		OCR0 = (0xFFUL*duty)/100;
    6260:	0c e5       	ldi	r16, 0x5C	; 92
    6262:	10 e0       	ldi	r17, 0x00	; 0
    6264:	89 81       	ldd	r24, Y+1	; 0x01
    6266:	88 2f       	mov	r24, r24
    6268:	90 e0       	ldi	r25, 0x00	; 0
    626a:	a0 e0       	ldi	r26, 0x00	; 0
    626c:	b0 e0       	ldi	r27, 0x00	; 0
    626e:	2f ef       	ldi	r18, 0xFF	; 255
    6270:	30 e0       	ldi	r19, 0x00	; 0
    6272:	40 e0       	ldi	r20, 0x00	; 0
    6274:	50 e0       	ldi	r21, 0x00	; 0
    6276:	bc 01       	movw	r22, r24
    6278:	cd 01       	movw	r24, r26
    627a:	0e 94 50 36 	call	0x6ca0	; 0x6ca0 <__mulsi3>
    627e:	dc 01       	movw	r26, r24
    6280:	cb 01       	movw	r24, r22
    6282:	24 e6       	ldi	r18, 0x64	; 100
    6284:	30 e0       	ldi	r19, 0x00	; 0
    6286:	40 e0       	ldi	r20, 0x00	; 0
    6288:	50 e0       	ldi	r21, 0x00	; 0
    628a:	bc 01       	movw	r22, r24
    628c:	cd 01       	movw	r24, r26
    628e:	0e 94 6f 36 	call	0x6cde	; 0x6cde <__udivmodsi4>
    6292:	da 01       	movw	r26, r20
    6294:	c9 01       	movw	r24, r18
    6296:	f8 01       	movw	r30, r16
    6298:	80 83       	st	Z, r24
	}
}
    629a:	0f 90       	pop	r0
    629c:	cf 91       	pop	r28
    629e:	df 91       	pop	r29
    62a0:	1f 91       	pop	r17
    62a2:	0f 91       	pop	r16
    62a4:	08 95       	ret

000062a6 <Timer_DecDuty>:
void Timer_DecDuty(u8 duty){
    62a6:	cf 92       	push	r12
    62a8:	df 92       	push	r13
    62aa:	ef 92       	push	r14
    62ac:	ff 92       	push	r15
    62ae:	0f 93       	push	r16
    62b0:	1f 93       	push	r17
    62b2:	df 93       	push	r29
    62b4:	cf 93       	push	r28
    62b6:	0f 92       	push	r0
    62b8:	cd b7       	in	r28, 0x3d	; 61
    62ba:	de b7       	in	r29, 0x3e	; 62
    62bc:	89 83       	std	Y+1, r24	; 0x01
	if(OCR0 >= 0xFF*(duty/100.0)){
    62be:	ec e5       	ldi	r30, 0x5C	; 92
    62c0:	f0 e0       	ldi	r31, 0x00	; 0
    62c2:	80 81       	ld	r24, Z
    62c4:	88 2f       	mov	r24, r24
    62c6:	90 e0       	ldi	r25, 0x00	; 0
    62c8:	aa 27       	eor	r26, r26
    62ca:	97 fd       	sbrc	r25, 7
    62cc:	a0 95       	com	r26
    62ce:	ba 2f       	mov	r27, r26
    62d0:	bc 01       	movw	r22, r24
    62d2:	cd 01       	movw	r24, r26
    62d4:	0e 94 85 04 	call	0x90a	; 0x90a <__floatsisf>
    62d8:	7b 01       	movw	r14, r22
    62da:	8c 01       	movw	r16, r24
    62dc:	89 81       	ldd	r24, Y+1	; 0x01
    62de:	88 2f       	mov	r24, r24
    62e0:	90 e0       	ldi	r25, 0x00	; 0
    62e2:	aa 27       	eor	r26, r26
    62e4:	97 fd       	sbrc	r25, 7
    62e6:	a0 95       	com	r26
    62e8:	ba 2f       	mov	r27, r26
    62ea:	bc 01       	movw	r22, r24
    62ec:	cd 01       	movw	r24, r26
    62ee:	0e 94 85 04 	call	0x90a	; 0x90a <__floatsisf>
    62f2:	dc 01       	movw	r26, r24
    62f4:	cb 01       	movw	r24, r22
    62f6:	bc 01       	movw	r22, r24
    62f8:	cd 01       	movw	r24, r26
    62fa:	20 e0       	ldi	r18, 0x00	; 0
    62fc:	30 e0       	ldi	r19, 0x00	; 0
    62fe:	48 ec       	ldi	r20, 0xC8	; 200
    6300:	52 e4       	ldi	r21, 0x42	; 66
    6302:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    6306:	dc 01       	movw	r26, r24
    6308:	cb 01       	movw	r24, r22
    630a:	bc 01       	movw	r22, r24
    630c:	cd 01       	movw	r24, r26
    630e:	20 e0       	ldi	r18, 0x00	; 0
    6310:	30 e0       	ldi	r19, 0x00	; 0
    6312:	4f e7       	ldi	r20, 0x7F	; 127
    6314:	53 e4       	ldi	r21, 0x43	; 67
    6316:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    631a:	dc 01       	movw	r26, r24
    631c:	cb 01       	movw	r24, r22
    631e:	9c 01       	movw	r18, r24
    6320:	ad 01       	movw	r20, r26
    6322:	c8 01       	movw	r24, r16
    6324:	b7 01       	movw	r22, r14
    6326:	0e 94 f5 03 	call	0x7ea	; 0x7ea <__gesf2>
    632a:	88 23       	and	r24, r24
    632c:	0c f4       	brge	.+2      	; 0x6330 <Timer_DecDuty+0x8a>
    632e:	46 c0       	rjmp	.+140    	; 0x63bc <Timer_DecDuty+0x116>
		OCR0 -= 0xFF*(duty/100.0);
    6330:	0f 2e       	mov	r0, r31
    6332:	fc e5       	ldi	r31, 0x5C	; 92
    6334:	cf 2e       	mov	r12, r31
    6336:	dd 24       	eor	r13, r13
    6338:	f0 2d       	mov	r31, r0
    633a:	ec e5       	ldi	r30, 0x5C	; 92
    633c:	f0 e0       	ldi	r31, 0x00	; 0
    633e:	80 81       	ld	r24, Z
    6340:	88 2f       	mov	r24, r24
    6342:	90 e0       	ldi	r25, 0x00	; 0
    6344:	aa 27       	eor	r26, r26
    6346:	97 fd       	sbrc	r25, 7
    6348:	a0 95       	com	r26
    634a:	ba 2f       	mov	r27, r26
    634c:	bc 01       	movw	r22, r24
    634e:	cd 01       	movw	r24, r26
    6350:	0e 94 85 04 	call	0x90a	; 0x90a <__floatsisf>
    6354:	7b 01       	movw	r14, r22
    6356:	8c 01       	movw	r16, r24
    6358:	89 81       	ldd	r24, Y+1	; 0x01
    635a:	88 2f       	mov	r24, r24
    635c:	90 e0       	ldi	r25, 0x00	; 0
    635e:	aa 27       	eor	r26, r26
    6360:	97 fd       	sbrc	r25, 7
    6362:	a0 95       	com	r26
    6364:	ba 2f       	mov	r27, r26
    6366:	bc 01       	movw	r22, r24
    6368:	cd 01       	movw	r24, r26
    636a:	0e 94 85 04 	call	0x90a	; 0x90a <__floatsisf>
    636e:	dc 01       	movw	r26, r24
    6370:	cb 01       	movw	r24, r22
    6372:	bc 01       	movw	r22, r24
    6374:	cd 01       	movw	r24, r26
    6376:	20 e0       	ldi	r18, 0x00	; 0
    6378:	30 e0       	ldi	r19, 0x00	; 0
    637a:	48 ec       	ldi	r20, 0xC8	; 200
    637c:	52 e4       	ldi	r21, 0x42	; 66
    637e:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    6382:	dc 01       	movw	r26, r24
    6384:	cb 01       	movw	r24, r22
    6386:	bc 01       	movw	r22, r24
    6388:	cd 01       	movw	r24, r26
    638a:	20 e0       	ldi	r18, 0x00	; 0
    638c:	30 e0       	ldi	r19, 0x00	; 0
    638e:	4f e7       	ldi	r20, 0x7F	; 127
    6390:	53 ec       	ldi	r21, 0xC3	; 195
    6392:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    6396:	dc 01       	movw	r26, r24
    6398:	cb 01       	movw	r24, r22
    639a:	9c 01       	movw	r18, r24
    639c:	ad 01       	movw	r20, r26
    639e:	c8 01       	movw	r24, r16
    63a0:	b7 01       	movw	r22, r14
    63a2:	0e 94 f2 01 	call	0x3e4	; 0x3e4 <__addsf3>
    63a6:	dc 01       	movw	r26, r24
    63a8:	cb 01       	movw	r24, r22
    63aa:	bc 01       	movw	r22, r24
    63ac:	cd 01       	movw	r24, r26
    63ae:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    63b2:	dc 01       	movw	r26, r24
    63b4:	cb 01       	movw	r24, r22
    63b6:	f6 01       	movw	r30, r12
    63b8:	80 83       	st	Z, r24
    63ba:	03 c0       	rjmp	.+6      	; 0x63c2 <Timer_DecDuty+0x11c>
	}
	else{
		OCR0 = 0x00;
    63bc:	ec e5       	ldi	r30, 0x5C	; 92
    63be:	f0 e0       	ldi	r31, 0x00	; 0
    63c0:	10 82       	st	Z, r1
	}
}
    63c2:	0f 90       	pop	r0
    63c4:	cf 91       	pop	r28
    63c6:	df 91       	pop	r29
    63c8:	1f 91       	pop	r17
    63ca:	0f 91       	pop	r16
    63cc:	ff 90       	pop	r15
    63ce:	ef 90       	pop	r14
    63d0:	df 90       	pop	r13
    63d2:	cf 90       	pop	r12
    63d4:	08 95       	ret

000063d6 <Timer_IncDuty>:
void Timer_IncDuty(u8 duty){
    63d6:	cf 92       	push	r12
    63d8:	df 92       	push	r13
    63da:	ef 92       	push	r14
    63dc:	ff 92       	push	r15
    63de:	0f 93       	push	r16
    63e0:	1f 93       	push	r17
    63e2:	df 93       	push	r29
    63e4:	cf 93       	push	r28
    63e6:	0f 92       	push	r0
    63e8:	cd b7       	in	r28, 0x3d	; 61
    63ea:	de b7       	in	r29, 0x3e	; 62
    63ec:	89 83       	std	Y+1, r24	; 0x01
	if(OCR0 + 0xFF*(duty/100.0) <= 0xFF){
    63ee:	ec e5       	ldi	r30, 0x5C	; 92
    63f0:	f0 e0       	ldi	r31, 0x00	; 0
    63f2:	80 81       	ld	r24, Z
    63f4:	88 2f       	mov	r24, r24
    63f6:	90 e0       	ldi	r25, 0x00	; 0
    63f8:	aa 27       	eor	r26, r26
    63fa:	97 fd       	sbrc	r25, 7
    63fc:	a0 95       	com	r26
    63fe:	ba 2f       	mov	r27, r26
    6400:	bc 01       	movw	r22, r24
    6402:	cd 01       	movw	r24, r26
    6404:	0e 94 85 04 	call	0x90a	; 0x90a <__floatsisf>
    6408:	7b 01       	movw	r14, r22
    640a:	8c 01       	movw	r16, r24
    640c:	89 81       	ldd	r24, Y+1	; 0x01
    640e:	88 2f       	mov	r24, r24
    6410:	90 e0       	ldi	r25, 0x00	; 0
    6412:	aa 27       	eor	r26, r26
    6414:	97 fd       	sbrc	r25, 7
    6416:	a0 95       	com	r26
    6418:	ba 2f       	mov	r27, r26
    641a:	bc 01       	movw	r22, r24
    641c:	cd 01       	movw	r24, r26
    641e:	0e 94 85 04 	call	0x90a	; 0x90a <__floatsisf>
    6422:	dc 01       	movw	r26, r24
    6424:	cb 01       	movw	r24, r22
    6426:	bc 01       	movw	r22, r24
    6428:	cd 01       	movw	r24, r26
    642a:	20 e0       	ldi	r18, 0x00	; 0
    642c:	30 e0       	ldi	r19, 0x00	; 0
    642e:	48 ec       	ldi	r20, 0xC8	; 200
    6430:	52 e4       	ldi	r21, 0x42	; 66
    6432:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    6436:	dc 01       	movw	r26, r24
    6438:	cb 01       	movw	r24, r22
    643a:	bc 01       	movw	r22, r24
    643c:	cd 01       	movw	r24, r26
    643e:	20 e0       	ldi	r18, 0x00	; 0
    6440:	30 e0       	ldi	r19, 0x00	; 0
    6442:	4f e7       	ldi	r20, 0x7F	; 127
    6444:	53 e4       	ldi	r21, 0x43	; 67
    6446:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    644a:	dc 01       	movw	r26, r24
    644c:	cb 01       	movw	r24, r22
    644e:	9c 01       	movw	r18, r24
    6450:	ad 01       	movw	r20, r26
    6452:	c8 01       	movw	r24, r16
    6454:	b7 01       	movw	r22, r14
    6456:	0e 94 f2 01 	call	0x3e4	; 0x3e4 <__addsf3>
    645a:	dc 01       	movw	r26, r24
    645c:	cb 01       	movw	r24, r22
    645e:	bc 01       	movw	r22, r24
    6460:	cd 01       	movw	r24, r26
    6462:	20 e0       	ldi	r18, 0x00	; 0
    6464:	30 e0       	ldi	r19, 0x00	; 0
    6466:	4f e7       	ldi	r20, 0x7F	; 127
    6468:	53 e4       	ldi	r21, 0x43	; 67
    646a:	0e 94 55 04 	call	0x8aa	; 0x8aa <__lesf2>
    646e:	18 16       	cp	r1, r24
    6470:	0c f4       	brge	.+2      	; 0x6474 <Timer_IncDuty+0x9e>
    6472:	46 c0       	rjmp	.+140    	; 0x6500 <Timer_IncDuty+0x12a>
		OCR0 += 0xFF*(duty/100.0);
    6474:	0f 2e       	mov	r0, r31
    6476:	fc e5       	ldi	r31, 0x5C	; 92
    6478:	cf 2e       	mov	r12, r31
    647a:	dd 24       	eor	r13, r13
    647c:	f0 2d       	mov	r31, r0
    647e:	ec e5       	ldi	r30, 0x5C	; 92
    6480:	f0 e0       	ldi	r31, 0x00	; 0
    6482:	80 81       	ld	r24, Z
    6484:	88 2f       	mov	r24, r24
    6486:	90 e0       	ldi	r25, 0x00	; 0
    6488:	aa 27       	eor	r26, r26
    648a:	97 fd       	sbrc	r25, 7
    648c:	a0 95       	com	r26
    648e:	ba 2f       	mov	r27, r26
    6490:	bc 01       	movw	r22, r24
    6492:	cd 01       	movw	r24, r26
    6494:	0e 94 85 04 	call	0x90a	; 0x90a <__floatsisf>
    6498:	7b 01       	movw	r14, r22
    649a:	8c 01       	movw	r16, r24
    649c:	89 81       	ldd	r24, Y+1	; 0x01
    649e:	88 2f       	mov	r24, r24
    64a0:	90 e0       	ldi	r25, 0x00	; 0
    64a2:	aa 27       	eor	r26, r26
    64a4:	97 fd       	sbrc	r25, 7
    64a6:	a0 95       	com	r26
    64a8:	ba 2f       	mov	r27, r26
    64aa:	bc 01       	movw	r22, r24
    64ac:	cd 01       	movw	r24, r26
    64ae:	0e 94 85 04 	call	0x90a	; 0x90a <__floatsisf>
    64b2:	dc 01       	movw	r26, r24
    64b4:	cb 01       	movw	r24, r22
    64b6:	bc 01       	movw	r22, r24
    64b8:	cd 01       	movw	r24, r26
    64ba:	20 e0       	ldi	r18, 0x00	; 0
    64bc:	30 e0       	ldi	r19, 0x00	; 0
    64be:	48 ec       	ldi	r20, 0xC8	; 200
    64c0:	52 e4       	ldi	r21, 0x42	; 66
    64c2:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    64c6:	dc 01       	movw	r26, r24
    64c8:	cb 01       	movw	r24, r22
    64ca:	bc 01       	movw	r22, r24
    64cc:	cd 01       	movw	r24, r26
    64ce:	20 e0       	ldi	r18, 0x00	; 0
    64d0:	30 e0       	ldi	r19, 0x00	; 0
    64d2:	4f e7       	ldi	r20, 0x7F	; 127
    64d4:	53 e4       	ldi	r21, 0x43	; 67
    64d6:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    64da:	dc 01       	movw	r26, r24
    64dc:	cb 01       	movw	r24, r22
    64de:	9c 01       	movw	r18, r24
    64e0:	ad 01       	movw	r20, r26
    64e2:	c8 01       	movw	r24, r16
    64e4:	b7 01       	movw	r22, r14
    64e6:	0e 94 f2 01 	call	0x3e4	; 0x3e4 <__addsf3>
    64ea:	dc 01       	movw	r26, r24
    64ec:	cb 01       	movw	r24, r22
    64ee:	bc 01       	movw	r22, r24
    64f0:	cd 01       	movw	r24, r26
    64f2:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    64f6:	dc 01       	movw	r26, r24
    64f8:	cb 01       	movw	r24, r22
    64fa:	f6 01       	movw	r30, r12
    64fc:	80 83       	st	Z, r24
    64fe:	04 c0       	rjmp	.+8      	; 0x6508 <Timer_IncDuty+0x132>
		}else{
		OCR0 = 0xFF;
    6500:	ec e5       	ldi	r30, 0x5C	; 92
    6502:	f0 e0       	ldi	r31, 0x00	; 0
    6504:	8f ef       	ldi	r24, 0xFF	; 255
    6506:	80 83       	st	Z, r24
	}
}
    6508:	0f 90       	pop	r0
    650a:	cf 91       	pop	r28
    650c:	df 91       	pop	r29
    650e:	1f 91       	pop	r17
    6510:	0f 91       	pop	r16
    6512:	ff 90       	pop	r15
    6514:	ef 90       	pop	r14
    6516:	df 90       	pop	r13
    6518:	cf 90       	pop	r12
    651a:	08 95       	ret

0000651c <Timer_SetNotif>:

void Timer_SetNotif(void (*pfNotify)(void),u32 notifyTime){
    651c:	df 93       	push	r29
    651e:	cf 93       	push	r28
    6520:	00 d0       	rcall	.+0      	; 0x6522 <Timer_SetNotif+0x6>
    6522:	00 d0       	rcall	.+0      	; 0x6524 <Timer_SetNotif+0x8>
    6524:	00 d0       	rcall	.+0      	; 0x6526 <Timer_SetNotif+0xa>
    6526:	cd b7       	in	r28, 0x3d	; 61
    6528:	de b7       	in	r29, 0x3e	; 62
    652a:	9a 83       	std	Y+2, r25	; 0x02
    652c:	89 83       	std	Y+1, r24	; 0x01
    652e:	4b 83       	std	Y+3, r20	; 0x03
    6530:	5c 83       	std	Y+4, r21	; 0x04
    6532:	6d 83       	std	Y+5, r22	; 0x05
    6534:	7e 83       	std	Y+6, r23	; 0x06
	Timer_Init(TM_NORMAL);
    6536:	80 e0       	ldi	r24, 0x00	; 0
    6538:	0e 94 9a 2f 	call	0x5f34	; 0x5f34 <Timer_Init>
	notifier = pfNotify;
    653c:	89 81       	ldd	r24, Y+1	; 0x01
    653e:	9a 81       	ldd	r25, Y+2	; 0x02
    6540:	90 93 54 07 	sts	0x0754, r25
    6544:	80 93 53 07 	sts	0x0753, r24
	//TCNT0 = 256 - ((notifyTime*1000UL)%256 -1);
	overflows = 0;
    6548:	10 92 3d 07 	sts	0x073D, r1
    654c:	10 92 3e 07 	sts	0x073E, r1
    6550:	10 92 3f 07 	sts	0x073F, r1
    6554:	10 92 40 07 	sts	0x0740, r1
	calcOverflows = (notifyTime*1000UL)/256;// +1;
    6558:	8b 81       	ldd	r24, Y+3	; 0x03
    655a:	9c 81       	ldd	r25, Y+4	; 0x04
    655c:	ad 81       	ldd	r26, Y+5	; 0x05
    655e:	be 81       	ldd	r27, Y+6	; 0x06
    6560:	28 ee       	ldi	r18, 0xE8	; 232
    6562:	33 e0       	ldi	r19, 0x03	; 3
    6564:	40 e0       	ldi	r20, 0x00	; 0
    6566:	50 e0       	ldi	r21, 0x00	; 0
    6568:	bc 01       	movw	r22, r24
    656a:	cd 01       	movw	r24, r26
    656c:	0e 94 50 36 	call	0x6ca0	; 0x6ca0 <__mulsi3>
    6570:	dc 01       	movw	r26, r24
    6572:	cb 01       	movw	r24, r22
    6574:	89 2f       	mov	r24, r25
    6576:	9a 2f       	mov	r25, r26
    6578:	ab 2f       	mov	r26, r27
    657a:	bb 27       	eor	r27, r27
    657c:	80 93 41 07 	sts	0x0741, r24
    6580:	90 93 42 07 	sts	0x0742, r25
    6584:	a0 93 43 07 	sts	0x0743, r26
    6588:	b0 93 44 07 	sts	0x0744, r27
	Timer_Start();
    658c:	0e 94 5e 30 	call	0x60bc	; 0x60bc <Timer_Start>
}
    6590:	26 96       	adiw	r28, 0x06	; 6
    6592:	0f b6       	in	r0, 0x3f	; 63
    6594:	f8 94       	cli
    6596:	de bf       	out	0x3e, r29	; 62
    6598:	0f be       	out	0x3f, r0	; 63
    659a:	cd bf       	out	0x3d, r28	; 61
    659c:	cf 91       	pop	r28
    659e:	df 91       	pop	r29
    65a0:	08 95       	ret

000065a2 <__vector_11>:


ISR(TIMER0_OVF_vect){
    65a2:	1f 92       	push	r1
    65a4:	0f 92       	push	r0
    65a6:	0f b6       	in	r0, 0x3f	; 63
    65a8:	0f 92       	push	r0
    65aa:	11 24       	eor	r1, r1
    65ac:	2f 93       	push	r18
    65ae:	3f 93       	push	r19
    65b0:	4f 93       	push	r20
    65b2:	5f 93       	push	r21
    65b4:	6f 93       	push	r22
    65b6:	7f 93       	push	r23
    65b8:	8f 93       	push	r24
    65ba:	9f 93       	push	r25
    65bc:	af 93       	push	r26
    65be:	bf 93       	push	r27
    65c0:	ef 93       	push	r30
    65c2:	ff 93       	push	r31
    65c4:	df 93       	push	r29
    65c6:	cf 93       	push	r28
    65c8:	cd b7       	in	r28, 0x3d	; 61
    65ca:	de b7       	in	r29, 0x3e	; 62
	overflows++;
    65cc:	80 91 3d 07 	lds	r24, 0x073D
    65d0:	90 91 3e 07 	lds	r25, 0x073E
    65d4:	a0 91 3f 07 	lds	r26, 0x073F
    65d8:	b0 91 40 07 	lds	r27, 0x0740
    65dc:	01 96       	adiw	r24, 0x01	; 1
    65de:	a1 1d       	adc	r26, r1
    65e0:	b1 1d       	adc	r27, r1
    65e2:	80 93 3d 07 	sts	0x073D, r24
    65e6:	90 93 3e 07 	sts	0x073E, r25
    65ea:	a0 93 3f 07 	sts	0x073F, r26
    65ee:	b0 93 40 07 	sts	0x0740, r27
	if(overflows == calcOverflows){
    65f2:	20 91 3d 07 	lds	r18, 0x073D
    65f6:	30 91 3e 07 	lds	r19, 0x073E
    65fa:	40 91 3f 07 	lds	r20, 0x073F
    65fe:	50 91 40 07 	lds	r21, 0x0740
    6602:	80 91 41 07 	lds	r24, 0x0741
    6606:	90 91 42 07 	lds	r25, 0x0742
    660a:	a0 91 43 07 	lds	r26, 0x0743
    660e:	b0 91 44 07 	lds	r27, 0x0744
    6612:	28 17       	cp	r18, r24
    6614:	39 07       	cpc	r19, r25
    6616:	4a 07       	cpc	r20, r26
    6618:	5b 07       	cpc	r21, r27
    661a:	39 f4       	brne	.+14     	; 0x662a <__vector_11+0x88>
		notifier();
    661c:	e0 91 53 07 	lds	r30, 0x0753
    6620:	f0 91 54 07 	lds	r31, 0x0754
    6624:	09 95       	icall
		Timer_Stop();
    6626:	0e 94 73 30 	call	0x60e6	; 0x60e6 <Timer_Stop>
	}
    662a:	cf 91       	pop	r28
    662c:	df 91       	pop	r29
    662e:	ff 91       	pop	r31
    6630:	ef 91       	pop	r30
    6632:	bf 91       	pop	r27
    6634:	af 91       	pop	r26
    6636:	9f 91       	pop	r25
    6638:	8f 91       	pop	r24
    663a:	7f 91       	pop	r23
    663c:	6f 91       	pop	r22
    663e:	5f 91       	pop	r21
    6640:	4f 91       	pop	r20
    6642:	3f 91       	pop	r19
    6644:	2f 91       	pop	r18
    6646:	0f 90       	pop	r0
    6648:	0f be       	out	0x3f, r0	; 63
    664a:	0f 90       	pop	r0
    664c:	1f 90       	pop	r1
    664e:	18 95       	reti

00006650 <Uart_Init>:
* Created: 7/14/2021 10:44:50 AM
*  Author: MahmoudH
*/
#include "uart.h"
/* default: 8N1  */
void	Uart_Init(u32 baudRate){
    6650:	df 93       	push	r29
    6652:	cf 93       	push	r28
    6654:	cd b7       	in	r28, 0x3d	; 61
    6656:	de b7       	in	r29, 0x3e	; 62
    6658:	28 97       	sbiw	r28, 0x08	; 8
    665a:	0f b6       	in	r0, 0x3f	; 63
    665c:	f8 94       	cli
    665e:	de bf       	out	0x3e, r29	; 62
    6660:	0f be       	out	0x3f, r0	; 63
    6662:	cd bf       	out	0x3d, r28	; 61
    6664:	6d 83       	std	Y+5, r22	; 0x05
    6666:	7e 83       	std	Y+6, r23	; 0x06
    6668:	8f 83       	std	Y+7, r24	; 0x07
    666a:	98 87       	std	Y+8, r25	; 0x08
	/* BR = (clock/(16*baud)) - 1*/
	u32 BRValue = (F_CPU/(16UL*baudRate)) - 1;
    666c:	8d 81       	ldd	r24, Y+5	; 0x05
    666e:	9e 81       	ldd	r25, Y+6	; 0x06
    6670:	af 81       	ldd	r26, Y+7	; 0x07
    6672:	b8 85       	ldd	r27, Y+8	; 0x08
    6674:	88 0f       	add	r24, r24
    6676:	99 1f       	adc	r25, r25
    6678:	aa 1f       	adc	r26, r26
    667a:	bb 1f       	adc	r27, r27
    667c:	88 0f       	add	r24, r24
    667e:	99 1f       	adc	r25, r25
    6680:	aa 1f       	adc	r26, r26
    6682:	bb 1f       	adc	r27, r27
    6684:	88 0f       	add	r24, r24
    6686:	99 1f       	adc	r25, r25
    6688:	aa 1f       	adc	r26, r26
    668a:	bb 1f       	adc	r27, r27
    668c:	88 0f       	add	r24, r24
    668e:	99 1f       	adc	r25, r25
    6690:	aa 1f       	adc	r26, r26
    6692:	bb 1f       	adc	r27, r27
    6694:	9c 01       	movw	r18, r24
    6696:	ad 01       	movw	r20, r26
    6698:	80 e0       	ldi	r24, 0x00	; 0
    669a:	92 e1       	ldi	r25, 0x12	; 18
    669c:	aa e7       	ldi	r26, 0x7A	; 122
    669e:	b0 e0       	ldi	r27, 0x00	; 0
    66a0:	bc 01       	movw	r22, r24
    66a2:	cd 01       	movw	r24, r26
    66a4:	0e 94 6f 36 	call	0x6cde	; 0x6cde <__udivmodsi4>
    66a8:	da 01       	movw	r26, r20
    66aa:	c9 01       	movw	r24, r18
    66ac:	01 97       	sbiw	r24, 0x01	; 1
    66ae:	a1 09       	sbc	r26, r1
    66b0:	b1 09       	sbc	r27, r1
    66b2:	89 83       	std	Y+1, r24	; 0x01
    66b4:	9a 83       	std	Y+2, r25	; 0x02
    66b6:	ab 83       	std	Y+3, r26	; 0x03
    66b8:	bc 83       	std	Y+4, r27	; 0x04
	
	/* Set baud rate */
	UCSRC &= ~(1<<URSEL);
    66ba:	a0 e4       	ldi	r26, 0x40	; 64
    66bc:	b0 e0       	ldi	r27, 0x00	; 0
    66be:	e0 e4       	ldi	r30, 0x40	; 64
    66c0:	f0 e0       	ldi	r31, 0x00	; 0
    66c2:	80 81       	ld	r24, Z
    66c4:	8f 77       	andi	r24, 0x7F	; 127
    66c6:	8c 93       	st	X, r24
	UBRRH = (u8)(BRValue>>8);
    66c8:	e0 e4       	ldi	r30, 0x40	; 64
    66ca:	f0 e0       	ldi	r31, 0x00	; 0
    66cc:	89 81       	ldd	r24, Y+1	; 0x01
    66ce:	9a 81       	ldd	r25, Y+2	; 0x02
    66d0:	ab 81       	ldd	r26, Y+3	; 0x03
    66d2:	bc 81       	ldd	r27, Y+4	; 0x04
    66d4:	89 2f       	mov	r24, r25
    66d6:	9a 2f       	mov	r25, r26
    66d8:	ab 2f       	mov	r26, r27
    66da:	bb 27       	eor	r27, r27
    66dc:	80 83       	st	Z, r24
	UBRRL = (u8)BRValue;
    66de:	e9 e2       	ldi	r30, 0x29	; 41
    66e0:	f0 e0       	ldi	r31, 0x00	; 0
    66e2:	89 81       	ldd	r24, Y+1	; 0x01
    66e4:	80 83       	st	Z, r24
	
	/* Enable receiver and transmitter */
	UCSRB = (1<<RXEN)|(1<<TXEN);//|(1<<RXCIE);
    66e6:	ea e2       	ldi	r30, 0x2A	; 42
    66e8:	f0 e0       	ldi	r31, 0x00	; 0
    66ea:	88 e1       	ldi	r24, 0x18	; 24
    66ec:	80 83       	st	Z, r24
	/* Set frame format: 8data, 2stop bit */
	UCSRC = (1<<URSEL)|(3<<UCSZ0);
    66ee:	e0 e4       	ldi	r30, 0x40	; 64
    66f0:	f0 e0       	ldi	r31, 0x00	; 0
    66f2:	86 e8       	ldi	r24, 0x86	; 134
    66f4:	80 83       	st	Z, r24
//	sei();
}
    66f6:	28 96       	adiw	r28, 0x08	; 8
    66f8:	0f b6       	in	r0, 0x3f	; 63
    66fa:	f8 94       	cli
    66fc:	de bf       	out	0x3e, r29	; 62
    66fe:	0f be       	out	0x3f, r0	; 63
    6700:	cd bf       	out	0x3d, r28	; 61
    6702:	cf 91       	pop	r28
    6704:	df 91       	pop	r29
    6706:	08 95       	ret

00006708 <Uart_SendByte>:
void	Uart_SendByte(u8 data){
    6708:	df 93       	push	r29
    670a:	cf 93       	push	r28
    670c:	0f 92       	push	r0
    670e:	cd b7       	in	r28, 0x3d	; 61
    6710:	de b7       	in	r29, 0x3e	; 62
    6712:	89 83       	std	Y+1, r24	; 0x01
	/* Wait for empty transmit buffer */
	while ( !( UCSRA & (1<<UDRE)) );
    6714:	eb e2       	ldi	r30, 0x2B	; 43
    6716:	f0 e0       	ldi	r31, 0x00	; 0
    6718:	80 81       	ld	r24, Z
    671a:	88 2f       	mov	r24, r24
    671c:	90 e0       	ldi	r25, 0x00	; 0
    671e:	80 72       	andi	r24, 0x20	; 32
    6720:	90 70       	andi	r25, 0x00	; 0
    6722:	00 97       	sbiw	r24, 0x00	; 0
    6724:	b9 f3       	breq	.-18     	; 0x6714 <Uart_SendByte+0xc>
	/* Put data into buffer, sends the data */
	UDR = data;
    6726:	ec e2       	ldi	r30, 0x2C	; 44
    6728:	f0 e0       	ldi	r31, 0x00	; 0
    672a:	89 81       	ldd	r24, Y+1	; 0x01
    672c:	80 83       	st	Z, r24
}
    672e:	0f 90       	pop	r0
    6730:	cf 91       	pop	r28
    6732:	df 91       	pop	r29
    6734:	08 95       	ret

00006736 <Uart_ReceiveByte>:
void	Uart_ReceiveByte(u8* pData){
    6736:	df 93       	push	r29
    6738:	cf 93       	push	r28
    673a:	00 d0       	rcall	.+0      	; 0x673c <Uart_ReceiveByte+0x6>
    673c:	cd b7       	in	r28, 0x3d	; 61
    673e:	de b7       	in	r29, 0x3e	; 62
    6740:	9a 83       	std	Y+2, r25	; 0x02
    6742:	89 83       	std	Y+1, r24	; 0x01
	/* Wait for data to be received */
	while ( !(UCSRA & (1<<RXC)) );
    6744:	eb e2       	ldi	r30, 0x2B	; 43
    6746:	f0 e0       	ldi	r31, 0x00	; 0
    6748:	80 81       	ld	r24, Z
    674a:	88 23       	and	r24, r24
    674c:	dc f7       	brge	.-10     	; 0x6744 <Uart_ReceiveByte+0xe>
	/* Get and return received data from buffer */
	(*pData) =  UDR;
    674e:	ec e2       	ldi	r30, 0x2C	; 44
    6750:	f0 e0       	ldi	r31, 0x00	; 0
    6752:	80 81       	ld	r24, Z
    6754:	e9 81       	ldd	r30, Y+1	; 0x01
    6756:	fa 81       	ldd	r31, Y+2	; 0x02
    6758:	80 83       	st	Z, r24
}
    675a:	0f 90       	pop	r0
    675c:	0f 90       	pop	r0
    675e:	cf 91       	pop	r28
    6760:	df 91       	pop	r29
    6762:	08 95       	ret

00006764 <Uart_ReceiveByte_Unblock>:
Bool	Uart_ReceiveByte_Unblock(u8* pData){
    6764:	df 93       	push	r29
    6766:	cf 93       	push	r28
    6768:	00 d0       	rcall	.+0      	; 0x676a <Uart_ReceiveByte_Unblock+0x6>
    676a:	0f 92       	push	r0
    676c:	cd b7       	in	r28, 0x3d	; 61
    676e:	de b7       	in	r29, 0x3e	; 62
    6770:	9b 83       	std	Y+3, r25	; 0x03
    6772:	8a 83       	std	Y+2, r24	; 0x02
	Bool result = FALSE;
    6774:	19 82       	std	Y+1, r1	; 0x01
	if(UCSRA & (1<<RXC)){
    6776:	eb e2       	ldi	r30, 0x2B	; 43
    6778:	f0 e0       	ldi	r31, 0x00	; 0
    677a:	80 81       	ld	r24, Z
    677c:	88 23       	and	r24, r24
    677e:	4c f4       	brge	.+18     	; 0x6792 <Uart_ReceiveByte_Unblock+0x2e>
		(*pData) =  UDR;
    6780:	ec e2       	ldi	r30, 0x2C	; 44
    6782:	f0 e0       	ldi	r31, 0x00	; 0
    6784:	80 81       	ld	r24, Z
    6786:	ea 81       	ldd	r30, Y+2	; 0x02
    6788:	fb 81       	ldd	r31, Y+3	; 0x03
    678a:	80 83       	st	Z, r24
		result =  TRUE;
    678c:	81 e0       	ldi	r24, 0x01	; 1
    678e:	89 83       	std	Y+1, r24	; 0x01
    6790:	01 c0       	rjmp	.+2      	; 0x6794 <Uart_ReceiveByte_Unblock+0x30>
	}
	else{
		result = FALSE;
    6792:	19 82       	std	Y+1, r1	; 0x01
	}
	return result;
    6794:	89 81       	ldd	r24, Y+1	; 0x01
}
    6796:	0f 90       	pop	r0
    6798:	0f 90       	pop	r0
    679a:	0f 90       	pop	r0
    679c:	cf 91       	pop	r28
    679e:	df 91       	pop	r29
    67a0:	08 95       	ret

000067a2 <Uart_SendStr>:
void	Uart_SendStr(u8* str){
    67a2:	df 93       	push	r29
    67a4:	cf 93       	push	r28
    67a6:	00 d0       	rcall	.+0      	; 0x67a8 <Uart_SendStr+0x6>
    67a8:	00 d0       	rcall	.+0      	; 0x67aa <Uart_SendStr+0x8>
    67aa:	00 d0       	rcall	.+0      	; 0x67ac <Uart_SendStr+0xa>
    67ac:	cd b7       	in	r28, 0x3d	; 61
    67ae:	de b7       	in	r29, 0x3e	; 62
    67b0:	9e 83       	std	Y+6, r25	; 0x06
    67b2:	8d 83       	std	Y+5, r24	; 0x05
	u32 ind = 0;
    67b4:	19 82       	std	Y+1, r1	; 0x01
    67b6:	1a 82       	std	Y+2, r1	; 0x02
    67b8:	1b 82       	std	Y+3, r1	; 0x03
    67ba:	1c 82       	std	Y+4, r1	; 0x04
    67bc:	15 c0       	rjmp	.+42     	; 0x67e8 <Uart_SendStr+0x46>
	while(str[ind] != 0){
		Uart_SendByte(str[ind]);
    67be:	29 81       	ldd	r18, Y+1	; 0x01
    67c0:	3a 81       	ldd	r19, Y+2	; 0x02
    67c2:	8d 81       	ldd	r24, Y+5	; 0x05
    67c4:	9e 81       	ldd	r25, Y+6	; 0x06
    67c6:	fc 01       	movw	r30, r24
    67c8:	e2 0f       	add	r30, r18
    67ca:	f3 1f       	adc	r31, r19
    67cc:	80 81       	ld	r24, Z
    67ce:	0e 94 84 33 	call	0x6708	; 0x6708 <Uart_SendByte>
		ind++;
    67d2:	89 81       	ldd	r24, Y+1	; 0x01
    67d4:	9a 81       	ldd	r25, Y+2	; 0x02
    67d6:	ab 81       	ldd	r26, Y+3	; 0x03
    67d8:	bc 81       	ldd	r27, Y+4	; 0x04
    67da:	01 96       	adiw	r24, 0x01	; 1
    67dc:	a1 1d       	adc	r26, r1
    67de:	b1 1d       	adc	r27, r1
    67e0:	89 83       	std	Y+1, r24	; 0x01
    67e2:	9a 83       	std	Y+2, r25	; 0x02
    67e4:	ab 83       	std	Y+3, r26	; 0x03
    67e6:	bc 83       	std	Y+4, r27	; 0x04
	}
	return result;
}
void	Uart_SendStr(u8* str){
	u32 ind = 0;
	while(str[ind] != 0){
    67e8:	29 81       	ldd	r18, Y+1	; 0x01
    67ea:	3a 81       	ldd	r19, Y+2	; 0x02
    67ec:	8d 81       	ldd	r24, Y+5	; 0x05
    67ee:	9e 81       	ldd	r25, Y+6	; 0x06
    67f0:	fc 01       	movw	r30, r24
    67f2:	e2 0f       	add	r30, r18
    67f4:	f3 1f       	adc	r31, r19
    67f6:	80 81       	ld	r24, Z
    67f8:	88 23       	and	r24, r24
    67fa:	09 f7       	brne	.-62     	; 0x67be <Uart_SendStr+0x1c>
		Uart_SendByte(str[ind]);
		ind++;
	}
}
    67fc:	26 96       	adiw	r28, 0x06	; 6
    67fe:	0f b6       	in	r0, 0x3f	; 63
    6800:	f8 94       	cli
    6802:	de bf       	out	0x3e, r29	; 62
    6804:	0f be       	out	0x3f, r0	; 63
    6806:	cd bf       	out	0x3d, r28	; 61
    6808:	cf 91       	pop	r28
    680a:	df 91       	pop	r29
    680c:	08 95       	ret

0000680e <__vector_13>:

ISR(USART_RXC_vect){
    680e:	1f 92       	push	r1
    6810:	0f 92       	push	r0
    6812:	0f b6       	in	r0, 0x3f	; 63
    6814:	0f 92       	push	r0
    6816:	11 24       	eor	r1, r1
    6818:	2f 93       	push	r18
    681a:	3f 93       	push	r19
    681c:	4f 93       	push	r20
    681e:	5f 93       	push	r21
    6820:	6f 93       	push	r22
    6822:	7f 93       	push	r23
    6824:	8f 93       	push	r24
    6826:	9f 93       	push	r25
    6828:	af 93       	push	r26
    682a:	bf 93       	push	r27
    682c:	ef 93       	push	r30
    682e:	ff 93       	push	r31
    6830:	df 93       	push	r29
    6832:	cf 93       	push	r28
    6834:	cd b7       	in	r28, 0x3d	; 61
    6836:	de b7       	in	r29, 0x3e	; 62
	LCD_DispCharXY(2,5,UDR);
    6838:	ec e2       	ldi	r30, 0x2C	; 44
    683a:	f0 e0       	ldi	r31, 0x00	; 0
    683c:	80 81       	ld	r24, Z
    683e:	28 2f       	mov	r18, r24
    6840:	30 e0       	ldi	r19, 0x00	; 0
    6842:	82 e0       	ldi	r24, 0x02	; 2
    6844:	90 e0       	ldi	r25, 0x00	; 0
    6846:	65 e0       	ldi	r22, 0x05	; 5
    6848:	70 e0       	ldi	r23, 0x00	; 0
    684a:	a9 01       	movw	r20, r18
    684c:	0e 94 b0 29 	call	0x5360	; 0x5360 <LCD_DispCharXY>
    6850:	cf 91       	pop	r28
    6852:	df 91       	pop	r29
    6854:	ff 91       	pop	r31
    6856:	ef 91       	pop	r30
    6858:	bf 91       	pop	r27
    685a:	af 91       	pop	r26
    685c:	9f 91       	pop	r25
    685e:	8f 91       	pop	r24
    6860:	7f 91       	pop	r23
    6862:	6f 91       	pop	r22
    6864:	5f 91       	pop	r21
    6866:	4f 91       	pop	r20
    6868:	3f 91       	pop	r19
    686a:	2f 91       	pop	r18
    686c:	0f 90       	pop	r0
    686e:	0f be       	out	0x3f, r0	; 63
    6870:	0f 90       	pop	r0
    6872:	1f 90       	pop	r1
    6874:	18 95       	reti

00006876 <main>:
SemaphoreHandle_t Fan_Semph = NULL;
QueueHandle_t  Queue_Handler = NULL;
QueueHandle_t  Data_Queue = NULL;

int main()
{
    6876:	af 92       	push	r10
    6878:	bf 92       	push	r11
    687a:	cf 92       	push	r12
    687c:	df 92       	push	r13
    687e:	ef 92       	push	r14
    6880:	ff 92       	push	r15
    6882:	0f 93       	push	r16
    6884:	df 93       	push	r29
    6886:	cf 93       	push	r28
    6888:	cd b7       	in	r28, 0x3d	; 61
    688a:	de b7       	in	r29, 0x3e	; 62
	/* Pr. Init */
	system_init();
    688c:	0e 94 c4 34 	call	0x6988	; 0x6988 <system_init>

	/* Create OS Objects */

	AC_Semph = xSemaphoreCreateBinary();
    6890:	81 e0       	ldi	r24, 0x01	; 1
    6892:	60 e0       	ldi	r22, 0x00	; 0
    6894:	43 e0       	ldi	r20, 0x03	; 3
    6896:	0e 94 0c 14 	call	0x2818	; 0x2818 <xQueueGenericCreate>
    689a:	90 93 46 07 	sts	0x0746, r25
    689e:	80 93 45 07 	sts	0x0745, r24
	Fan_Semph = xSemaphoreCreateBinary();
    68a2:	81 e0       	ldi	r24, 0x01	; 1
    68a4:	60 e0       	ldi	r22, 0x00	; 0
    68a6:	43 e0       	ldi	r20, 0x03	; 3
    68a8:	0e 94 0c 14 	call	0x2818	; 0x2818 <xQueueGenericCreate>
    68ac:	90 93 48 07 	sts	0x0748, r25
    68b0:	80 93 47 07 	sts	0x0747, r24

	Queue_Handler = xQueueCreate(5, 8);
    68b4:	85 e0       	ldi	r24, 0x05	; 5
    68b6:	68 e0       	ldi	r22, 0x08	; 8
    68b8:	40 e0       	ldi	r20, 0x00	; 0
    68ba:	0e 94 0c 14 	call	0x2818	; 0x2818 <xQueueGenericCreate>
    68be:	90 93 4a 07 	sts	0x074A, r25
    68c2:	80 93 49 07 	sts	0x0749, r24

	/* Create Tasks */
	xTaskCreate(ReadUart_Task, "ReadUart_Task", 120, NULL, 1, NULL);
    68c6:	8e ed       	ldi	r24, 0xDE	; 222
    68c8:	94 e3       	ldi	r25, 0x34	; 52
    68ca:	2d e7       	ldi	r18, 0x7D	; 125
    68cc:	30 e0       	ldi	r19, 0x00	; 0
    68ce:	b9 01       	movw	r22, r18
    68d0:	48 e7       	ldi	r20, 0x78	; 120
    68d2:	50 e0       	ldi	r21, 0x00	; 0
    68d4:	20 e0       	ldi	r18, 0x00	; 0
    68d6:	30 e0       	ldi	r19, 0x00	; 0
    68d8:	01 e0       	ldi	r16, 0x01	; 1
    68da:	ee 24       	eor	r14, r14
    68dc:	ff 24       	eor	r15, r15
    68de:	cc 24       	eor	r12, r12
    68e0:	dd 24       	eor	r13, r13
    68e2:	aa 24       	eor	r10, r10
    68e4:	bb 24       	eor	r11, r11
    68e6:	0e 94 32 1b 	call	0x3664	; 0x3664 <xTaskGenericCreate>
	xTaskCreate(DataParsing_Task, "DataParsing_Task", 140, NULL, 2, NULL);
    68ea:	87 e2       	ldi	r24, 0x27	; 39
    68ec:	95 e3       	ldi	r25, 0x35	; 53
    68ee:	2b e8       	ldi	r18, 0x8B	; 139
    68f0:	30 e0       	ldi	r19, 0x00	; 0
    68f2:	b9 01       	movw	r22, r18
    68f4:	4c e8       	ldi	r20, 0x8C	; 140
    68f6:	50 e0       	ldi	r21, 0x00	; 0
    68f8:	20 e0       	ldi	r18, 0x00	; 0
    68fa:	30 e0       	ldi	r19, 0x00	; 0
    68fc:	02 e0       	ldi	r16, 0x02	; 2
    68fe:	ee 24       	eor	r14, r14
    6900:	ff 24       	eor	r15, r15
    6902:	cc 24       	eor	r12, r12
    6904:	dd 24       	eor	r13, r13
    6906:	aa 24       	eor	r10, r10
    6908:	bb 24       	eor	r11, r11
    690a:	0e 94 32 1b 	call	0x3664	; 0x3664 <xTaskGenericCreate>
	xTaskCreate(ReadTemp_Task, "ReadTemp_Task", 120, NULL, 3, NULL);
    690e:	8b ec       	ldi	r24, 0xCB	; 203
    6910:	95 e3       	ldi	r25, 0x35	; 53
    6912:	2c e9       	ldi	r18, 0x9C	; 156
    6914:	30 e0       	ldi	r19, 0x00	; 0
    6916:	b9 01       	movw	r22, r18
    6918:	48 e7       	ldi	r20, 0x78	; 120
    691a:	50 e0       	ldi	r21, 0x00	; 0
    691c:	20 e0       	ldi	r18, 0x00	; 0
    691e:	30 e0       	ldi	r19, 0x00	; 0
    6920:	03 e0       	ldi	r16, 0x03	; 3
    6922:	ee 24       	eor	r14, r14
    6924:	ff 24       	eor	r15, r15
    6926:	cc 24       	eor	r12, r12
    6928:	dd 24       	eor	r13, r13
    692a:	aa 24       	eor	r10, r10
    692c:	bb 24       	eor	r11, r11
    692e:	0e 94 32 1b 	call	0x3664	; 0x3664 <xTaskGenericCreate>
	xTaskCreate(AC_Task, "AC_Task", 120, NULL, 4, NULL);
    6932:	80 e2       	ldi	r24, 0x20	; 32
    6934:	96 e3       	ldi	r25, 0x36	; 54
    6936:	2a ea       	ldi	r18, 0xAA	; 170
    6938:	30 e0       	ldi	r19, 0x00	; 0
    693a:	b9 01       	movw	r22, r18
    693c:	48 e7       	ldi	r20, 0x78	; 120
    693e:	50 e0       	ldi	r21, 0x00	; 0
    6940:	20 e0       	ldi	r18, 0x00	; 0
    6942:	30 e0       	ldi	r19, 0x00	; 0
    6944:	04 e0       	ldi	r16, 0x04	; 4
    6946:	ee 24       	eor	r14, r14
    6948:	ff 24       	eor	r15, r15
    694a:	cc 24       	eor	r12, r12
    694c:	dd 24       	eor	r13, r13
    694e:	aa 24       	eor	r10, r10
    6950:	bb 24       	eor	r11, r11
    6952:	0e 94 32 1b 	call	0x3664	; 0x3664 <xTaskGenericCreate>
	xTaskCreate(Fan_Task, "Fan_Task", 120, NULL, 5, NULL);
    6956:	88 e3       	ldi	r24, 0x38	; 56
    6958:	96 e3       	ldi	r25, 0x36	; 54
    695a:	22 eb       	ldi	r18, 0xB2	; 178
    695c:	30 e0       	ldi	r19, 0x00	; 0
    695e:	b9 01       	movw	r22, r18
    6960:	48 e7       	ldi	r20, 0x78	; 120
    6962:	50 e0       	ldi	r21, 0x00	; 0
    6964:	20 e0       	ldi	r18, 0x00	; 0
    6966:	30 e0       	ldi	r19, 0x00	; 0
    6968:	05 e0       	ldi	r16, 0x05	; 5
    696a:	ee 24       	eor	r14, r14
    696c:	ff 24       	eor	r15, r15
    696e:	cc 24       	eor	r12, r12
    6970:	dd 24       	eor	r13, r13
    6972:	aa 24       	eor	r10, r10
    6974:	bb 24       	eor	r11, r11
    6976:	0e 94 32 1b 	call	0x3664	; 0x3664 <xTaskGenericCreate>
	//	xTaskCreate(Action, "Action", 120, NULL, 6, NULL);

	//	/* Start OS */
	vTaskStartScheduler();
    697a:	0e 94 1d 1e 	call	0x3c3a	; 0x3c3a <vTaskStartScheduler>

	/* Unreachable Code */
	while(1)
	{
		LCD_DispStr("Error");
    697e:	8b eb       	ldi	r24, 0xBB	; 187
    6980:	90 e0       	ldi	r25, 0x00	; 0
    6982:	0e 94 87 29 	call	0x530e	; 0x530e <LCD_DispStr>
    6986:	fb cf       	rjmp	.-10     	; 0x697e <main+0x108>

00006988 <system_init>:
	}
	return 0;
}

void system_init(void){
    6988:	df 93       	push	r29
    698a:	cf 93       	push	r28
    698c:	cd b7       	in	r28, 0x3d	; 61
    698e:	de b7       	in	r29, 0x3e	; 62
	Uart_Init(9600);
    6990:	60 e8       	ldi	r22, 0x80	; 128
    6992:	75 e2       	ldi	r23, 0x25	; 37
    6994:	80 e0       	ldi	r24, 0x00	; 0
    6996:	90 e0       	ldi	r25, 0x00	; 0
    6998:	0e 94 28 33 	call	0x6650	; 0x6650 <Uart_Init>
	ADC_Init();
    699c:	0e 94 6b 25 	call	0x4ad6	; 0x4ad6 <ADC_Init>
	LCD_Init();
    69a0:	0e 94 4a 28 	call	0x5094	; 0x5094 <LCD_Init>
	Leds_AllInit();
    69a4:	0e 94 69 26 	call	0x4cd2	; 0x4cd2 <Leds_AllInit>
	LCD_DispStrXY(1, 1, "System Started");
    69a8:	21 ec       	ldi	r18, 0xC1	; 193
    69aa:	30 e0       	ldi	r19, 0x00	; 0
    69ac:	81 e0       	ldi	r24, 0x01	; 1
    69ae:	61 e0       	ldi	r22, 0x01	; 1
    69b0:	a9 01       	movw	r20, r18
    69b2:	0e 94 c6 29 	call	0x538c	; 0x538c <LCD_DispStrXY>
}
    69b6:	cf 91       	pop	r28
    69b8:	df 91       	pop	r29
    69ba:	08 95       	ret

000069bc <ReadUart_Task>:

void ReadUart_Task(void* pvParam)
{
    69bc:	df 93       	push	r29
    69be:	cf 93       	push	r28
    69c0:	cd b7       	in	r28, 0x3d	; 61
    69c2:	de b7       	in	r29, 0x3e	; 62
    69c4:	2c 97       	sbiw	r28, 0x0c	; 12
    69c6:	0f b6       	in	r0, 0x3f	; 63
    69c8:	f8 94       	cli
    69ca:	de bf       	out	0x3e, r29	; 62
    69cc:	0f be       	out	0x3f, r0	; 63
    69ce:	cd bf       	out	0x3d, r28	; 61
    69d0:	9c 87       	std	Y+12, r25	; 0x0c
    69d2:	8b 87       	std	Y+11, r24	; 0x0b
	u8 Local_Au8CharsArray[8] = {0};
    69d4:	88 e0       	ldi	r24, 0x08	; 8
    69d6:	fe 01       	movw	r30, r28
    69d8:	32 96       	adiw	r30, 0x02	; 2
    69da:	df 01       	movw	r26, r30
    69dc:	98 2f       	mov	r25, r24
    69de:	1d 92       	st	X+, r1
    69e0:	9a 95       	dec	r25
    69e2:	e9 f7       	brne	.-6      	; 0x69de <ReadUart_Task+0x22>
	u8 Local_u8Char = 0;
    69e4:	1a 86       	std	Y+10, r1	; 0x0a
	u8 Local_u8Counter = 0;
    69e6:	19 82       	std	Y+1, r1	; 0x01
	while(1)
	{
		//		Uart_SendStr("ReadUart_Task\r\n");
		if(Uart_ReceiveByte_Unblock(&Local_u8Char) == TRUE)
    69e8:	ce 01       	movw	r24, r28
    69ea:	0a 96       	adiw	r24, 0x0a	; 10
    69ec:	0e 94 b2 33 	call	0x6764	; 0x6764 <Uart_ReceiveByte_Unblock>
    69f0:	81 30       	cpi	r24, 0x01	; 1
    69f2:	41 f5       	brne	.+80     	; 0x6a44 <ReadUart_Task+0x88>
		{
			//New Data is received
			if(Local_u8Char != 13)
    69f4:	8a 85       	ldd	r24, Y+10	; 0x0a
    69f6:	8d 30       	cpi	r24, 0x0D	; 13
    69f8:	71 f0       	breq	.+28     	; 0x6a16 <ReadUart_Task+0x5a>
			{
				Local_Au8CharsArray[Local_u8Counter] = Local_u8Char;
    69fa:	89 81       	ldd	r24, Y+1	; 0x01
    69fc:	28 2f       	mov	r18, r24
    69fe:	30 e0       	ldi	r19, 0x00	; 0
    6a00:	4a 85       	ldd	r20, Y+10	; 0x0a
    6a02:	ce 01       	movw	r24, r28
    6a04:	02 96       	adiw	r24, 0x02	; 2
    6a06:	fc 01       	movw	r30, r24
    6a08:	e2 0f       	add	r30, r18
    6a0a:	f3 1f       	adc	r31, r19
    6a0c:	40 83       	st	Z, r20
				Local_u8Counter++;
    6a0e:	89 81       	ldd	r24, Y+1	; 0x01
    6a10:	8f 5f       	subi	r24, 0xFF	; 255
    6a12:	89 83       	std	Y+1, r24	; 0x01
    6a14:	17 c0       	rjmp	.+46     	; 0x6a44 <ReadUart_Task+0x88>
			}
			else
			{
				Local_Au8CharsArray[Local_u8Counter] = '\0';
    6a16:	89 81       	ldd	r24, Y+1	; 0x01
    6a18:	28 2f       	mov	r18, r24
    6a1a:	30 e0       	ldi	r19, 0x00	; 0
    6a1c:	ce 01       	movw	r24, r28
    6a1e:	02 96       	adiw	r24, 0x02	; 2
    6a20:	fc 01       	movw	r30, r24
    6a22:	e2 0f       	add	r30, r18
    6a24:	f3 1f       	adc	r31, r19
    6a26:	10 82       	st	Z, r1
				xQueueSend(Queue_Handler, Local_Au8CharsArray, portMAX_DELAY);
    6a28:	80 91 49 07 	lds	r24, 0x0749
    6a2c:	90 91 4a 07 	lds	r25, 0x074A
    6a30:	9e 01       	movw	r18, r28
    6a32:	2e 5f       	subi	r18, 0xFE	; 254
    6a34:	3f 4f       	sbci	r19, 0xFF	; 255
    6a36:	b9 01       	movw	r22, r18
    6a38:	4f ef       	ldi	r20, 0xFF	; 255
    6a3a:	5f ef       	ldi	r21, 0xFF	; 255
    6a3c:	20 e0       	ldi	r18, 0x00	; 0
    6a3e:	0e 94 d7 14 	call	0x29ae	; 0x29ae <xQueueGenericSend>
				Local_u8Counter = 0;
    6a42:	19 82       	std	Y+1, r1	; 0x01
			}

		}
		vTaskDelay(20);
    6a44:	84 e1       	ldi	r24, 0x14	; 20
    6a46:	90 e0       	ldi	r25, 0x00	; 0
    6a48:	0e 94 ec 1c 	call	0x39d8	; 0x39d8 <vTaskDelay>
    6a4c:	cd cf       	rjmp	.-102    	; 0x69e8 <ReadUart_Task+0x2c>

00006a4e <DataParsing_Task>:
	}
}

void DataParsing_Task(void* pvParam)
{
    6a4e:	df 93       	push	r29
    6a50:	cf 93       	push	r28
    6a52:	cd b7       	in	r28, 0x3d	; 61
    6a54:	de b7       	in	r29, 0x3e	; 62
    6a56:	61 97       	sbiw	r28, 0x11	; 17
    6a58:	0f b6       	in	r0, 0x3f	; 63
    6a5a:	f8 94       	cli
    6a5c:	de bf       	out	0x3e, r29	; 62
    6a5e:	0f be       	out	0x3f, r0	; 63
    6a60:	cd bf       	out	0x3d, r28	; 61
    6a62:	9f 87       	std	Y+15, r25	; 0x0f
    6a64:	8e 87       	std	Y+14, r24	; 0x0e
	u8 Local_Au8CharsArray[8] = {0};
    6a66:	88 e0       	ldi	r24, 0x08	; 8
    6a68:	fe 01       	movw	r30, r28
    6a6a:	33 96       	adiw	r30, 0x03	; 3
    6a6c:	df 01       	movw	r26, r30
    6a6e:	28 2f       	mov	r18, r24
    6a70:	1d 92       	st	X+, r1
    6a72:	2a 95       	dec	r18
    6a74:	e9 f7       	brne	.-6      	; 0x6a70 <DataParsing_Task+0x22>
	u8 Local_u8DataArray[3] = {0};
    6a76:	83 e0       	ldi	r24, 0x03	; 3
    6a78:	fe 01       	movw	r30, r28
    6a7a:	3b 96       	adiw	r30, 0x0b	; 11
    6a7c:	df 01       	movw	r26, r30
    6a7e:	28 2f       	mov	r18, r24
    6a80:	1d 92       	st	X+, r1
    6a82:	2a 95       	dec	r18
    6a84:	e9 f7       	brne	.-6      	; 0x6a80 <DataParsing_Task+0x32>
	u8 Local_u8Counter = 0;
    6a86:	1a 82       	std	Y+2, r1	; 0x02
	u8 Local_u8Counter2 = 0;
    6a88:	19 82       	std	Y+1, r1	; 0x01
	while(1)
	{
		Uart_SendStr("DataParsing_Task\r\n");
    6a8a:	80 ed       	ldi	r24, 0xD0	; 208
    6a8c:	90 e0       	ldi	r25, 0x00	; 0
    6a8e:	0e 94 d1 33 	call	0x67a2	; 0x67a2 <Uart_SendStr>
		if(xQueueReceive(Queue_Handler, Local_Au8CharsArray, portMAX_DELAY))
    6a92:	80 91 49 07 	lds	r24, 0x0749
    6a96:	90 91 4a 07 	lds	r25, 0x074A
    6a9a:	9e 01       	movw	r18, r28
    6a9c:	2d 5f       	subi	r18, 0xFD	; 253
    6a9e:	3f 4f       	sbci	r19, 0xFF	; 255
    6aa0:	b9 01       	movw	r22, r18
    6aa2:	4f ef       	ldi	r20, 0xFF	; 255
    6aa4:	5f ef       	ldi	r21, 0xFF	; 255
    6aa6:	20 e0       	ldi	r18, 0x00	; 0
    6aa8:	0e 94 e5 15 	call	0x2bca	; 0x2bca <xQueueGenericReceive>
    6aac:	88 23       	and	r24, r24
    6aae:	09 f4       	brne	.+2      	; 0x6ab2 <DataParsing_Task+0x64>
    6ab0:	6f c0       	rjmp	.+222    	; 0x6b90 <DataParsing_Task+0x142>
    6ab2:	23 c0       	rjmp	.+70     	; 0x6afa <DataParsing_Task+0xac>
		{
			//A frame is successfully received.
			while(Local_Au8CharsArray[Local_u8Counter] != '#')
			{
				if(Local_Au8CharsArray[Local_u8Counter] != '*')
    6ab4:	8a 81       	ldd	r24, Y+2	; 0x02
    6ab6:	28 2f       	mov	r18, r24
    6ab8:	30 e0       	ldi	r19, 0x00	; 0
    6aba:	ce 01       	movw	r24, r28
    6abc:	03 96       	adiw	r24, 0x03	; 3
    6abe:	fc 01       	movw	r30, r24
    6ac0:	e2 0f       	add	r30, r18
    6ac2:	f3 1f       	adc	r31, r19
    6ac4:	80 81       	ld	r24, Z
    6ac6:	8a 32       	cpi	r24, 0x2A	; 42
    6ac8:	a9 f0       	breq	.+42     	; 0x6af4 <DataParsing_Task+0xa6>
				{
					Local_u8DataArray[Local_u8Counter2] = Local_Au8CharsArray[Local_u8Counter];
    6aca:	89 81       	ldd	r24, Y+1	; 0x01
    6acc:	48 2f       	mov	r20, r24
    6ace:	50 e0       	ldi	r21, 0x00	; 0
    6ad0:	8a 81       	ldd	r24, Y+2	; 0x02
    6ad2:	28 2f       	mov	r18, r24
    6ad4:	30 e0       	ldi	r19, 0x00	; 0
    6ad6:	ce 01       	movw	r24, r28
    6ad8:	03 96       	adiw	r24, 0x03	; 3
    6ada:	fc 01       	movw	r30, r24
    6adc:	e2 0f       	add	r30, r18
    6ade:	f3 1f       	adc	r31, r19
    6ae0:	20 81       	ld	r18, Z
    6ae2:	ce 01       	movw	r24, r28
    6ae4:	0b 96       	adiw	r24, 0x0b	; 11
    6ae6:	fc 01       	movw	r30, r24
    6ae8:	e4 0f       	add	r30, r20
    6aea:	f5 1f       	adc	r31, r21
    6aec:	20 83       	st	Z, r18
					Local_u8Counter2++;
    6aee:	89 81       	ldd	r24, Y+1	; 0x01
    6af0:	8f 5f       	subi	r24, 0xFF	; 255
    6af2:	89 83       	std	Y+1, r24	; 0x01
				}

				Local_u8Counter++;
    6af4:	8a 81       	ldd	r24, Y+2	; 0x02
    6af6:	8f 5f       	subi	r24, 0xFF	; 255
    6af8:	8a 83       	std	Y+2, r24	; 0x02
	{
		Uart_SendStr("DataParsing_Task\r\n");
		if(xQueueReceive(Queue_Handler, Local_Au8CharsArray, portMAX_DELAY))
		{
			//A frame is successfully received.
			while(Local_Au8CharsArray[Local_u8Counter] != '#')
    6afa:	8a 81       	ldd	r24, Y+2	; 0x02
    6afc:	28 2f       	mov	r18, r24
    6afe:	30 e0       	ldi	r19, 0x00	; 0
    6b00:	ce 01       	movw	r24, r28
    6b02:	03 96       	adiw	r24, 0x03	; 3
    6b04:	fc 01       	movw	r30, r24
    6b06:	e2 0f       	add	r30, r18
    6b08:	f3 1f       	adc	r31, r19
    6b0a:	80 81       	ld	r24, Z
    6b0c:	83 32       	cpi	r24, 0x23	; 35
    6b0e:	91 f6       	brne	.-92     	; 0x6ab4 <DataParsing_Task+0x66>
				}

				Local_u8Counter++;
			}

			if(Local_u8DataArray[0] == 'i')
    6b10:	8b 85       	ldd	r24, Y+11	; 0x0b
    6b12:	89 36       	cpi	r24, 0x69	; 105
    6b14:	e9 f5       	brne	.+122    	; 0x6b90 <DataParsing_Task+0x142>
			{
				switch(Local_u8DataArray[1])
    6b16:	8c 85       	ldd	r24, Y+12	; 0x0c
    6b18:	a8 2f       	mov	r26, r24
    6b1a:	b0 e0       	ldi	r27, 0x00	; 0
    6b1c:	b9 8b       	std	Y+17, r27	; 0x11
    6b1e:	a8 8b       	std	Y+16, r26	; 0x10
    6b20:	28 89       	ldd	r18, Y+16	; 0x10
    6b22:	39 89       	ldd	r19, Y+17	; 0x11
    6b24:	22 33       	cpi	r18, 0x32	; 50
    6b26:	31 05       	cpc	r19, r1
    6b28:	c1 f0       	breq	.+48     	; 0x6b5a <DataParsing_Task+0x10c>
    6b2a:	88 89       	ldd	r24, Y+16	; 0x10
    6b2c:	99 89       	ldd	r25, Y+17	; 0x11
    6b2e:	83 33       	cpi	r24, 0x33	; 51
    6b30:	91 05       	cpc	r25, r1
    6b32:	09 f1       	breq	.+66     	; 0x6b76 <DataParsing_Task+0x128>
    6b34:	a8 89       	ldd	r26, Y+16	; 0x10
    6b36:	b9 89       	ldd	r27, Y+17	; 0x11
    6b38:	a1 33       	cpi	r26, 0x31	; 49
    6b3a:	b1 05       	cpc	r27, r1
    6b3c:	49 f5       	brne	.+82     	; 0x6b90 <DataParsing_Task+0x142>
				{
				case '1':
					if(Local_u8DataArray[2] == '1')
    6b3e:	8d 85       	ldd	r24, Y+13	; 0x0d
    6b40:	81 33       	cpi	r24, 0x31	; 49
    6b42:	21 f4       	brne	.+8      	; 0x6b4c <DataParsing_Task+0xfe>
					{
						Led_On(LED3);
    6b44:	83 e0       	ldi	r24, 0x03	; 3
    6b46:	0e 94 c4 25 	call	0x4b88	; 0x4b88 <Led_On>
    6b4a:	22 c0       	rjmp	.+68     	; 0x6b90 <DataParsing_Task+0x142>
					}
					else if(Local_u8DataArray[2] == '0')
    6b4c:	8d 85       	ldd	r24, Y+13	; 0x0d
    6b4e:	80 33       	cpi	r24, 0x30	; 48
    6b50:	f9 f4       	brne	.+62     	; 0x6b90 <DataParsing_Task+0x142>
					{
						Led_Off(LED3);
    6b52:	83 e0       	ldi	r24, 0x03	; 3
    6b54:	0e 94 e1 25 	call	0x4bc2	; 0x4bc2 <Led_Off>
    6b58:	1b c0       	rjmp	.+54     	; 0x6b90 <DataParsing_Task+0x142>
					}
					break;
				case '2':
					if(Local_u8DataArray[2] == '1')
    6b5a:	8d 85       	ldd	r24, Y+13	; 0x0d
    6b5c:	81 33       	cpi	r24, 0x31	; 49
    6b5e:	21 f4       	brne	.+8      	; 0x6b68 <DataParsing_Task+0x11a>
					{
						Led_On(LED4);
    6b60:	84 e0       	ldi	r24, 0x04	; 4
    6b62:	0e 94 c4 25 	call	0x4b88	; 0x4b88 <Led_On>
    6b66:	14 c0       	rjmp	.+40     	; 0x6b90 <DataParsing_Task+0x142>
					}
					else if(Local_u8DataArray[2] == '0')
    6b68:	8d 85       	ldd	r24, Y+13	; 0x0d
    6b6a:	80 33       	cpi	r24, 0x30	; 48
    6b6c:	89 f4       	brne	.+34     	; 0x6b90 <DataParsing_Task+0x142>
					{
						Led_Off(LED4);
    6b6e:	84 e0       	ldi	r24, 0x04	; 4
    6b70:	0e 94 e1 25 	call	0x4bc2	; 0x4bc2 <Led_Off>
    6b74:	0d c0       	rjmp	.+26     	; 0x6b90 <DataParsing_Task+0x142>
					}
					break;
				case '3':
					if(Local_u8DataArray[2] == '1')
    6b76:	8d 85       	ldd	r24, Y+13	; 0x0d
    6b78:	81 33       	cpi	r24, 0x31	; 49
    6b7a:	21 f4       	brne	.+8      	; 0x6b84 <DataParsing_Task+0x136>
					{
						Led_On(LED5);
    6b7c:	85 e0       	ldi	r24, 0x05	; 5
    6b7e:	0e 94 c4 25 	call	0x4b88	; 0x4b88 <Led_On>
    6b82:	06 c0       	rjmp	.+12     	; 0x6b90 <DataParsing_Task+0x142>
					}
					else if(Local_u8DataArray[2] == '0')
    6b84:	8d 85       	ldd	r24, Y+13	; 0x0d
    6b86:	80 33       	cpi	r24, 0x30	; 48
    6b88:	19 f4       	brne	.+6      	; 0x6b90 <DataParsing_Task+0x142>
					{
						Led_Off(LED5);
    6b8a:	85 e0       	ldi	r24, 0x05	; 5
    6b8c:	0e 94 e1 25 	call	0x4bc2	; 0x4bc2 <Led_Off>
			}



		}
		Local_u8Counter = 0;
    6b90:	1a 82       	std	Y+2, r1	; 0x02
		Local_u8Counter2 = 0;
    6b92:	19 82       	std	Y+1, r1	; 0x01
    6b94:	7a cf       	rjmp	.-268    	; 0x6a8a <DataParsing_Task+0x3c>

00006b96 <ReadTemp_Task>:
//		}
//	}
//}

void ReadTemp_Task(void * pvParam)
{
    6b96:	df 93       	push	r29
    6b98:	cf 93       	push	r28
    6b9a:	00 d0       	rcall	.+0      	; 0x6b9c <ReadTemp_Task+0x6>
    6b9c:	00 d0       	rcall	.+0      	; 0x6b9e <ReadTemp_Task+0x8>
    6b9e:	00 d0       	rcall	.+0      	; 0x6ba0 <ReadTemp_Task+0xa>
    6ba0:	cd b7       	in	r28, 0x3d	; 61
    6ba2:	de b7       	in	r29, 0x3e	; 62
    6ba4:	9e 83       	std	Y+6, r25	; 0x06
    6ba6:	8d 83       	std	Y+5, r24	; 0x05
	u16 Local_u16DigitalRead = 0;
    6ba8:	1c 82       	std	Y+4, r1	; 0x04
    6baa:	1b 82       	std	Y+3, r1	; 0x03
	u16 Local_u16AnalogRead = 0;
    6bac:	1a 82       	std	Y+2, r1	; 0x02
    6bae:	19 82       	std	Y+1, r1	; 0x01
	while(1)
	{
		//		Uart_SendStr("ReadTemp_Task\r\n");
		Led_Off(LED1);
    6bb0:	81 e0       	ldi	r24, 0x01	; 1
    6bb2:	0e 94 e1 25 	call	0x4bc2	; 0x4bc2 <Led_Off>
		Led_Off(LED2);
    6bb6:	82 e0       	ldi	r24, 0x02	; 2
    6bb8:	0e 94 e1 25 	call	0x4bc2	; 0x4bc2 <Led_Off>

		Local_u16DigitalRead = ADC_Read(ADC_CH0);
    6bbc:	80 e0       	ldi	r24, 0x00	; 0
    6bbe:	0e 94 82 25 	call	0x4b04	; 0x4b04 <ADC_Read>
    6bc2:	9c 83       	std	Y+4, r25	; 0x04
    6bc4:	8b 83       	std	Y+3, r24	; 0x03
		Local_u16AnalogRead = (Local_u16DigitalRead * 500) / 1024;
    6bc6:	2b 81       	ldd	r18, Y+3	; 0x03
    6bc8:	3c 81       	ldd	r19, Y+4	; 0x04
    6bca:	84 ef       	ldi	r24, 0xF4	; 244
    6bcc:	91 e0       	ldi	r25, 0x01	; 1
    6bce:	ac 01       	movw	r20, r24
    6bd0:	24 9f       	mul	r18, r20
    6bd2:	c0 01       	movw	r24, r0
    6bd4:	25 9f       	mul	r18, r21
    6bd6:	90 0d       	add	r25, r0
    6bd8:	34 9f       	mul	r19, r20
    6bda:	90 0d       	add	r25, r0
    6bdc:	11 24       	eor	r1, r1
    6bde:	89 2f       	mov	r24, r25
    6be0:	99 27       	eor	r25, r25
    6be2:	86 95       	lsr	r24
    6be4:	86 95       	lsr	r24
    6be6:	9a 83       	std	Y+2, r25	; 0x02
    6be8:	89 83       	std	Y+1, r24	; 0x01
		if(Local_u16AnalogRead >= 35)
    6bea:	89 81       	ldd	r24, Y+1	; 0x01
    6bec:	9a 81       	ldd	r25, Y+2	; 0x02
    6bee:	83 32       	cpi	r24, 0x23	; 35
    6bf0:	91 05       	cpc	r25, r1
    6bf2:	60 f0       	brcs	.+24     	; 0x6c0c <ReadTemp_Task+0x76>
		{
			// Turn on the AC
			xSemaphoreGive(AC_Semph);
    6bf4:	80 91 45 07 	lds	r24, 0x0745
    6bf8:	90 91 46 07 	lds	r25, 0x0746
    6bfc:	60 e0       	ldi	r22, 0x00	; 0
    6bfe:	70 e0       	ldi	r23, 0x00	; 0
    6c00:	40 e0       	ldi	r20, 0x00	; 0
    6c02:	50 e0       	ldi	r21, 0x00	; 0
    6c04:	20 e0       	ldi	r18, 0x00	; 0
    6c06:	0e 94 d7 14 	call	0x29ae	; 0x29ae <xQueueGenericSend>
    6c0a:	15 c0       	rjmp	.+42     	; 0x6c36 <ReadTemp_Task+0xa0>
		}
		else if(Local_u16AnalogRead >= 30 && Local_u16AnalogRead <= 35)
    6c0c:	89 81       	ldd	r24, Y+1	; 0x01
    6c0e:	9a 81       	ldd	r25, Y+2	; 0x02
    6c10:	8e 31       	cpi	r24, 0x1E	; 30
    6c12:	91 05       	cpc	r25, r1
    6c14:	80 f0       	brcs	.+32     	; 0x6c36 <ReadTemp_Task+0xa0>
    6c16:	89 81       	ldd	r24, Y+1	; 0x01
    6c18:	9a 81       	ldd	r25, Y+2	; 0x02
    6c1a:	84 32       	cpi	r24, 0x24	; 36
    6c1c:	91 05       	cpc	r25, r1
    6c1e:	58 f4       	brcc	.+22     	; 0x6c36 <ReadTemp_Task+0xa0>
		{
			//Turn on the Fan
			xSemaphoreGive(Fan_Semph);
    6c20:	80 91 47 07 	lds	r24, 0x0747
    6c24:	90 91 48 07 	lds	r25, 0x0748
    6c28:	60 e0       	ldi	r22, 0x00	; 0
    6c2a:	70 e0       	ldi	r23, 0x00	; 0
    6c2c:	40 e0       	ldi	r20, 0x00	; 0
    6c2e:	50 e0       	ldi	r21, 0x00	; 0
    6c30:	20 e0       	ldi	r18, 0x00	; 0
    6c32:	0e 94 d7 14 	call	0x29ae	; 0x29ae <xQueueGenericSend>
		else
		{
			// DoNothing
		}

		vTaskDelay(300);
    6c36:	8c e2       	ldi	r24, 0x2C	; 44
    6c38:	91 e0       	ldi	r25, 0x01	; 1
    6c3a:	0e 94 ec 1c 	call	0x39d8	; 0x39d8 <vTaskDelay>
    6c3e:	b8 cf       	rjmp	.-144    	; 0x6bb0 <ReadTemp_Task+0x1a>

00006c40 <AC_Task>:
	}
}
void AC_Task(void* pvParam)
{
    6c40:	df 93       	push	r29
    6c42:	cf 93       	push	r28
    6c44:	00 d0       	rcall	.+0      	; 0x6c46 <AC_Task+0x6>
    6c46:	cd b7       	in	r28, 0x3d	; 61
    6c48:	de b7       	in	r29, 0x3e	; 62
    6c4a:	9a 83       	std	Y+2, r25	; 0x02
    6c4c:	89 83       	std	Y+1, r24	; 0x01
	while(1)
	{
		//		Uart_SendStr("AC_Task\r\n");
		if(xSemaphoreTake(AC_Semph, portMAX_DELAY) == pdTRUE)
    6c4e:	80 91 45 07 	lds	r24, 0x0745
    6c52:	90 91 46 07 	lds	r25, 0x0746
    6c56:	60 e0       	ldi	r22, 0x00	; 0
    6c58:	70 e0       	ldi	r23, 0x00	; 0
    6c5a:	4f ef       	ldi	r20, 0xFF	; 255
    6c5c:	5f ef       	ldi	r21, 0xFF	; 255
    6c5e:	20 e0       	ldi	r18, 0x00	; 0
    6c60:	0e 94 e5 15 	call	0x2bca	; 0x2bca <xQueueGenericReceive>
    6c64:	81 30       	cpi	r24, 0x01	; 1
    6c66:	99 f7       	brne	.-26     	; 0x6c4e <AC_Task+0xe>
		{
			// Semaphore successfully taken.
			Led_On(LED2);
    6c68:	82 e0       	ldi	r24, 0x02	; 2
    6c6a:	0e 94 c4 25 	call	0x4b88	; 0x4b88 <Led_On>
    6c6e:	ef cf       	rjmp	.-34     	; 0x6c4e <AC_Task+0xe>

00006c70 <Fan_Task>:
		}
	}
}

void Fan_Task(void* pvParam)
{
    6c70:	df 93       	push	r29
    6c72:	cf 93       	push	r28
    6c74:	00 d0       	rcall	.+0      	; 0x6c76 <Fan_Task+0x6>
    6c76:	cd b7       	in	r28, 0x3d	; 61
    6c78:	de b7       	in	r29, 0x3e	; 62
    6c7a:	9a 83       	std	Y+2, r25	; 0x02
    6c7c:	89 83       	std	Y+1, r24	; 0x01
	while(1)
	{

		//		Uart_SendStr("Fan_Task\r\n");
		if(xSemaphoreTake(Fan_Semph, portMAX_DELAY) == pdTRUE)
    6c7e:	80 91 47 07 	lds	r24, 0x0747
    6c82:	90 91 48 07 	lds	r25, 0x0748
    6c86:	60 e0       	ldi	r22, 0x00	; 0
    6c88:	70 e0       	ldi	r23, 0x00	; 0
    6c8a:	4f ef       	ldi	r20, 0xFF	; 255
    6c8c:	5f ef       	ldi	r21, 0xFF	; 255
    6c8e:	20 e0       	ldi	r18, 0x00	; 0
    6c90:	0e 94 e5 15 	call	0x2bca	; 0x2bca <xQueueGenericReceive>
    6c94:	81 30       	cpi	r24, 0x01	; 1
    6c96:	99 f7       	brne	.-26     	; 0x6c7e <Fan_Task+0xe>
		{
			// Semaphore successfully taken.
			Led_On(LED1);
    6c98:	81 e0       	ldi	r24, 0x01	; 1
    6c9a:	0e 94 c4 25 	call	0x4b88	; 0x4b88 <Led_On>
    6c9e:	ef cf       	rjmp	.-34     	; 0x6c7e <Fan_Task+0xe>

00006ca0 <__mulsi3>:
    6ca0:	62 9f       	mul	r22, r18
    6ca2:	d0 01       	movw	r26, r0
    6ca4:	73 9f       	mul	r23, r19
    6ca6:	f0 01       	movw	r30, r0
    6ca8:	82 9f       	mul	r24, r18
    6caa:	e0 0d       	add	r30, r0
    6cac:	f1 1d       	adc	r31, r1
    6cae:	64 9f       	mul	r22, r20
    6cb0:	e0 0d       	add	r30, r0
    6cb2:	f1 1d       	adc	r31, r1
    6cb4:	92 9f       	mul	r25, r18
    6cb6:	f0 0d       	add	r31, r0
    6cb8:	83 9f       	mul	r24, r19
    6cba:	f0 0d       	add	r31, r0
    6cbc:	74 9f       	mul	r23, r20
    6cbe:	f0 0d       	add	r31, r0
    6cc0:	65 9f       	mul	r22, r21
    6cc2:	f0 0d       	add	r31, r0
    6cc4:	99 27       	eor	r25, r25
    6cc6:	72 9f       	mul	r23, r18
    6cc8:	b0 0d       	add	r27, r0
    6cca:	e1 1d       	adc	r30, r1
    6ccc:	f9 1f       	adc	r31, r25
    6cce:	63 9f       	mul	r22, r19
    6cd0:	b0 0d       	add	r27, r0
    6cd2:	e1 1d       	adc	r30, r1
    6cd4:	f9 1f       	adc	r31, r25
    6cd6:	bd 01       	movw	r22, r26
    6cd8:	cf 01       	movw	r24, r30
    6cda:	11 24       	eor	r1, r1
    6cdc:	08 95       	ret

00006cde <__udivmodsi4>:
    6cde:	a1 e2       	ldi	r26, 0x21	; 33
    6ce0:	1a 2e       	mov	r1, r26
    6ce2:	aa 1b       	sub	r26, r26
    6ce4:	bb 1b       	sub	r27, r27
    6ce6:	fd 01       	movw	r30, r26
    6ce8:	0d c0       	rjmp	.+26     	; 0x6d04 <__udivmodsi4_ep>

00006cea <__udivmodsi4_loop>:
    6cea:	aa 1f       	adc	r26, r26
    6cec:	bb 1f       	adc	r27, r27
    6cee:	ee 1f       	adc	r30, r30
    6cf0:	ff 1f       	adc	r31, r31
    6cf2:	a2 17       	cp	r26, r18
    6cf4:	b3 07       	cpc	r27, r19
    6cf6:	e4 07       	cpc	r30, r20
    6cf8:	f5 07       	cpc	r31, r21
    6cfa:	20 f0       	brcs	.+8      	; 0x6d04 <__udivmodsi4_ep>
    6cfc:	a2 1b       	sub	r26, r18
    6cfe:	b3 0b       	sbc	r27, r19
    6d00:	e4 0b       	sbc	r30, r20
    6d02:	f5 0b       	sbc	r31, r21

00006d04 <__udivmodsi4_ep>:
    6d04:	66 1f       	adc	r22, r22
    6d06:	77 1f       	adc	r23, r23
    6d08:	88 1f       	adc	r24, r24
    6d0a:	99 1f       	adc	r25, r25
    6d0c:	1a 94       	dec	r1
    6d0e:	69 f7       	brne	.-38     	; 0x6cea <__udivmodsi4_loop>
    6d10:	60 95       	com	r22
    6d12:	70 95       	com	r23
    6d14:	80 95       	com	r24
    6d16:	90 95       	com	r25
    6d18:	9b 01       	movw	r18, r22
    6d1a:	ac 01       	movw	r20, r24
    6d1c:	bd 01       	movw	r22, r26
    6d1e:	cf 01       	movw	r24, r30
    6d20:	08 95       	ret

00006d22 <__divmodsi4>:
    6d22:	97 fb       	bst	r25, 7
    6d24:	09 2e       	mov	r0, r25
    6d26:	05 26       	eor	r0, r21
    6d28:	0e d0       	rcall	.+28     	; 0x6d46 <__divmodsi4_neg1>
    6d2a:	57 fd       	sbrc	r21, 7
    6d2c:	04 d0       	rcall	.+8      	; 0x6d36 <__divmodsi4_neg2>
    6d2e:	d7 df       	rcall	.-82     	; 0x6cde <__udivmodsi4>
    6d30:	0a d0       	rcall	.+20     	; 0x6d46 <__divmodsi4_neg1>
    6d32:	00 1c       	adc	r0, r0
    6d34:	38 f4       	brcc	.+14     	; 0x6d44 <__divmodsi4_exit>

00006d36 <__divmodsi4_neg2>:
    6d36:	50 95       	com	r21
    6d38:	40 95       	com	r20
    6d3a:	30 95       	com	r19
    6d3c:	21 95       	neg	r18
    6d3e:	3f 4f       	sbci	r19, 0xFF	; 255
    6d40:	4f 4f       	sbci	r20, 0xFF	; 255
    6d42:	5f 4f       	sbci	r21, 0xFF	; 255

00006d44 <__divmodsi4_exit>:
    6d44:	08 95       	ret

00006d46 <__divmodsi4_neg1>:
    6d46:	f6 f7       	brtc	.-4      	; 0x6d44 <__divmodsi4_exit>
    6d48:	90 95       	com	r25
    6d4a:	80 95       	com	r24
    6d4c:	70 95       	com	r23
    6d4e:	61 95       	neg	r22
    6d50:	7f 4f       	sbci	r23, 0xFF	; 255
    6d52:	8f 4f       	sbci	r24, 0xFF	; 255
    6d54:	9f 4f       	sbci	r25, 0xFF	; 255
    6d56:	08 95       	ret

00006d58 <__prologue_saves__>:
    6d58:	2f 92       	push	r2
    6d5a:	3f 92       	push	r3
    6d5c:	4f 92       	push	r4
    6d5e:	5f 92       	push	r5
    6d60:	6f 92       	push	r6
    6d62:	7f 92       	push	r7
    6d64:	8f 92       	push	r8
    6d66:	9f 92       	push	r9
    6d68:	af 92       	push	r10
    6d6a:	bf 92       	push	r11
    6d6c:	cf 92       	push	r12
    6d6e:	df 92       	push	r13
    6d70:	ef 92       	push	r14
    6d72:	ff 92       	push	r15
    6d74:	0f 93       	push	r16
    6d76:	1f 93       	push	r17
    6d78:	cf 93       	push	r28
    6d7a:	df 93       	push	r29
    6d7c:	cd b7       	in	r28, 0x3d	; 61
    6d7e:	de b7       	in	r29, 0x3e	; 62
    6d80:	ca 1b       	sub	r28, r26
    6d82:	db 0b       	sbc	r29, r27
    6d84:	0f b6       	in	r0, 0x3f	; 63
    6d86:	f8 94       	cli
    6d88:	de bf       	out	0x3e, r29	; 62
    6d8a:	0f be       	out	0x3f, r0	; 63
    6d8c:	cd bf       	out	0x3d, r28	; 61
    6d8e:	09 94       	ijmp

00006d90 <__epilogue_restores__>:
    6d90:	2a 88       	ldd	r2, Y+18	; 0x12
    6d92:	39 88       	ldd	r3, Y+17	; 0x11
    6d94:	48 88       	ldd	r4, Y+16	; 0x10
    6d96:	5f 84       	ldd	r5, Y+15	; 0x0f
    6d98:	6e 84       	ldd	r6, Y+14	; 0x0e
    6d9a:	7d 84       	ldd	r7, Y+13	; 0x0d
    6d9c:	8c 84       	ldd	r8, Y+12	; 0x0c
    6d9e:	9b 84       	ldd	r9, Y+11	; 0x0b
    6da0:	aa 84       	ldd	r10, Y+10	; 0x0a
    6da2:	b9 84       	ldd	r11, Y+9	; 0x09
    6da4:	c8 84       	ldd	r12, Y+8	; 0x08
    6da6:	df 80       	ldd	r13, Y+7	; 0x07
    6da8:	ee 80       	ldd	r14, Y+6	; 0x06
    6daa:	fd 80       	ldd	r15, Y+5	; 0x05
    6dac:	0c 81       	ldd	r16, Y+4	; 0x04
    6dae:	1b 81       	ldd	r17, Y+3	; 0x03
    6db0:	aa 81       	ldd	r26, Y+2	; 0x02
    6db2:	b9 81       	ldd	r27, Y+1	; 0x01
    6db4:	ce 0f       	add	r28, r30
    6db6:	d1 1d       	adc	r29, r1
    6db8:	0f b6       	in	r0, 0x3f	; 63
    6dba:	f8 94       	cli
    6dbc:	de bf       	out	0x3e, r29	; 62
    6dbe:	0f be       	out	0x3f, r0	; 63
    6dc0:	cd bf       	out	0x3d, r28	; 61
    6dc2:	ed 01       	movw	r28, r26
    6dc4:	08 95       	ret

00006dc6 <memcpy>:
    6dc6:	fb 01       	movw	r30, r22
    6dc8:	dc 01       	movw	r26, r24
    6dca:	02 c0       	rjmp	.+4      	; 0x6dd0 <memcpy+0xa>
    6dcc:	01 90       	ld	r0, Z+
    6dce:	0d 92       	st	X+, r0
    6dd0:	41 50       	subi	r20, 0x01	; 1
    6dd2:	50 40       	sbci	r21, 0x00	; 0
    6dd4:	d8 f7       	brcc	.-10     	; 0x6dcc <memcpy+0x6>
    6dd6:	08 95       	ret

00006dd8 <itoa>:
    6dd8:	fb 01       	movw	r30, r22
    6dda:	9f 01       	movw	r18, r30
    6ddc:	e8 94       	clt
    6dde:	42 30       	cpi	r20, 0x02	; 2
    6de0:	c4 f0       	brlt	.+48     	; 0x6e12 <itoa+0x3a>
    6de2:	45 32       	cpi	r20, 0x25	; 37
    6de4:	b4 f4       	brge	.+44     	; 0x6e12 <itoa+0x3a>
    6de6:	4a 30       	cpi	r20, 0x0A	; 10
    6de8:	29 f4       	brne	.+10     	; 0x6df4 <itoa+0x1c>
    6dea:	97 fb       	bst	r25, 7
    6dec:	1e f4       	brtc	.+6      	; 0x6df4 <itoa+0x1c>
    6dee:	90 95       	com	r25
    6df0:	81 95       	neg	r24
    6df2:	9f 4f       	sbci	r25, 0xFF	; 255
    6df4:	64 2f       	mov	r22, r20
    6df6:	77 27       	eor	r23, r23
    6df8:	0e 94 1d 37 	call	0x6e3a	; 0x6e3a <__udivmodhi4>
    6dfc:	80 5d       	subi	r24, 0xD0	; 208
    6dfe:	8a 33       	cpi	r24, 0x3A	; 58
    6e00:	0c f0       	brlt	.+2      	; 0x6e04 <itoa+0x2c>
    6e02:	89 5d       	subi	r24, 0xD9	; 217
    6e04:	81 93       	st	Z+, r24
    6e06:	cb 01       	movw	r24, r22
    6e08:	00 97       	sbiw	r24, 0x00	; 0
    6e0a:	a1 f7       	brne	.-24     	; 0x6df4 <itoa+0x1c>
    6e0c:	16 f4       	brtc	.+4      	; 0x6e12 <itoa+0x3a>
    6e0e:	5d e2       	ldi	r21, 0x2D	; 45
    6e10:	51 93       	st	Z+, r21
    6e12:	10 82       	st	Z, r1
    6e14:	c9 01       	movw	r24, r18
    6e16:	0c 94 0d 37 	jmp	0x6e1a	; 0x6e1a <strrev>

00006e1a <strrev>:
    6e1a:	dc 01       	movw	r26, r24
    6e1c:	fc 01       	movw	r30, r24
    6e1e:	67 2f       	mov	r22, r23
    6e20:	71 91       	ld	r23, Z+
    6e22:	77 23       	and	r23, r23
    6e24:	e1 f7       	brne	.-8      	; 0x6e1e <strrev+0x4>
    6e26:	32 97       	sbiw	r30, 0x02	; 2
    6e28:	04 c0       	rjmp	.+8      	; 0x6e32 <strrev+0x18>
    6e2a:	7c 91       	ld	r23, X
    6e2c:	6d 93       	st	X+, r22
    6e2e:	70 83       	st	Z, r23
    6e30:	62 91       	ld	r22, -Z
    6e32:	ae 17       	cp	r26, r30
    6e34:	bf 07       	cpc	r27, r31
    6e36:	c8 f3       	brcs	.-14     	; 0x6e2a <strrev+0x10>
    6e38:	08 95       	ret

00006e3a <__udivmodhi4>:
    6e3a:	aa 1b       	sub	r26, r26
    6e3c:	bb 1b       	sub	r27, r27
    6e3e:	51 e1       	ldi	r21, 0x11	; 17
    6e40:	07 c0       	rjmp	.+14     	; 0x6e50 <__udivmodhi4_ep>

00006e42 <__udivmodhi4_loop>:
    6e42:	aa 1f       	adc	r26, r26
    6e44:	bb 1f       	adc	r27, r27
    6e46:	a6 17       	cp	r26, r22
    6e48:	b7 07       	cpc	r27, r23
    6e4a:	10 f0       	brcs	.+4      	; 0x6e50 <__udivmodhi4_ep>
    6e4c:	a6 1b       	sub	r26, r22
    6e4e:	b7 0b       	sbc	r27, r23

00006e50 <__udivmodhi4_ep>:
    6e50:	88 1f       	adc	r24, r24
    6e52:	99 1f       	adc	r25, r25
    6e54:	5a 95       	dec	r21
    6e56:	a9 f7       	brne	.-22     	; 0x6e42 <__udivmodhi4_loop>
    6e58:	80 95       	com	r24
    6e5a:	90 95       	com	r25
    6e5c:	bc 01       	movw	r22, r24
    6e5e:	cd 01       	movw	r24, r26
    6e60:	08 95       	ret

00006e62 <_exit>:
    6e62:	f8 94       	cli

00006e64 <__stop_program>:
    6e64:	ff cf       	rjmp	.-2      	; 0x6e64 <__stop_program>
